---
layout: post_DoubleMenu_content
title: 数组的扩展
description: 要学习angular ，ES6先撸一撸。
category: es6
imgs: '../source/img/post/basic.jpg'

---
### 一、扩展运算符
#### 含义
扩展运算符是三个点(...)。它就像是rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。
```
console.log(...[1,2,3]);     //1 2 3               
console.log(1,...[2,3,4],5); //1 2 3 4 5

var lis = document.querySelectorAll('li');
console.log(...lis);         // <li></li> <li></li> <li></li>
```
该运算符主要用于函数调用
```
function(array,...values){
	array.push(...values);
}

function add(x,y){
   console.log(x+y);
}
let  data = [1,2];
add(...data); //3
```
上面代码都在函数的调用中用到了扩展运算符。该运算符将一个数组，变为参数序列。

扩展运算符与正常的函数参数可以结合使用，非常灵活。
```
function func(a,b,c,d,e){
  console.log(a+b+c+d+e);
}
func(1,...[2,3],...[4],5);//15
```
扩展运算符后面还可以放置表达式。
```
var x = 1;
let arr = [...(x>0 ? ['a'] : []) , 'b' ];
console.log(arr); //[a,b];
```
如果扩展运算符后面是一个空数组，则不产生任何效果。
```
let arr = [...[],2];
console.log(arr); //[2]
```
注意：扩展运算符如果放在括号中，js引擎就会认为这是函数调用。如果这时不是函数调用，就会报错。
```
let arr = (...[1,2]);    //报错

console.log((...[1,2])); //报错

console.log(...[1,2])    //1,2
```
上面前两种写法会报错，是因为扩展运算符所在的括号不是函数调用。

#### 替代函数的apply方法
由于扩展运算符可以展开数组，所以不再需要使用apply方法将数组转为函数的参数了。
```
function add(x,y,z){
	console.log(x+y+z);
}
let dataArr = [1,2,3];
add.apply(null,dataArr);  //6
add(...dataArr);          //6
```
下面是扩展运算符取代apply的方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法。
```
//es5
Math.max.apply(null,[1,3,4]);
//es6
Math.max(...[1,3,4]);
//等同于
Math.max(1,3,4);
```
上面代码中，由于js不提供数组最大项的函数，只能套用Math.max函数，将数组转化为一个参数序列，然后求最大值。有了扩展运算符之后，就可以直接用Math.max了。

另一个例子是：通过push函数，将一个数组添加到另一个数组的尾部。
```
//es5
var arr1 = [1,2];
var arr2 = [3,4];
arr1.push(...arr2);
//es6
var arr1 = [1,2];
var arr2 = [3,4];
arr1.push(...arr2);
```
es5写法中，push的参数不能是数组，所以只好通过apply方法变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法。

下面是另外一个例子
```
//es5
var date = new (Date.bind.apply(Date, [null, 2015, 1, 1]));
//es6
var date2 = new Date(...[2015, 1, 1]);
```
#### 扩展运算符的应用

##### （1）复制数组
数组是引用型数据类型，直接复制的话，只是复制数组的指针，而不是复制出一个全新的数组。
```
let arr1 = [1,2];
let arr2 = arr1;
arr2[0] = 2;
console.log(arr1);//[2, 2]
```
上面代码中，arr2不是一个全新的数组，而只是跟arr1拥有相同地址的指针。修改arr2，会直接导致arr1的变化。

ES5只能用变通方法来复制数组。
```
let arr1 = [1,2];
let arr2 = arr1.concat();
arr2[0] = 2;
console.log(arr1);//[1,2]
console.log(arr2);//[2,2]
```
上面代码中，arr1使用concat方法后，会返回元素数组的克隆，再修改arr2，就不会对arr1产生影响。

扩展运算符提供了复制数组的简便写法。
```
let arr1 = [1,2];
//写法一
let arr2 = [...arr1];
//写法二
let [...arr3] = [...arr1];
```
上面两种写法，arr2和arr3都是arr1的克隆。
##### (2)数组合并
扩展运算符提供了数组合并的新写法。
```

```










