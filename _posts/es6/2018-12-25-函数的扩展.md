---
layout: post_DoubleMenu_content
title: 函数的扩展
description: 要学习angular ，ES6先撸一撸。
category: es6
imgs: '../source/img/post/basic.jpg'

---
### 一、函数参数的默认值
#### 基本用法
ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法。
```
function log(x,y){
  y = y || 'world';
  console.log(x,y);
}
log() //undefined world
log('Hello') // Hello world
log('Hello', 'abc') // Hello abc
log('Hello', '') // Hello world
```
上面代码检查函数的参数y有没有赋值，如果没有，则指定默认值为world。这种写法的缺点是：如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用，log('Hello','')中y传入空字符串，结果被改为默认值。

为了避免这个问题，通常需要先判断一下参数y是否被赋值，如果没有，再等于默认值。
```
function log(x,y){
  if (typeof y === 'undefined') {
  y = 'World';
 }
  console.log(x,y);
}
log('hello');                //hello world
log('hello' , '');           //hello
log('hello' , 'abc');        //hello abc
log('hello' , undefined);    //hello world
log('hello' , 'undefined');  //hello undefined
```
ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。
```
function log(x,y = 'world'){
  console.log(x,y);
}
log();                       //undefined "world"
log('hello');                //hello world
log('hello' , '');           //hello
log('hello' , 'abc');        //hello abc
log('hello' , undefined);    //hello world
log('hello' , 'undefined');  //hello undefined
```
ES6的写法比ES5简单很多。
```
function func(x = 0,y = 0){
	this.x = x;
	this.y = y;
}
const abc = new func();
console.log(abc);
```
除了写法简洁明了之外，ES6的写法还有两个好处：1.阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体 2. 有利于将来的代码优化，即使代码在未来彻底拿掉这个参数，也不会导致以前的代码无法运行。
【】最后一句啥意思 ? 是执行的时候拿掉参数 ？，声明的时候拿掉参数代码还能运行么？

参数变量默认是声明的，所以不能用let或者const再次声明。
```
function func(x = 0){
	let x = 1; //报错
}
func();
```
使用参数默认值时，函数不能有同名参数。
```
//不报错
function func(x ,x, y){

}
//报错
function func(x,x,y=1){

}
```
注意：参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。
```
let a = 1;
function func(x = a + 1){
	console.log(x);
}
func(); //2
a = 2;
func(); //3
```
上面代码中，函数func的参数x的默认值是a + 1，每次执行都会重新计算a + 1的值，而不是一直等于第一次的结果。

#### 与解构赋值默认值结合使用
参数默认值可以与解构赋值的默认值结合起来使用。
```
function func({x,y=1}){
	console.log(x,y);
}
func({x:1,y:2}); //1,2
func({x:1}); 	 //1,1
func({y:2});     //undefined,2
func({});        //undefined,1
func();          //报错 Cannot destructure property `x` of 'undefined' or 'null'.
```
上面代码给对象的解构赋值设置了默认值值，并没有给函数参数本身设置默认值，只有当函数的参数是一个对象时，变量x和y才会通过解构赋值生成，如果调用函数时没有传递任何参数，不能通过解构赋值生成变量x和y，导致函数出错。知道了这个原因，如果给函数的参数设置一个默认值，就可以避免这种情况。
```
function func({x,y=1} = {}){
	console.log(x,y);
}
func(); //undefined，1
```
上面代码中，如果没有传递参数，默认值为一个空对象。

下面是一个解构赋值默认值的例子。
```
function func(url,{a,b ='abc',c}){
	console.log(b);
}
func('https://xxxx',{});  //abc
func('https://xxxx');  //报错
```
上面代码中，函数func的第二个参数是一个对象，可以给这个对象的三个属性设置默认值，这种写法不能省略第二个参数，这时如果给这个对象（函数的第二个参数）一个参数默认值，就可以省略第二个参数。这时，就有了双重默认值。
```
function func(url,{a,b ='abc',c} = {}){
	console.log(b);
}
func('https://xxxx',{}); //abc
func('https://xxxx');    //abc
```
上面代码中，函数没有传入第二个参数时，函数参数的默认值开始生效，然后是解构赋值的默认值生效，变量b才会取到默认值。

下面两种写法有什么区别？
```
function func({a=1,b=2} = {}){
	console.log(a,b);
}          

function func1({a,b} = {a:1,b:2}){
	console.log(a,b);
}
```
上面两种写法 第一种写法是设置了函数的参数的默认值为一个空对象，但是设置了对象解构赋值的默认值，第二种写法是设置了函数参数的默认值为一个有属性和值的对象，但是没有设置对象解构赋值的默认值。这两种写法的函数传参运行情况如下。
```
//都不传入参数
func();  		 //1,2
func1(); 		 //1,2
//都传入参数
func({a:3,b:4}); //3,4
func1({a:3,b:4});//3,4
//只传入a参数
func({a:5});     //5,2
func1({a:5});    //5,undefined
//传入空对象
func({});        //1,2
func1({});       //undefined,undefined
//传入错误参数
func({a:6,c:7}); //6,2
func1({a:6,c:6});//6,undefined
```
#### 参数默认值的位置
通常情况下，设置了默认值的参数，应该放在参数额最后，这样比较容易看出来省略了哪些参数。如果不是尾部的参数设置了默认值，实际上这个参数是没法省略的。
```
function func(a,b=2,c){
	console.log(a,b,c);
}
func();              //undefined,undefined
func(1);			 //1,2,undefined
func(1,2);           //1,2,undefined
func(1,,3);          //报错
func(1,2,3);         //1,2,3
func(1,undefined,3); //1,2,3
```
上面的函数有默认值的参数是第二个，所以没法只省略第二个参数，而不省略其他参数，除非传入undefined。

如果传入undefined，该参数将等于默认值，null则不是这样。
```
function func(a,b=2,c){
	console.log(a,b,c);
}
func(1,null,3); //1,null,3
```
#### 函数的length属性
函数的length属性，将返回没有制定默认值的参数个数，所以函数参数设置了默认值后，函数的length属性将不准确。
```
var func  = function (a,b,c=3){
};
console.log(func.length); //2
```
上面的函数中，末位参数设置了默认值，所以函数的length返回了2（3-1），之所以这样是因为length的含义是：该函数预期传入的参数个数，某个参数制定默认值之后，预期传入的参数就不包括这个参数了 。 同理， 后文的rest参数也不会计入length。
```
(function(...args) {}).length // 0
```
【】直接复制

如果设置了默认值的的参数不是尾参数，那么这个参数和之后的参数都不计入length。
```
var func  = function (a,b=2,c){
};
console.log(func.length);//1
```
#### 作用域
一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域。等到初始化结束，这个作用域会消失。这种语法行为，在不设置参数默认值时，是不会出现的。
```
let x = 1;
function func(x , y = x){
	console.log(y);
}
func(2);//2
```
上面代码中，参数y的默认值是x，调用函数func时，参数会形成一个单独的作用域。在这个作用域里面，默认值变量等于第一个参数x，而不是全局的x，所以输出是2。

再看下面的例子：
```
let x = 1;
function func(y = x){
	let x = 2;
	console.log(y);
}
func();//1
```
上面的代码中，函数func调用时，参数y=x形成一个单独的作用域。在这个作用域里面，变量x本身没有定义，所以向外寻找全局的变量x。函数调用时，函数体内部的变量x不影响默认值变量x。

如果此时，全局变量x不存在，就会报错。
```
function func(y = x){
	let x = 2;
	console.log(y);
}
func();//x is not defined
```
下面这样写，也会报错。
```
let x = 1;
function func(x = x){
	console.log(x);
}
func();//x is not defined
```
上面代码中，参数x = x形成一个单独的作用域。实际执行的是let x = x，这行代码会报错。

如果参数的默认值是一个函数的，该函数的作用域也遵守这个规则。
```
let foo = 'tx';
function bar(func = () =>foo){
	let foo = '123';
	console.log(func());
}
bar();//tx
```
上面的代码中，函数bar的参数func的默认值是一个匿名函数，返回值为变量foo。函数参数形成的单独作用域里面，并没有定义变量foo，所以向外（全局）寻找变量foo，因此输出tx。

下面这样写，会报错。
```
function bar(func = () =>foo){
	let foo = '123';
	console.log(func());
}
bar(); //报错
```
由于函数参数的单独作用域中没有foo变量，向外寻找的时候全局也没有foo变量，所以报错了。

下面是另一个例子：
```
var x = 1;
function func(x,y = function(){ x = 2;}){
	var x = 3;
	y();
	console.log(x);
}
func();        //3
console.log(x) //1
```
上面代码中，函数func的参数形成了单独的作用域，这个作用域里面，参数y的默认值是一个匿名函数。这个函数的内部变量x，指向同一个作用域中第一个参数x。函数func内部又声明了一个变量x，该变量跟参数x不在同一个作用域，所以不是同一个变量，所以执行y后函数内部的变量x和全局变量x都没有改变。

如果将函数内部的变量x前面的var去掉，函数内部的变量x就指向第一个参数x，与匿名函数的内部是一致的，所以最后输出的就是2，而外层的全局变量x不受影响。
```
var x = 1;
function func(x,y = function(){ x = 2;}){
	x = 3;
	y();
	console.log(x);
}
func();        //3
console.log(x) //1
```
#### 应用
利用默认值参数，可以指定某一个参数不得省略，如果省略就抛出一个错误。
```
function throwIfMissing(){
	throw new Error('Missing');
}
function func(x = throwIfMissing()){
	return x;
}
func(); //Error:Missing
```
上面的函数func参数x的默认值是一个抛出错误的函数，如果这个函数函数调用的时候没有传入参数，就会触发这个默认值函数，从而抛出一个错误。

从上面的函数还可以看到，参数x的默认值等于throwIfMissing函数的运行结果（注意函数名throwIfMissing之后有一对圆括号），这表情参数的默认值不是在定义时执行，而是在运行时执行，如果参数已经传入，那么默认值将不会执行。

可以将参数默认值设置为undefined，这表明这个参数是可以省略的。
```
function func(x = undefined){
	console.log(x);
}
func();//undefined
```
### 二、rest参数
ES6引入rest参数(形式为...变量名)，用于获取函数的多余参数，这样就不用使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。
```
function add(...values){
	let sum = 0;
	for(let val of values){
		sum += val;
	}
	console.log(sum);
}
add(1,2,3);//6
```
上面的函数是一个求和函数，利用rest参数，可以向函数中传入任意数量的参数。

下面是一个rest参数代替arguments变量的例子。
```
//Array.prototype.slice.call将一个具有length属性的对象转化为数组。
function es5sortNumber(){
	console.log(Array.prototype.slice.call(arguments).sort());
}

function es6sortNumber(...numbers){
	console.log(numbers.sort());
}
es5sortNumber(5,3,4,1); //[1, 3, 4, 5]
es6sortNumber(5,3,4,1); //[1, 3, 4, 5]
```
上面的两种写法，明显看出ES6的写法更加简洁。

arguments不是一个数组，而是一个具有length属性的对象。所以为了使用数组方法，必须使用Array.prototype.slice.call将其转为数组。rest参数就不存在这个问题，它本身就是一个纯数组，数组上的方法都可以使用。下面是一个利用rest参数改写数组push方法的例子。
```
function push(array,...items){
	items.forEach(function(item){
		array.push(item);
		console.log(item);
	})
}
var a = [];
push(a,1,2,3,4);
console.log(a) //[1, 2, 3, 4]
```
注意：rest参数之后不能再有其他参数(只能是最后一个参数)，否则会报错。
```
function func(...values,y){} //报错
```
函数的length属性，不包括rest参数。
```
function func(x,...values){};
console.log(func.length); //1
```
### 严格模式
从ES5开始，函数内部可以设定为严格模式。
```
function func(x,y){
	'use strict'
}
```
ES6做了一点修改，规定只要函数设定了默认值、解构赋值、扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。
```
function func(x,y=2){
	'use strict'
}

var func =  function(x,y=1){
	'use strict'
};

function func({x,y}){
	'use strict';
}

function func(...values){
	'use strict';
}
//以上都报错
```
这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是函数执行的时候，先执行函数参数，然后再执行函数体。这样就冲突了，只有从函数体内，才能知道函数参数是否应该以严格模式执行，但是函数参数先于函数体执行。
```
//报错
function func(x = 070){
	'use strict'
	console.log(x);
}
```
上面代码中，函数的参数x的默认值是八进制数070，但是严格模式下不能用前缀0表示八进制，所以应该报错。但是实际上，js引擎会先成功执行x=070，然后执行函数体内部，发现需要用严格模式执行，这时才会报错。

虽然可以先解析函数体代码，再执行参数代码，但是这样无疑增加了复杂性。因此，标准干脆禁止了这种用法，只要参数使用了默认值、解构赋值、扩展运算符就不能显式指定严格模式。

两种方法可以规避这种限制。

第一种：设定全局性的严格模式。
```
'use strict'
function func(x = 1){
	console.log(x);
}
```
第二种：把函数包在一个无参数的立即执行函数里面
```
var func = (function(){
	'use strict';
	return function (x = 1){
		console.log(x);
	}
})();
func();//1
```
### name属性
函数的name属性，返回该函数的函数名。
```
function func(){}
console.log(func.name);
```
这个属性早就支持，到ES6才写入标准。

ES6对这个属性做出了一点修改，如果将一个匿名函数赋值给一个变量，ES5的name属性会返回空字符串，ES6会返回实际的函数名。
```
//es5
var func = function(){}
console.log(func.name); //空字符串
//es6
var func = function(){}
console.log(func.name);//func
```
如果将一个具体名字的函数赋值给一个变量，es5和es6的name属性都会返回这个函数原本的名字。
```
//es5
var func = function foo(){}
console.log(func.name); //foo
//es6
var func = function foo(){}
console.log(func.name); //foo
```
Function构造函数返回的函数实例，name属性的值为anonymous。
```
var func = new Function();
console.log(func.name);//anonymous
```
bind返回的函数，name属性返回会加上bound前缀。
```
var func = new Function();
func.bind({}).name; //bound anonymous

function func(){};
console.log(func.bind({}).name);//bound func

(function(){}).bind({}).name // "bound "
```
### 箭头函数












