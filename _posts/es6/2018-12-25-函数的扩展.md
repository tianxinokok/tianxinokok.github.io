---
layout: post_DoubleMenu_content
title: 函数的扩展
description: 要学习angular ，ES6先撸一撸。
category: es6
imgs: '../source/img/post/basic.jpg'

---
### 一、函数参数的默认值
#### 基本用法
ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法。
```
function log(x,y){
  y = y || 'world';
  console.log(x,y);
}
log() //undefined world
log('Hello') // Hello world
log('Hello', 'abc') // Hello abc
log('Hello', '') // Hello world
```
上面代码检查函数的参数y有没有赋值，如果没有，则指定默认值为world。这种写法的缺点是：如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用，log('Hello','')中y传入空字符串，结果被改为默认值。

为了避免这个问题，通常需要先判断一下参数y是否被赋值，如果没有，再等于默认值。
```
function log(x,y){
  if (typeof y === 'undefined') {
  y = 'World';
 }
  console.log(x,y);
}
log('hello');                //hello world
log('hello' , '');           //hello
log('hello' , 'abc');        //hello abc
log('hello' , undefined);    //hello world
log('hello' , 'undefined');  //hello undefined
```
ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。
```
function log(x,y = 'world'){
  console.log(x,y);
}
log();                       //undefined "world"
log('hello');                //hello world
log('hello' , '');           //hello
log('hello' , 'abc');        //hello abc
log('hello' , undefined);    //hello world
log('hello' , 'undefined');  //hello undefined
```
ES6的写法比ES5简单很多。
```
function func(x = 0,y = 0){
	this.x = x;
	this.y = y;
}
const abc = new func();
console.log(abc);
```
除了写法简洁明了之外，ES6的写法还有两个好处：1.阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体 2. 有利于将来的代码优化，即使代码在未来彻底拿掉这个参数，也不会导致以前的代码无法运行。
【】最后一句啥意思 ? 是执行的时候拿掉参数 ？，声明的时候拿掉参数代码还能运行么？

参数变量默认是声明的，所以不能用let或者const再次声明。
```
function func(x = 0){
	let x = 1; //报错
}
func();
```
使用参数默认值时，函数不能有同名参数。
```
//不报错
function func(x ,x, y){

}
//报错
function func(x,x,y=1){

}
```
注意：参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。
```
let a = 1;
function func(x = a + 1){
	console.log(x);
}
func(); //2
a = 2;
func(); //3
```
上面代码中，函数func的参数x的默认值是a + 1，每次执行都会重新计算a + 1的值，而不是一直等于第一次的结果。

#### 与解构赋值默认值结合使用
参数默认值可以与解构赋值的默认值结合起来使用。
```
function func({x,y=1}){
	console.log(x,y);
}
func({x:1,y:2}); //1,2
func({x:1}); 	 //1,1
func({y:2});     //undefined,2
func({});        //undefined,1
func();          //报错 Cannot destructure property `x` of 'undefined' or 'null'.
```
上面代码给对象的解构赋值设置了默认值值，并没有给函数参数本身设置默认值，只有当函数的参数是一个对象时，变量x和y才会通过解构赋值生成，如果调用函数时没有传递任何参数，不能通过解构赋值生成变量x和y，导致函数出错。知道了这个原因，如果给函数的参数设置一个默认值，就可以避免这种情况。
```
function func({x,y=1} = {}){
	console.log(x,y);
}
func(); //undefined，1
```
上面代码中，如果没有传递参数，默认值为一个空对象。

下面是一个解构赋值默认值的例子。
```
function func(url,{a,b ='abc',c}){
	console.log(b);
}
func('https://xxxx',{});  //abc
func('https://xxxx');  //报错
```
上面代码中，函数func的第二个参数是一个对象，可以给这个对象的三个属性设置默认值，这种写法不能省略第二个参数，这时如果给这个对象（函数的第二个参数）一个参数默认值，就可以省略第二个参数。这时，就有了双重默认值。
```
function func(url,{a,b ='abc',c} = {}){
	console.log(b);
}
func('https://xxxx',{}); //abc
func('https://xxxx');    //abc
```
上面代码中，函数没有传入第二个参数时，函数参数的默认值开始生效，然后是解构赋值的默认值生效，变量b才会取到默认值。

下面两种写法有什么区别？
```
function func({a=1,b=2} = {}){
	console.log(a,b);
}          

function func1({a,b} = {a:1,b:2}){
	console.log(a,b);
}
```
上面两种写法 第一种写法是设置了函数的参数的默认值为一个空对象，但是设置了对象解构赋值的默认值，第二种写法是设置了函数参数的默认值为一个有属性和值的对象，但是没有设置对象解构赋值的默认值。这两种写法的函数传参运行情况如下。
```
//都不传入参数
func();  		 //1,2
func1(); 		 //1,2
//都传入参数
func({a:3,b:4}); //3,4
func1({a:3,b:4});//3,4
//只传入a参数
func({a:5});     //5,2
func1({a:5});    //5,undefined
//传入空对象
func({});        //1,2
func1({});       //undefined,undefined
//传入错误参数
func({a:6,c:7}); //6,2
func1({a:6,c:6});//6,undefined
```
#### 参数默认值的位置
通常情况下，设置了默认值的参数，应该放在参数额最后，这样比较容易看出来省略了哪些参数。如果不是尾部的参数设置了默认值，实际上这个参数是没法省略的。
```
function func(a,b=2,c){
	console.log(a,b,c);
}
func();              //undefined,undefined
func(1);			 //1,2,undefined
func(1,2);           //1,2,undefined
func(1,,3);          //报错
func(1,2,3);         //1,2,3
func(1,undefined,3); //1,2,3
```
上面的函数有默认值的参数是第二个，所以没法只省略第二个参数，而不省略其他参数，除非传入undefined。

如果传入undefined，该参数将等于默认值，null则不是这样。
```
function func(a,b=2,c){
	console.log(a,b,c);
}
func(1,null,3); //1,null,3
```
#### 函数的length属性
函数的length属性，将返回没有制定默认值的参数个数，所以函数参数设置了默认值后，函数的length属性将不准确。
```
var func  = function (a,b,c=3){
};
console.log(func.length); //2
```
上面的函数中，末位参数设置了默认值，所以函数的length返回了2（3-1），之所以这样是因为length的含义是：该函数预期传入的参数个数，某个参数制定默认值之后，预期传入的参数就不包括这个参数了 。 同理， 后文的rest参数也不会计入length。
```
(function(...args) {}).length // 0
```
【】直接复制

如果设置了默认值的的参数不是尾参数，那么这个参数和之后的参数都不计入length。
```
var func  = function (a,b=2,c){
};
console.log(func.length);//1
```
#### 作用域
一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域。等到初始化结束，这个作用域会消失。这种语法行为，在不设置参数默认值时，是不会出现的。
```
let x = 1;
function func(x , y = x){
	console.log(y);
}
func(2);//2
```
上面代码中，参数y的默认值是x，调用函数func时，参数会形成一个单独的作用域。在这个作用域里面，默认值变量等于第一个参数x，而不是全局的x，所以输出是2。

再看下面的例子：
```
let x = 1;
function func(y = x){
	let x = 2;
	console.log(y);
}
func();//1
```
上面的代码中，函数func调用时，参数y=x形成一个单独的作用域。在这个作用域里面，变量x本身没有定义，所以向外寻找全局的变量x。函数调用时，函数体内部的变量x不影响默认值变量x。

如果此时，全局变量x不存在，就会报错。
```
function func(y = x){
	let x = 2;
	console.log(y);
}
func();//x is not defined
```
下面这样写，也会报错。
```
let x = 1;
function func(x = x){
	console.log(x);
}
func();//x is not defined
```
上面代码中，参数x = x形成一个单独的作用域。实际执行的是let x = x，这行代码会报错。

如果参数的默认值是一个函数的，该函数的作用域也遵守这个规则。
```
let foo = 'tx';
function bar(func = () =>foo){
	let foo = '123';
	console.log(func());
}
bar();//tx
```
上面的代码中，函数bar的参数func的默认值是一个匿名函数，返回值为变量foo。函数参数形成的单独作用域里面，并没有定义变量foo，所以向外（全局）寻找变量foo，因此输出tx。

下面这样写，会报错。
```
function bar(func = () =>foo){
	let foo = '123';
	console.log(func());
}
bar(); //报错
```
由于函数参数的单独作用域中没有foo变量，向外寻找的时候全局也没有foo变量，所以报错了。

下面是另一个例子：
```
var x = 1;
function func(x,y = function(){ x = 2;}){
	var x = 3;
	y();
	console.log(x);
}
func();        //3
console.log(x) //1
```
上面代码中，函数func的参数形成了单独的作用域，这个作用域里面，参数y的默认值是一个匿名函数。这个函数的内部变量x，指向同一个作用域中第一个参数x。函数func内部又声明了一个变量x，该变量跟参数x不在同一个作用域，所以不是同一个变量，所以执行y后函数内部的变量x和全局变量x都没有改变。

如果将函数内部的变量x前面的var去掉，函数内部的变量x就指向第一个参数x，与匿名函数的内部是一致的，所以最后输出的就是2，而外层的全局变量x不受影响。
```
var x = 1;
function func(x,y = function(){ x = 2;}){
	x = 3;
	y();
	console.log(x);
}
func();        //3
console.log(x) //1
```
#### 应用










