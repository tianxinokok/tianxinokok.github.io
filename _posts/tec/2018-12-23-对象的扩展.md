---
layout: post_tec
title: 对象的扩展
description: 要学习angular ，ES6先撸一撸。
category: tec
imgs: '../source/img/post/basic.jpg'

---
### 一、属性的简洁表示法
ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。
```
let name = 'tx';
//es6
let obj = {name};
console.log(obj); //{name: "tx"}
//等同于es5
let obj = {name:name};
console.log(obj); //{name: "tx"}
```
上面的代码说明，ES6允许在对象之中，直接写变量。这时，属性名为变量名，属性值为变量的值。
```
function func(x,y){
	return {x,y}
}
func('tx',28);  //{x: "tx", y: 28}
//相当于
function func2(x,y){
	return {
		x:x,
		y:y
	};
}
```
除了属性简写，方法也可以简写。
```
const obj = {
	name:'tx',
	getName() {
		console.log(this.name);
	}
};
obj.getName(); //tx
//等同于
const obj = {
	name:'tx',
	getName:function(){
		console.log(this.name);
	}
};
```
下面是一个实际的例子。
```
let age = 25;
const obj = {
	name:'tx',
	age,
	getName (){ console.log('我的年龄是：' + this.age) ;}
};
obj.getName(); //我的年龄是：25
```
这种写法用于函数的返回值，将会非常方便。
```
function func(){
	let x = 1;
	let y = 2;
	return {x,y};
}
func(); //{x: 1, y: 2}
```
CommonJS模块输出一组变量，就非常合适使用简洁写法。
```
let obj = {};
function getItem(key){
	return key in obj ? obj[key] : null;
}

function setItem(key,value){
	obj[key] = value;
}
function clear(){
	obj  = {};
}

module.exports = { getItem, setItem, clear };
//等同于
module.exports = {
	getItem : getItem,
	setItem : setItem,
	clear   : clear
};
```
注意：简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果。
```
let obj = {
	class (){}
};
//相当于
let obj = {
	'class':function(){}
}
```
上面代码中，class是字符串，所以不会因为他是关键字，而导致语法解析报错。

如果某个方法的值是一个Generator 函数，前面需要加上*号。
```
const obj = {
  * m() {
    yield 'hello world';
  }
};
```
【】Generator 函数

### 二、属性名表达式
js定义对象的属性，有两种方法。
```
//第一种
obj.name = 'tx';
//第二种
obj['na' + 'me'] = 'jl';
```
第一种方法是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在括号之内。

但是如果使用字面量方式定义对象（使用大括号），在ES5中只能使用标识符定义属性。
```
let obj = {
	foo: true,
	abc:123
};
```
ES6允许字面量定义对象时，用表达式作为对象的属性名，即把表达式放在放括号内。
```
let key = 'foo';

let obj = {
	[key] : true,
	['a' + 'bc'] : 123
};
console.log(obj.foo);  //true
console.log(obj.abc);  //123
console.log(obj.key);  //undefined
```
下面是另外一个例子
```
let lastword = 'last word';
let obj = {
	'first word' : 'hello',
	[lastword]   : 'world'
};
console.log(obj['first word']);  //hello
console.log(obj['last word']);   //world
console.log(obj[lastword]);  	 //world
```
表达式还可以用于定于方法名。
```
let obj = {
	['get'+'Hi'](){
		return 'hi';
	}
};
obj.getHi(); //hi
```
注意：属性名表达式与简洁表示法不能同时使用，会报错。
```
//报错
const foo = 'bar';
const baz = { [foo] };

//不报错
const foo = 'bar';
const baz = { [foo] : 'abc' };
```
注意：属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串【object ， Object】,这一点要特别小心。
```
let keyA = {a:1};
let keyB = {b:2};

let obj = {
	[keyA] :  'A',
	[keyB] :  'B'
};
console.log(obj); //{[object Object]: "B"}
```
上面代码中，【keyA】和【keyB】得到的都是【object ，Object】，所以【keyB】会把【keyA】覆盖掉，所以obj最后只有一个【object ， Object】属性，【object ， Object】的值为B。

### 三、方法的name属性
函数的name属性，返回函数名。对象的方法也是函数，因此也有name属性。
```
let obj = {
	getName (){
		return this.name;
	}
};
console.log(obj.getName.name); //getName
```
上面代码中，方法的name属性返回方法名。

有两种特殊情况：bind方法创造的函数，name属性返回bound加原函数的名字，Funciton构造函数创造的函数，name属性返回anonymous。
```
var fun = function(){
	
};
console.log(fun.bind().name); //bound fun

var func = new Function();
console.log(func.name); //anonymous
```
如果对象的方法是一个Symbol值，那么name属性返回的是这个Symbol值的描述。
```
const key1 = Symbol("this is a Symblo");
const key2 = Symbol("");
let obj = {
	[key1](){},
	[key2](){}
};
console.log(obj[key1].name); //[this is a Symblo]
console.log(obj[key2].name); //[]
```
上面代码中，key1对应Symbol值有描述，key2没有。 【】 Symbol还没有学到。

### 四、属性的可枚举性和遍历


#### 可枚举性
对象的每一个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。
```
let obj = {
	name:'tianxin'
};
console.log(Object.getOwnPropertyDescriptor(obj,'name'));
 // {
 // 	value: "tianxin", 
 // 	writable: true, 
 // 	enumerable: true, 
 // 	configurable: true
 // }
```
上面描述对象中的enumerable字段，称为"可枚举性"，如果该属性为false，就表示某些操作会忽略当前属性。

目前，有四个操作会忽略enumerable为false的属性。
##### - for...in循环：只遍历对象自身的和继承的可枚举的属性。
##### - Object.key(): 返回对象自身的所有可枚举的属性的键名。
##### - JSON.stringify() : 只将对象的自身可枚举属性转化为字符串。
##### - Object.assign() : 忽略enumerable为false的属性，只拷贝对象自身的可枚举属性。

这四个操作中，前三个是es5就有的，最后一个Object.assign是es6新增的。其中，只有for...in会返回继承的的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。实际上引入"可枚举"(enumerable)这个概念的最初目的，就是让某些属性可以规避掉for...in操作，不然所有内部属性和方法都会都遍历到。 例如  ， 对象原型的toString方法，以及数组的length属性，就通过"可枚举性"，从而避免被for...in循环到。
```
Object.getOwnPropertyDescriptor(Object.prototype, 'toString').enumerable
// false

Object.getOwnPropertyDescriptor([], 'length').enumerable
// false
```
上面代码中，toString()方法和length属性的enumerable都是false，因此for...in不会遍历到这两个继承自原型的方法和属性。

另外，es6规定，所有Class的原型的方法都是不可枚举的。
```
Object.getOwnPropertyDescriptor(class {foo() {}}.prototype, 'foo').enumerable
// false
```
总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性，所有尽量不用for...in循环，而用Object.keys()代替。
#### 属性的遍历








