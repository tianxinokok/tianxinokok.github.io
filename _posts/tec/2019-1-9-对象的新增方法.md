---
layout: post_tec
title: 对象的新增方法
description: 要学习angular ，ES6先撸一撸。
category: tec
imgs: '../source/img/post/basic.jpg'

---
### 一、Object.is()
es5比较两个值是否相等，只有两个运算符。相等运算符（==）和全等运算符（===）。他们都有缺点，前者会自动转换数据类型，后者的nNaN不等于自身，以及+0等于-0。javascript缺乏一种运算，在所有环境中，只要两个值是一样的，他们就应该像等。

es6提出同值相等算法，用来解决这个问题。Object.is就是部署这个算法的新方法。他用来比较两个值是否严格相等。与全等运算符（===）的作用基本一致。
```
let obj = {a:1};
console.log(Object.is(obj,obj)); //true
console.log(Object.is({},{}));   //true
```
不同之处只有两个：一是+0不等于-0，而是NaN等于自身。
```
console.log(+0 === -0);   //true
console.log(NaN === NaN); //false

console.log(Object.is(+0,-0));   //false
console.log(Object.is(NaN,NaN)); //true
```
es5可以通过下面的代码，实现Object.is()。直接复制的。
```
Object.defineProperty(Object, 'is', {
value: function(x, y) {
if (x === y) {
// 针对+0 不等于 -0的情况
return x !== 0 || 1 / x === 1 / y;
}
// 针对NaN的情况
return x !== x && y !== y;
},
configurable: true,
enumerable: false,
writable: true
});

```
### 二、Object.assign()

#### 基本用法
Object.assign方法用于对象的合并，将源对象的所有可枚举属性，复制到目标对象。
```
let target = {name:'tx'};
let source1 = {age:24};
let source2 = {sex:'男'};
Object.assign(target,source1,source2);
console.log(target); //{name: "tx", age: 24, sex: "男"}
```
Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。

注意：如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。
```
let target = {name:'tx'};
let source1 = {age:24};
let source2 = {name:'123'};
Object.assign(target,source1,source2);
console.log(target); {name: "123", age: 24}
```
如果只有一个参数，Object.assign会直接返回该参数。
```
let obj = {name:'tx'};
console.log(Object.assign(obj) === obj); //true
```
如果该参数不是对象，则会先转成对象，然后返回。
```
console.log(Object.assign(2));        //Number {2}
console.log(typeof Object.assign(2)); //object
```
由于undefined和null无法转成对象，所以如果他们作为参数，就会报错。
```
Object.assign(undefined); //报错
Object.assign(null);      //报错
```
如果非对象参数不是出现在首参数的位置，那么处理规则有点不同，如果不能转成对象的会跳过。也就是说null和undefined如果不在首参数，就不会报错。
```
let obj = {name:'tx'};

console.log(Object.assign(obj,null) === obj);     //true
console.log(Object.assign(obj,undefined) === obj);//true 
```
其他类型的值（即数值，字符串和布尔值），不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝至目标对象，其他值都不会产生效果。
```
let target = {};
let source1 = 'hello';
let source2 = 24;
let source3 = true;
Object.assign(target,source1,source2,source3);
console.log(target); //{0: "h", 1: "e", 2: "l", 3: "l", 4: "o"}
```
上面代码中，只有字符串以数组的形式合入b目标对象，数字合布尔值都会忽略。这是因为只有字符串的包装对象，会产生可枚举属性。

Object.assign只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable:false）。

属性名为Symbol值的属性，也会被Object.assign拷贝。
```
console.log(Object.assign({},{[Symbol('c')]:'d' })); 
//{Symbol(c): "d"}
```
#### 注意点

##### （1）浅拷贝
Object.assign方法实行的是浅拷贝，如果源对象的某个属性值是对象，那么目标对象拷贝得到的是对这个对象的引用。
```
let obj = {a:{b:'tx'}};
let newobj = Object.assign({},obj);
obj.a.b = 'new';
console.log(newobj.a.b); //new
```
上面代码中，源对象a属性的值是一个对象，Object.assign拷贝得到的是这个对象的引用。这个对象的任何变化，都会反应到目标对象上。

##### （2）同名属性的替换
对于嵌套的对象，一旦遇到同名属性，Object.assign的处理方式是替换，而不是添加。
```
let obj = {config:{name:'tx',age:24,sex:'男'}};
let obj2 = {config:{age:'28'}};
Object.assign(obj,obj2);
console.log(obj); //{config: {age:'28'}}
```
上面代码中，obj中的config属性被obj2的config属性这个替换掉了，而不是得到   {config:{name:'tx',age:28,sex:'男'}}的结果，这通常不是开发者想要的，要特别小心。

#####  （3）数组的处理
Object.assign可以用来处理数组，但是会把数组视为对象。
```
let target = [1,2,3];
let source = [4,5];
Object.assign(target,source);
console.log(target); //[4, 5, 3]
```
上面代码中，Object.assign把数组视为属性名为0，1，2的对象，因此源数组的0好属性4和1号属性分别覆盖了目标数组的0号和1号。

#####  （4）取值函数的处理
Object.assign只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。
```
let target = {};
let source = {
get getnum() {
return 1;
}
};
Object.assign(target,source);
console.log(target); //{getnum: 1}
```
上面代码中，源对象的getname属性是一个取值函数，Object不会复制这个取值函数，只会拿到值以后，将这个值复制过去。

#### 常见用途
Object.assign方法有很多用处

##### （1）为对象添加属性
```
class point {
construntor(x,y){
Object.assign(this,{x,y});
}
}
```
上面方法通过Object.assign方法，将x属性和y属性添加到point类的实例对象。【】不太明白。

##### （2）为对象添加方法
```
Object.assign(someClass.prototype,{
someMethod(arg1,arg2){

},
anotherMethod(){

}
});
//等同于下面的写法
someClass.prototype.someMethod = function(arg1,arg2){

};
someClass.prototype.anotherMethod = function(){

};
```
上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用assign方法添加到someClass.prototype之中。

##### （3）克隆对象
```
function clone(origin){
Object.assign({},origin);
}
```
上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。

采用这种克隆方法，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。
```
function clone(origin){
let originProto = Object.getPrototypeOf(origin);
return Object.assign(Object.create(originProto),origin);
}
```
##### (4)   合并多个对象
将多个对象合并到某个对象
```
const mergeobj = (target,...sources) => Object.assign(target,...sources);
```
如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。
```
const mergeobj = (...sources) =>Object.assign({},...sources); 
```
##### (5) 为属性指定默认值(可用作默认配置参数)
```
const defaultconfig = {
name:'tx',
age :24
};

function processContent(options){
options = Object.assign({},defaultconfig,options);
console.log(options);
}
```
上面代码中，defaultconfig对象是默认配置，options是对象提供的参数。通过Object.assign方法将defaultconfig和options合并成一个新对象，如果两者有同名属性，则options的属性值会覆盖defaultconfig的属性值。

注意：由于存在浅拷贝的问题，defaultconfig对象和options对象的所有属性的值，最好都是基本数据类型，不要是复合类型。否则，defaultconfig的该属性很可能不起作用。
```
const  defaultconfig = {
url : {
host : 'tianxinokok.com',
port : '8080'
}
};
function processContent(options){
options = Object.assign({},defaultconfig,options);
console.log(options); 
}
processContent( { url: {port:'123'} } ); //url: {port:'123'}}
```
上面代码的原意是将url.port改成123，url.host不变。实际结果确是options.url覆盖掉defaultconfig.url,导致url.host就不存在了。

### 三、Object.getOwnPropertyDescriptors()



