---
layout: post_tec
title: Class的基本语法
description: 要学习angular ，ES6先撸一撸。
category: tec
imgs: '../source/img/post/basic.jpg'

---

### 一、简介

#### 类的由来
js语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。
```
function func(a,b){
    this.a = a;
    this.b = b;
}
func.prototype.toString = function(){
    return '(' + this.a + ',' + this.b + ')'; 
}
var p =  new func(1,2);
p.toString(); //(1,2)
```
上面这种写法跟传统的面向对象语言相差很大，很容易让新学习这门语言的程序员感到困惑。

es6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过Class关键字，可以定义类。

基本上，es6的class可以看作只是一个语法糖，它的绝大部分功能，es5都可以做大，新的class写法只是让对象原型的写法更加清晰，更像面向对象编程的语法而已。上面的代码用es6的class改写，就是下面这样。
```
class func {
    constructor(a,b){
        this.a = a ;
        this.b = b;
    }

    toString(){
        return '(' + this.a + , this.b + ')' ;
    }
}
```
上面代码定义了一个类 ， 可以看到里面有一个constructor方法，这就是构造方法，而this关键字代表实例对象。也就是说，es5的构造函数func，对应es6的func类的构造方法。

func类除了构造方法，还定义了toString方法。注意，定义类的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去就可以了。而且，方法跟方法之间不需要逗号分隔，加了会报错。

es6的类，完全可以看作构造函数的另一种写法。
```
class func {

}
console.log(typeof func);                          //"function"
console.log(func === func.prototype.constructor);  //true
```
上面代码说明，类的数据类型就是函数，类本身就指向构造函数。

使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。
```
class func {
    getName(){
        console.log('hello')
    }
}
var b = new func();
b.getName(); //"hello"
```
构造函数的prototype属性，在es6的"类"上面继续存在，事实上，类的所有方法都定义在类的prototype属性上面。
```
class func {
    constructor(){

    }
    getName(){

    }
    toString(){

    }
}
//等同于
func.prototype = {
    constructor(){

    },
    getName(){

    },
    toString(){
        
    }
};
```
在类的实例上调用方法，其实就是调用原型上的方法。
```
class B {}
let b = new B();
console.log(b.constructor === B.prototype.constructor); //true
```
上面代码中，b是B类的实例，它的constructor方法就是B类原型上的constructor方法。

由于类的方法都定义在prototype上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便的一次向类添加多个方法。
```
class func {
    constructor(){

    }
}
Object.assign(func.prototype,{
    getName(){},
    toString(){}
});
```
prototype对象的constructor属性，直接指向类的本身，这与es5的行为是一致的。
```
class func {
    constructor(){

    }
}
func.prototype.constructor === func; //true
```
另外，类的内部所有定义的方法，都是不可枚举的。
```
class func {
    constructor(){

    }
    toString(){

    }
}
Object.keys(func.prototype);                //[]
Object.getOwnPropertyNames(func.prototype); //["constructor", "toString"]
```
上面代码中，toString方法是func类内部定义的方法，它是不可枚举的。这一点与es5的行为不一致。
```
var func = function(a,b){

};
func.prototype.toString = function(){

};
Object.keys(func.prototype);                //["toString"]
Object.getOwnPropertyNames(func.prototype); //["constructor","toString"]
```
上面代码采用es5的写法，toString方法就是可枚举的。

#### constructor方法
constructor方法是类的默认方法，通过new命令生成类的实例时，自动调用该方法。一个类一定会有constructor方法，如果没有显示定义，一个空的construction方法会被默认添加。
```
class Point {
}
//等同于
class Point {
    constructor(){
        
    }
}
```
如果定义一个空的类Point，js引擎会自动为他添加一个空的constructor方法。

constructor方法默认会返回实例对象（即this），完全可以指定返回另外一个对象。
```
class Point {
    constructor(){
        return Object.create(null);
    }
}
new Point() instanceof Point ; //false
```
上面代码中，constructor函数返回一个全新的对象，结果导致实例对象不是Point类的实例。

类必须使用new调用，否则会报错。这是他跟普通构造函数的一个主要区别，后者不用new也可以执行。
```
class Point {
}
Point(); // Class constructor Point cannot be invoked without 'new'
```
#### 类的实例
生成类的实例的写法，与es5一样，也是使用new命令，前面已经说过，类的实例如果忘记加new，会报错。

与es5一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。
```
class Point {
    constructor(x,y){
        this.x = x;
        this.y = y;
    }
    toString(){
        return '(' + this.x + ',' + this.y + ')';
    }
}
let point = new Point(1,2);
console.log(point.hasOwnProperty('x'));                   //true
console.log(point.hasOwnProperty('y'));                   //true
console.log(point.hasOwnProperty('toString'));            //false
console.log(point.__proto__.hasOwnProperty('toString'));  //true
```
上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，而toString方法是原型对象的属性（因为定义在Point类上），所以hasOwnPrototype方法返回false。这些都与es5的行为保持一致。

与es5一样，类的所有实例共享一个原型对象。
```
class Point{

}
var x1 = new Point();
var x2 = new Point();
console.log(x1.__proto__ === x2.__proto__); //true
```

