<!DOCTYPE HTML>
<html>
<head>
  <meta charset="UTF-8">
    <link rel="stylesheet" href="/source/css/index.css" type="text/css">
    <link rel="stylesheet" type="text/css" href="/source/css/font-awesome-4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/source/css/post_last.css" type="text/css">
    <link rel="stylesheet" href="/source/css/obsidian.min.css">
    <link rel="icon" href="favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>摆渡先生</title>
   <!-- <link rel="stylesheet" href="/css/highlight.css" type="text/css">-->
</head>

 <body>
   <div class="container">
       <header>
          <svg style="display: none"  version="1.1" xmlns="http://www.w3.org/2000/svg">
    <filter id="grayscale">
        <feColorMatrix type="matrix"  id="ie_svg" values="0.3333 0.3333 0.3333 0 0
                                             0.3333 0.3333 0.3333 0 0 
                                             0.3333 0.3333 0.3333 0 0 
                                             0 0 0 1 0"/>
    </filter>
</svg>
<div class="header">
	<div class="poster_img gray">
	<svg class="box_svg" width="100%" height="100%" >
		<image  class="img_svg" xlink:href="/source/img/index_left.jpg" x="0" y="0" width="100%" height="100%" preserveAspectRatio="xMinYMin slice" filter="url('#grayscale')"></image>
	</svg>	
	</div>
	<div class="header_cover">
		<div class="nav">
			<ul class="nav_ul">
				<li data-subtitle="首页"><a href="/"><i class="fa fa-home"></i></a></li>
				<li data-subtitle="自留地"><a href="/prose"><i class="fa fa-heart"></i></a></li>
				<li data-subtitle="书籍"><a href="/book"><i class="fa fa-book" ></i></a></li>
				<li data-subtitle="微信"><a href="/contact"><i class="fa fa-comments"></i></a></li>
				<li data-subtitle="夜间模式"><i class="fa fa-moon-o"></i></li>
			</ul>
		</div>
	</div>
	<div style="display: none;">
		本站访客数：<span id="busuanzi_value_site_uv"></span>人次
		本站总访问量：<span id="busuanzi_value_site_pv"></span>次
		本文总阅读量：<span id="busuanzi_value_page_pv"></span>次
	</div>
	<div style="display: none;">
			<script type="text/javascript" src="//rf.revolvermaps.com/0/0/6.js?i=52zqlc4vy2q&amp;m=7&amp;c=e63100&amp;cr1=ffffff&amp;f=arial&amp;l=0&amp;bv=90&amp;lx=-420&amp;ly=420&amp;hi=20&amp;he=7&amp;hc=a8ddff&amp;rs=80" async="async"></script>
	</div>
</div>
<div class="bottom_line"></div>
      </header> 
       <div class="content_box">
          <div class="content" >
            <div class="post_content">
                <div class="doubleMenuList">
                    <ul>
                      
                      <li>
                        <div>
                          <div class="post_title">
                          <a class="post-link" href="/es6/2018/12/30/let%E5%92%8Cconst.html" data-post-href="/es6/2018/12/30/let%E5%92%8Cconst.html">let和const</a>
                          </div>
                        </div>
                      </li> 
                      
                      <li>
                        <div>
                          <div class="post_title">
                          <a class="post-link" href="/es6/2018/12/29/%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC.html" data-post-href="/es6/2018/12/29/%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC.html">变量的解构赋值</a>
                          </div>
                        </div>
                      </li> 
                      
                      <li>
                        <div>
                          <div class="post_title">
                          <a class="post-link" href="/es6/2018/12/28/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95.html" data-post-href="/es6/2018/12/28/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95.html">字符串的扩展</a>
                          </div>
                        </div>
                      </li> 
                      
                      <li>
                        <div>
                          <div class="post_title">
                          <a class="post-link" href="/es6/2018/12/27/%E6%AD%A3%E5%88%99%E7%9A%84%E6%89%A9%E5%B1%95.html" data-post-href="/es6/2018/12/27/%E6%AD%A3%E5%88%99%E7%9A%84%E6%89%A9%E5%B1%95.html">正则的扩展</a>
                          </div>
                        </div>
                      </li> 
                      
                      <li>
                        <div>
                          <div class="post_title">
                          <a class="post-link" href="/es6/2018/12/26/%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95.html" data-post-href="/es6/2018/12/26/%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95.html">数值的扩展</a>
                          </div>
                        </div>
                      </li> 
                      
                      <li>
                        <div>
                          <div class="post_title">
                          <a class="post-link" href="/es6/2018/12/25/%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95.html" data-post-href="/es6/2018/12/25/%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95.html">函数的扩展</a>
                          </div>
                        </div>
                      </li> 
                      
                      <li>
                        <div>
                          <div class="post_title">
                          <a class="post-link" href="/es6/2018/12/24/%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95.html" data-post-href="/es6/2018/12/24/%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95.html">数组的扩展</a>
                          </div>
                        </div>
                      </li> 
                      
                      <li>
                        <div>
                          <div class="post_title">
                          <a class="post-link" href="/es6/2018/12/23/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95.html" data-post-href="/es6/2018/12/23/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95.html">对象的扩展</a>
                          </div>
                        </div>
                      </li> 
                      
                      <li>
                        <div>
                          <div class="post_title">
                          <a class="post-link" href="/es6/2018/12/22/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95.html" data-post-href="/es6/2018/12/22/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95.html">对象的新增方法</a>
                          </div>
                        </div>
                      </li> 
                      
                      <li>
                        <div>
                          <div class="post_title">
                          <a class="post-link" href="/es6/2018/12/21/Symbol.html" data-post-href="/es6/2018/12/21/Symbol.html">Symbol</a>
                          </div>
                        </div>
                      </li> 
                      
                      <li>
                        <div>
                          <div class="post_title">
                          <a class="post-link" href="/es6/2018/12/20/Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html" data-post-href="/es6/2018/12/20/Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html">Set 和 Map 数据结构</a>
                          </div>
                        </div>
                      </li> 
                      
                      <li>
                        <div>
                          <div class="post_title">
                          <a class="post-link" href="/es6/2018/12/19/Proxy.html" data-post-href="/es6/2018/12/19/Proxy.html">Proxy</a>
                          </div>
                        </div>
                      </li> 
                      
                      <li>
                        <div>
                          <div class="post_title">
                          <a class="post-link" href="/es6/2018/12/18/Reflect.html" data-post-href="/es6/2018/12/18/Reflect.html">Reflect</a>
                          </div>
                        </div>
                      </li> 
                      
                      <li>
                        <div>
                          <div class="post_title">
                          <a class="post-link" href="/es6/2018/12/17/Promise-%E5%AF%B9%E8%B1%A1.html" data-post-href="/es6/2018/12/17/Promise-%E5%AF%B9%E8%B1%A1.html">Promise 对象</a>
                          </div>
                        </div>
                      </li> 
                      
                      <li>
                        <div>
                          <div class="post_title">
                          <a class="post-link" href="/es6/2018/12/16/Iterator-%E5%92%8C-for...of-%E5%BE%AA%E7%8E%AF.html" data-post-href="/es6/2018/12/16/Iterator-%E5%92%8C-for...of-%E5%BE%AA%E7%8E%AF.html">Iterator 和 for...of 循环</a>
                          </div>
                        </div>
                      </li> 
                      
                      <li>
                        <div>
                          <div class="post_title">
                          <a class="post-link" href="/es6/2018/12/15/Generator-%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95.html" data-post-href="/es6/2018/12/15/Generator-%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95.html">Generator 函数的语法</a>
                          </div>
                        </div>
                      </li> 
                      
                      <li>
                        <div>
                          <div class="post_title">
                          <a class="post-link" href="/es6/2018/12/14/Generator-%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E6%AD%A5%E5%BA%94%E7%94%A8.html" data-post-href="/es6/2018/12/14/Generator-%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E6%AD%A5%E5%BA%94%E7%94%A8.html">Generator 函数的异步应用</a>
                          </div>
                        </div>
                      </li> 
                      
                      <li>
                        <div>
                          <div class="post_title">
                          <a class="post-link" href="/es6/2018/12/13/async-%E5%87%BD%E6%95%B0.html" data-post-href="/es6/2018/12/13/async-%E5%87%BD%E6%95%B0.html">async 函数</a>
                          </div>
                        </div>
                      </li> 
                      
                      <li>
                        <div>
                          <div class="post_title">
                          <a class="post-link" href="/es6/2018/12/12/Class-%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95.html" data-post-href="/es6/2018/12/12/Class-%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95.html">Class 的基本语法</a>
                          </div>
                        </div>
                      </li> 
                      
                      <li>
                        <div>
                          <div class="post_title">
                          <a class="post-link" href="/es6/2018/12/11/Class-%E7%9A%84%E7%BB%A7%E6%89%BF.html" data-post-href="/es6/2018/12/11/Class-%E7%9A%84%E7%BB%A7%E6%89%BF.html">Class 的继承</a>
                          </div>
                        </div>
                      </li> 
                      
                      <li>
                        <div>
                          <div class="post_title">
                          <a class="post-link" href="/es6/2018/12/10/Decorator.html" data-post-href="/es6/2018/12/10/Decorator.html">Decorator</a>
                          </div>
                        </div>
                      </li> 
                      
                      <li>
                        <div>
                          <div class="post_title">
                          <a class="post-link" href="/es6/2018/12/09/Module-%E7%9A%84%E8%AF%AD%E6%B3%95.html" data-post-href="/es6/2018/12/09/Module-%E7%9A%84%E8%AF%AD%E6%B3%95.html">Module 的语法</a>
                          </div>
                        </div>
                      </li> 
                      
                      <li>
                        <div>
                          <div class="post_title">
                          <a class="post-link" href="/es6/2018/12/08/Module-%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0.html" data-post-href="/es6/2018/12/08/Module-%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0.html">Module 的加载实现</a>
                          </div>
                        </div>
                      </li> 
                      
                    </ul>
                </div>
                <div class="doubleMenuContent">
                  <div class="content_title">
                    <h2>数组的扩展</h2>
                    <span id="busuanzi_container_page_pv">
                    <time datetime=""></time>
                    </span>
                  </div>
                   <h3 id="一扩展运算符">一、扩展运算符</h3>
<h4 id="含义">含义</h4>
<p>扩展运算符是三个点(…)。它就像是rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>console.log(...[1,2,3]);     //1 2 3               
console.log(1,...[2,3,4],5); //1 2 3 4 5

var lis = document.querySelectorAll('li');
console.log(...lis);         // &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;
</code></pre>
</div>
<p>该运算符主要用于函数调用</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function(array,...values){
	array.push(...values);
}

function add(x,y){
   console.log(x+y);
}
let  data = [1,2];
add(...data); //3
</code></pre>
</div>
<p>上面代码都在函数的调用中用到了扩展运算符。该运算符将一个数组，变为参数序列。</p>

<p>扩展运算符与正常的函数参数可以结合使用，非常灵活。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(a,b,c,d,e){
  console.log(a+b+c+d+e);
}
func(1,...[2,3],...[4],5);//15
</code></pre>
</div>
<p>扩展运算符后面还可以放置表达式。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var x = 1;
let arr = [...(x&gt;0 ? ['a'] : []) , 'b' ];
console.log(arr); //[a,b];
</code></pre>
</div>
<p>如果扩展运算符后面是一个空数组，则不产生任何效果。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = [...[],2];
console.log(arr); //[2]
</code></pre>
</div>
<p>注意：扩展运算符如果放在括号中，js引擎就会认为这是函数调用。如果这时不是函数调用，就会报错。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = (...[1,2]);    //报错

console.log((...[1,2])); //报错

console.log(...[1,2])    //1,2
</code></pre>
</div>
<p>上面前两种写法会报错，是因为扩展运算符所在的括号不是函数调用。</p>

<h4 id="替代函数的apply方法">替代函数的apply方法</h4>
<p>由于扩展运算符可以展开数组，所以不再需要使用apply方法将数组转为函数的参数了。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function add(x,y,z){
	console.log(x+y+z);
}
let dataArr = [1,2,3];
add.apply(null,dataArr);  //6
add(...dataArr);          //6
</code></pre>
</div>
<p>下面是扩展运算符取代apply的方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>//es5
Math.max.apply(null,[1,3,4]);
//es6
Math.max(...[1,3,4]);
//等同于
Math.max(1,3,4);
</code></pre>
</div>
<p>上面代码中，由于js不提供数组最大项的函数，只能套用Math.max函数，将数组转化为一个参数序列，然后求最大值。有了扩展运算符之后，就可以直接用Math.max了。</p>

<p>另一个例子是：通过push函数，将一个数组添加到另一个数组的尾部。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>//es5
var arr1 = [1,2];
var arr2 = [3,4];
arr1.push(...arr2);
//es6
var arr1 = [1,2];
var arr2 = [3,4];
arr1.push(...arr2);
</code></pre>
</div>
<p>es5写法中，push的参数不能是数组，所以只好通过apply方法变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法。</p>

<p>下面是另外一个例子</p>
<div class="highlighter-rouge"><pre class="highlight"><code>//es5
var date = new (Date.bind.apply(Date, [null, 2015, 1, 1]));
//es6
var date2 = new Date(...[2015, 1, 1]);
</code></pre>
</div>
<h4 id="扩展运算符的应用">扩展运算符的应用</h4>

<h5 id="1复制数组">（1）复制数组</h5>
<p>数组是引用型数据类型，直接复制的话，只是复制数组的指针，而不是复制出一个全新的数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr1 = [1,2];
let arr2 = arr1;
arr2[0] = 2;
console.log(arr1);//[2, 2]
</code></pre>
</div>
<p>上面代码中，arr2不是一个全新的数组，而只是跟arr1拥有相同地址的指针。修改arr2，会直接导致arr1的变化。</p>

<p>ES5只能用变通方法来复制数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr1 = [1,2];
let arr2 = arr1.concat();
arr2[0] = 2;
console.log(arr1);//[1,2]
console.log(arr2);//[2,2]
</code></pre>
</div>
<p>上面代码中，arr1使用concat方法后，会返回元素数组的克隆，再修改arr2，就不会对arr1产生影响。</p>

<p>扩展运算符提供了复制数组的简便写法。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr1 = [1,2];
//写法一
let arr2 = [...arr1];
//写法二
let [...arr3] = [...arr1];
</code></pre>
</div>
<p>上面两种写法，arr2和arr3都是arr1的克隆。</p>
<h5 id="2数组合并">（2）数组合并</h5>
<p>扩展运算符提供了数组合并的新写法。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr1 = [1,2];
let arr2 = [3];
let arr3 = [4,5];
//es5
let arr4 = arr1.concat(arr2,arr3);
//es6
let arr5 = [...arr1,...arr2,...arr3];
</code></pre>
</div>
<p>不过，这两种方法都是浅拷贝，使用的时候需要注意。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr1 = [1,2];
let arr2 = [3,4];

let arr3 = arr1.concat(arr2);
let arr4 = [...arr1,...arr2];
arr3[0] === arr1[0]; //true
arr4[0] === arr1[0]; //true
</code></pre>
</div>
<p>【】这里阮一峰原文好像有点问题。
测试结论如下：上面两种方法在原数组是一维（数组内没有嵌套数组）的情况下用concat和扩展运算符拷贝后是深拷贝，修改拷贝后数组的值，不会影响到原数组。但是如果原数组中有嵌套的数组情况就不一样了，看下面代码。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr1 = [1,2,['abc']];
let arr2 = [3,4];

let arr3 = arr1.concat(arr2);
let arr4 = [...arr1,...arr2];

arr3[length - 3][0] = 'z'; //这里修改拷贝后数组中嵌套数组的值。
arr1[2]                    //z  原数组也修改了 
</code></pre>
</div>
<p>从上面的代码可以看出，如果原数组中有数组的嵌套，那么通过concat或者扩展运算符拷贝拷贝新数组后的第一层数组是深拷贝，嵌套的数组是浅拷贝，如果修改新数组内部嵌套数组的值，原数组的值也会发生改变。</p>
<h5 id="3与解构赋值结合">（3）与解构赋值结合</h5>
<p>扩展运算符可以与解构赋值结合起来，用于生成数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = [1,2,3,4];
//es5赋值
let a = arr[0];
let b = arr.slice(1);
//es6
[a,...b] = arr;
</code></pre>
</div>
<p>下面是另外一些例子。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = [1,2,3,4];
[first,...rest] = arr;
console.log(first); //1
console.log(rest);  //[2,3,4]

[first,...rest] = [];
console.log(first); //undefined
console.log(rest);  //[]

[first,...rest] = ['abc'];
console.log(first); //abc
console.log(rest);  //[]
</code></pre>
</div>
<p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>[...rest,first] = arr; //报错：Rest element must be last element
</code></pre>
</div>
<h5 id="4字符串">（4）字符串</h5>
<p>扩展运算符还可以将字符串转为真正的数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>[...'hello']; //["h", "e", "l", "l", "o"]
</code></pre>
</div>
<p>上面的写法有一个好处，那就是能够正确识别四个字节的Unicode字符。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>'x\uD83D\uDE80y'.length      //4
[...'x\uD83D\uDE80y'].length //4 
</code></pre>
</div>
<p>【】上面第二条用了扩展运算符之后结果还是4，原文打印的是3。？</p>
<h5 id="5实现了iterator接口的对象">（5）实现了Iterator接口的对象</h5>
<p>任何定义了遍历器(Iterator)接口的对象，（参阅Iterator一章），都可以用扩展运算符转为真正的数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let lis = document.querySelectorAll('li');
let arr = [...lis]; //[&lt;li&gt;&lt;/li&gt;]
</code></pre>
</div>
<p>上面代码中，querySelectorAll方法返回的是一个NodeList对象。不是数组，而是一个类似数组的对象。这时候如果用扩展运算符既可以将其转为真正的数组，原因就在于NodeList对象实现了Iterator。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Number.prototype[Symbol.iterator] = function*() {
  let i = 0;
  let num = this.valueOf();
  while (i &lt; num) {
    yield i++;
  }
}
console.log(...5);//0 1 2 3 4
</code></pre>
</div>
<p>【】Symbol.iterator不懂</p>

<p>实现的结果就是返回0到扩展运算符后面数字（不包括本身）的所有整数。</p>

<p>对于那些没有部署Iterator接口的类似数组的对象，扩展运算符就不能把他们转为真正的数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let obj = {
	name : 'tx',
	length:1
};
[...obj]; //报错 obj is not iterable
</code></pre>
</div>
<p>上面代码中，obj是一个对象，但是没有Iterator接口，扩展运算符就会报错。这时可以改为使用Array.from（下面快到了）方法将obj转为真正的数组。</p>
<h5 id="6map-和-set-结构generator-函数">（6）Map 和 Set 结构，Generator 函数</h5>
<p>扩展运算符内部调用的是数据结构的Iterator 接口，因此只要是具有Iterator 接口的对象，都可以使用扩展运算符，例如map结构。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let map = new Map([
	[1,'a'],
	[2,'b'],
	[3,'c']
]);
let arr = [...map.keys()]; //[1, 2, 3]
</code></pre>
</div>
<p>Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let go = function*(){
  yield 1;
  yield 2;
  yield 3;
};
[...go()] // [1, 2, 3])
</code></pre>
</div>
<p>【】上面函数看不懂</p>

<p>如果对没有Iterator 接口的对象使用扩展运算符，将会报错。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>const obj ={
	name:"tx",
	age:12
};
[...obj]; //报错
</code></pre>
</div>

<h3 id="二arrayfrom">二、Array.from()</h3>
<p>Array.from方法可以将两类对象转为真正的数组：类似数组的对象和可遍历的(iterable)对象(包括ES6 新增的数据结构 Set 和 Map)。</p>

<p>下面是一个类似数组的对象，Array.from可以把他转为真正的数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let obj = {
	"0" : 'tx',
	"1"  :'25',
	 length:2
};
//es5
let arr1 = [].slice.call(obj); //["tx", "25"]
//es6
let arr2 = Array.from(obj);    //["tx", "25"]
</code></pre>
</div>
<p>实际应用中，常见的类似数组的的对象是DOM返回的的NodeList集合，以及函数内部的arguments对象。Array.from()都可以将他们转为真正的数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>//NodeList集合
let lis = document.querySelectorAll('li');

Array.from(lis).filter( li =&gt;{
	if(li.textContent.length &gt; 1){
		console.log(li);
	}
})
//arguments对象
function func(){
	var args = Array.from(arguments);
}
</code></pre>
</div>
<p>上面代码中，querySelectorAll方法返回的是一个类似数组的对象，可以将这个对象转为数组，再使用filter方法【】。</p>

<p>只要是部署了Iterator 接口的数据结构，Array.from会返回一个一模一样的新数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var arr = Array.from([1,2,3]); //[1, 2, 3]
</code></pre>
</div>
<p>值得注意的是，扩展运算符也可以将某些数据结构转为数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(){
	let args = [...arguments];
}

[...document.querySelectorAll('li')]
</code></pre>
</div>
<p>扩展运算符背后调用的的是遍历器接口(Symbal.iterator)，如果一个对象没有部署这个接口，就无法转换。Array.from方法还支持类似数组的的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此任何有length属性的对象，都可以通过Array.from方法转为数组，但是这种情况扩展运算符是不能转换的</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var obj = {
	"name":"tx",
	"age" :28,
	length:2
};
var arr = Array.from(obj); //[undefined, undefined]

var obj = {
	"0":"tx",
	"1" :28,
	length:2
};
var arr = Array.from(obj); //["tx", 28]
</code></pre>
</div>
<p>上面这种情况，扩展运算符就会报错。</p>

<p>对于还没有部署该方法的环境，可以用Array.prototype.slice方法替代。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let toarray = (()=&gt; 
	Array.from  ? Array.from : obj=&gt; [].slice.call(obj)
)();
</code></pre>
</div>
<p>Array.from还可以接受第二个参数，作用跟数组的map方法类似。用来对每个元素进行处理，将处理后的值放入返回的数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = Array.from([1,2,3], x =&gt; x*x);      //[1, 4, 9]
let arr2 = Array.from([1,2,3]).map( x=&gt; x*x); //[1, 4, 9]
</code></pre>
</div>
<p>下面的例子是取出一组dom节点的文本内容。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let lis = document.querySelectorAll('li');
//map()
let LiTextcontent = Array.prototype.map.call(lis,x =&gt; x.textContent);
//Array.from()
let LiTextcontent2 = Array.from(lis,x=&gt;x.textContent);
</code></pre>
</div>
<p>下面的例子将数组中布尔值为false的成员转为0。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = Array.from([1,,2,false,4], x =&gt; x||0); //[1, 0, 2, 0, 4]
</code></pre>
</div>
<p>下面的例子是返回各种数据的类型。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(){
	return Array.from(arguments,x =&gt; typeof x);
}
datatype(1,NaN,'abc');//["number", "number", "string"]
</code></pre>
</div>
<p>如果map函数里面用到了this，还可以传入Array.from的第三个参数，用来绑定this。【】</p>

<p>Array.from可以将各种值转为真正的数组，并且还提供map功能。这实际上意味着，只要有一个原始的数据结构，就可以点对他的值进行处理，然后转成规范的数组结构，进而就可以使用数组上面的方法。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = Array.from({length:2}, () =&gt; 'tx') // ["tx", "tx"]
</code></pre>
</div>
<p>上面代码中，Array.from的第一个参数指定了第二个参数运行的次数。这种特性可以让Array.from的用法非常灵活。</p>

<p>Array.from的另一个应用是，将字符串转为数组，然后返回字符出的长度。因为他能正确处理各种Unicode 字符，可以避免js将大于\uFFFF的 Unicode 字符，算作两个字符的 bug。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function countSymbols(string) {
  return Array.from(string).length;
}
countSymbols('x\uD83D\uDE80y'); //3 这里可以正确打印x\uD83D\uDE80y的长度。
</code></pre>
</div>
<p>上面的代码证明了用Array.from转换后可以正确打印Unicode字符的长度，上文中用扩展运算符就不可以。</p>
<h3 id="三arrayof">三、Array.of()</h3>
<p>Array.of()方法用于将一组值转换为数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = Array.of(1,2,3); //[1, 2, 3]
Array.of(1,2).length;      //2
</code></pre>
</div>
<p>这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致
Array()的行为有差异。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = Array(1,2,3); //[1, 2, 3]
let arr = Array(2);     //[empty × 2]
let arr = Array();      //[]
</code></pre>
</div>
<p>上面代码中，Array方法三个参数、一个参数、没有参数时，返回结果都不一样。只有当参数个数不少于2个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上指定的是数组的长度。</p>

<p>Array.of()基本上可以替代Array()和new Array()，并且不存在由于参数不同而导致的的重载。他的行为非常统一。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Array.of();           //[]
Array.of(undefined);  //[undefined]
Array.of(2);          //[2]
</code></pre>
</div>
<p>Array.of()总是返回参数值组成的数组。如果没有参数，就返回一个空数组。</p>

<p>Array.of()方法可以用下面的函数模拟实现。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function arrayOf(){
	return [].slice.call(arguments);
}
</code></pre>
</div>
<h3 id="四数组实例的copywithin方法">四、数组实例的copyWithin()方法</h3>
<p>数组实例的copyWithin()方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），返回当前数组。使用这个方法，会修改当前数组。</p>

<p>他有三个参数。</p>

<p>（参数1）target（必须）→从该位置开始替换数据。如果为负值，表示倒数。</p>

<p>（参数2）start  （可选） →从该位置选取要复制的源数据，默认为0。如果为负值，表示倒数。</p>

<p>（参数3）end  （可选）  →到该位置停止选取复制的值。如果为负值，表示倒数。</p>

<p>这三个都应该是数值，如果不是，会自动转为数值。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = [1,2,3,4,5].copyWithin(0,3); //[4, 5, 3, 4, 5]
</code></pre>
</div>
<p>上面代码表示将从3号位直到最后的成员（4，5）。复制到从0号位开始的位置，结果复制了原来的1和2。</p>

<p>下面是更多的例子。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>//将3号位复制到0号位
let arr = [1,2,3,4,5].copyWithin(0,3,4); //[4, 2, 3, 4, 5]

//-2从后面数是正着数的3号位，-1从后面数是正着数的4号位
let arr = [1,2,3,4,5].copyWithin(0,-2,-1); //[4, 2, 3, 4, 5]

//如果没有部署TypedArray 的 copyWithin 的环境，用下面的方法
[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4); //Int32Array [4, 2, 3, 4, 5]
</code></pre>
</div>
<p>【】上面最后一个例子看不懂</p>

<h3 id="五数组实例的find和findindex">五、数组实例的find()和findIndex()</h3>
<p>数组实例的find方法，用于找出第一个符合条件的数组成员。他的参数是一个回调函数</p>


                </div>
            </div>
          </div>
       </div>
    </div>
  </body>
  <script src="/source/js/highlight.min.js"></script>
  <script type="text/javascript" src="/source/js/jquery.js"></script>
  <script type="text/javascript" src="/source/js/index.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>
</html>