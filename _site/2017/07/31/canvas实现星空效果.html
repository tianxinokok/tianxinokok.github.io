 <!DOCTYPE HTML>
<html>
<head>
  <meta charset="UTF-8">
    <link rel="stylesheet" href="/source/css/index.css" type="text/css">
    <link rel="stylesheet" type="text/css" href="/source/css/font-awesome-4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/source/css/post_last.css" type="text/css">
    <link rel="stylesheet" href="/source/css/obsidian.min.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
   <!-- <link rel="stylesheet" href="/css/highlight.css" type="text/css">-->
</head>

   <div class="container">
       <header>
          <svg style="display: none"  version="1.1" xmlns="http://www.w3.org/2000/svg">
    <filter id="grayscale">
        <feColorMatrix type="matrix"  id="ie_svg" values="0.3333 0.3333 0.3333 0 0
                                             0.3333 0.3333 0.3333 0 0 
                                             0.3333 0.3333 0.3333 0 0 
                                             0 0 0 1 0"/>
    </filter>
</svg>
<div class="header">
	<div class="poster_img gray">
	<svg class="box_svg" width="100%" height="100%" >
		<image  class="img_svg" xlink:href="/source/img/index_left.jpg" x="0" y="0" width="100%" height="100%" preserveAspectRatio="xMinYMin slice" filter="url('#grayscale')"></image>
	</svg>	
	</div>
	<div class="header_cover">
		<div class="nav">
			<ul class="nav_ul">
				<li data-subtitle="首页"><a href="/"><i class="fa fa-home"></i></a></li>
				<li data-subtitle="技术"><a href="/"><i class="fa fa-html5"></i></a></li>
				<li data-subtitle="瞎扯"><a href="/"><i class="fa fa-heart"></i></a></li>
				<li data-subtitle="联系"><a href="/"><i class="fa fa-comments"></i></a></li>
				<li data-subtitle="夜间模式"><a href="/"><i class="fa fa-moon-o"></i></a></li>
			</ul>
		</div>
	</div>
</div>
      </header> 
       <div class="content_box">
          <div class="content" >
            <div class="post_content">
                <div class="content_title">
                  <h1>canvas实现满天繁星运动效果</h1>
                  <span><time datetime=""></time></span>
                </div>
                  <h3 id="一写在前面的逼逼叨">一、写在前面的逼逼叨</h3>
<p>话说作为一个学习计算机专业的学生，大学一定上过动效制作类的课程（课程名字可能不同），我的印象中就有这么一个场景，一个胖胖的女老师，在讲台上温柔的告诉你，学好flash动画，你才能做出酷炫的网页，如果学不好flash，你做的网页就跟一潭死水一样，没有酷酷的效果，那时正是css3刚刚提起，还没有定版的时候，短短几年，随着前端技术的不断发展，想要在网站上实现动画效果，已经有多种方案供我们选择，并且性能上有质的飞跃，让flash在制作网页动画方面慢慢退出历史舞台，不知道曾经的老师，是不是还在教用flash做动画，毕竟老师教什么教材，不是老师决定的，逼逼叨到此结束，今天的主角是<code class="highlighter-rouge">&lt;canvas&gt;</code>，一个牛逼赫赫的神秘男子。</p>

<h3 id="二管他神秘不神秘">二、管他神秘不神秘</h3>
<p>是骡子是马，拉出来溜溜，说了这么多它的好话，具体怎么用，好不好用应该是说的重点，毕竟我是个实用主义者，不喜欢华而不实的东东。canvas你可以称之为画布，画布这个词听过吧，啥?没听过，去死吧，有了画布，在上面画出我们想要的图画，再用橡皮擦掉，再画上一幅图画，再擦，再画，再擦，重复上述过程，动画不就出来了嘛，就像童年时期玩的动画小人书。</p>

<p><img src="/test/canvas_star/img/fsdg.gif" alt="翻书动画" /></p>

<p><span class="s">//连环画是很多张画布，canvas是只有一张画布，快速重复绘图-擦掉-绘图-擦的过程,此处仅仅是为了展示动画效果。<span></span></span></p>
<h3 id="三从基础开始">三、从基础开始</h3>
<p><code class="highlighter-rouge">&lt;canvas&gt;</code>是这个html属性是为客户端矢量图形而设计的，他自己本身没有画图能力，本身只提供一张画布，但他会把整个绘图API展现给javascript，让javascript在他的画布内创作出我们想要的图像。让我们来看看他提供了哪些API供我们绘图。</p>

<p><span class="s">//篇幅有限，仅展示一些常用API</span></p>

<p><strong>Rect(矩形左上角x坐标，矩形左上角y坐标，矩形宽度，矩形高度)</strong>  ：看名字就知道了，创建一个矩形，仅仅是创建了一个路径而已，所以看上去还是一张白纸哦。</p>

<p>html</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;canvas id="rect"&gt;&lt;/canvas&gt;
</code></pre>
</div>
<p>js</p>

<div class="highlighter-rouge"><pre class="highlight"><code>var mycanvas = document.getElementById('rect');
var content     = mycanvas.context();
content.Rect(0,0,100,50);
</code></pre>
</div>
<div>
<canvas id="rect" style="border:1px solid #d3d3d3;"></canvas>
<script>
var mycanvas = document.getElementById('rect');
var content     = mycanvas.getContext('2d');
content.rect(0,0,100,50);
</script>
</div>

<p>看~白纸吧，所谓路径你可以想象成隐藏的线条，所以只要说到路径，就肯定是不可见的，要对路径有所动作才能让他显现出来。</p>

<p><strong>fillRect(矩形左上角x坐标，矩形左上角y坐标，矩形宽度，矩形高度)</strong>：看这个英文名称就知道了，充满-矩形，所以他的作用就是把我们绘制的矩形路径给填充填色，既然填充颜色了肯定就能看见了吧。</p>

<p>js</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var mycanvas = document.getElementById('fillrect');
var content     = mycanvas.getContext('2d');
content.fillRect(0,0,200,100);
</code></pre>
</div>

<div>
<canvas id="fillrect" style="border:1px solid #d3d3d3;"></canvas>
<script>
var mycanvas = document.getElementById('fillrect');
var content     = mycanvas.getContext('2d');
content.fillRect(0,0,200,100);
</script>
</div>
<p>这样我们就绘制填充了一个左上角坐标为（0，0），宽度200px, 高度100px，默认为黑色的矩形。</p>

<p><strong>strokeRect(矩形左上角x坐标，矩形左上角y坐标，矩形宽度，矩形高度)</strong>：这个方法跟<code class="highlighter-rouge">fillRect</code>对比记忆就可以了，<code class="highlighter-rouge">fillRect()</code>是为矩形填充颜色，充满整个矩形，<code class="highlighter-rouge">strokeRect()</code>就是为矩形画个框框，里面不填充。</p>

<p>js</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var mycanvas = document.getElementById('strokerect');
var content     = mycanvas.getContext('2d');
content.strokeRect(0,0,200,100);
</code></pre>
</div>

<div>
<canvas id="strokerect" style="border:1px solid #d3d3d3;"></canvas>
<script>
var mycanvas = document.getElementById('strokerect');
var content     = mycanvas.getContext('2d');
content.strokeRect(0,0,200,100);
</script>
</div>
<p><strong>clearRect(要清除的矩形左上角的 x 坐标，要清除的矩形左上角的 y 坐标，要清除的矩形的高度，要清除的矩形的高度)</strong>：前面都是绘制，填充矩形，这个方法是在指定的一个举行内扣除一个矩形。</p>

<p>js</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var mycanvas = document.getElementById('clearrect');
var content     = mycanvas.getContext('2d');
content.fillRect(0,0,200,100);
content.clearRect(20,20,100,50);
</code></pre>
</div>
<div>
<canvas id="clearrect" style="border:1px solid #d3d3d3;"></canvas>
<script>
var mycanvas = document.getElementById('clearrect');
var content     = mycanvas.getContext('2d');
content.fillRect(0,0,200,100);
content.clearRect(20,20,100,50);
</script>
</div>
<p>上面的四个方法都是作用于矩形的，下面让我们认识一些所有图形都通用的方法。</p>

<p><strong>fill()</strong>：这个字面意义就理解了，填充嘛，就是为所创建的路径填充颜色的。因为既然是填充，就应该是一个封闭的路径，所以说如果路径不封闭，fill()方法会从路径结束点到路径开始点之间添加一条线，以关闭该路径，再填充路径。</p>

<p>js</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var mycanvas = document.getElementById('fill');
var content     = mycanvas.getContext('2d');
content.rect(0,0,200,100);//还记得第一个例子中rect()是创建一个路径对吧，路径是看不见的，我们用fill()给填充下就能看到矩形了。
content.fill(); 
</code></pre>
</div>

<div>
<canvas id="fill" style="border:1px solid #d3d3d3;"></canvas>
<script>
var mycanvas = document.getElementById('fill');
var content     = mycanvas.getContext('2d');
content.rect(0,0,200,100);
content.fill();
</script>
</div>
<p><strong>beginPath()、closePath()、moveTo()、lineTo()</strong> ：这四个一起介绍。都是关于创建路径的。</p>

<p><strong>beginPath()</strong>：开始或者是重置当前路径。</p>

<p><strong>closePath()</strong>：创建从当前点到开始点的路径。</p>

<p><strong>moveTo(目标位置的x坐标，目标位置的y坐标)</strong>：把路径移动到画布中的指定点，不创建线条。</p>

<p><strong>lineTo(目标位置的x坐标，目标位置的y坐标)</strong>：该方法添加一个新的点，创建从该点到画布中最后指定点的路径。</p>

<p>因为都是关于路径的，还记得前面说过的，路径不可见，所以演示肯定就看不到效果，跟下一个要介绍的<code class="highlighter-rouge">stroke</code>方法一起演示才有效果。</p>

<p><strong>stroke()</strong>：此方法是实际的绘制出已经定义的路径，注意<code class="highlighter-rouge">实际</code>二字了吧，前面那写moveTo(),lineTo()创建的路径都是不可见的，此方法就是让那些不可见的路径浮出水面。很牛逼的赶脚。</p>

<p>js</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var mycanvas = document.getElementById('four_canvas');
var content     = mycanvas.getContext('2d');
content.beginPath();
content.moveTo(20,20);//我把原点移动到了（20，20）
content.lineTo(20,100);//我创建了一个新的点
content.lineTo(50,100);//我创建了最后一个新的点
content.closePath();//那条斜边的路径就是我创建的
content.stroke();  //你们创建了那么多，没有我还不是看不到
</code></pre>
</div>
<div>
<canvas id="four_canvas" style="border:1px solid #d3d3d3;"></canvas>
<script>
var mycanvas = document.getElementById('four_canvas');
var content     = mycanvas.getContext('2d');
content.beginPath();
content.moveTo(20,20);
content.lineTo(20,100);
content.lineTo(50,100);
content.closePath();
content.stroke();
</script>
</div>
<p><strong>arc(圆心的x坐标，圆心的y坐标，圆半径，起始角以弧度计，结束角以弧度计，可选顺时针绘图或者逆时针绘图)</strong> ：前面介绍了很多创建矩形路径的，这个方法是创建弧/曲线（圆或部分圆）的路径，如果要创建圆，请把起始角参数设置为0，结束角参数设置为2*Math.PI，起始角和结束角都以弧度记，<em>(人们规定360度为2PI，PI就是180度，用这样的方法换算就可以了)</em>，同样也是绘制的路径，要想可见，要配合<code class="highlighter-rouge">fill()</code>或者<code class="highlighter-rouge">stroke()</code>绘制实际的弧。</p>

<p>js</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var mycanvas = document.getElementById('arc');
var content     = mycanvas.getContext('2d');
content.arc(100,80,50,0,2*Math.PI);
content.stroke();
</code></pre>
</div>
<div>
<canvas id="arc" width="600px" style="border:1px solid #d3d3d3;"></canvas>
<script>
var mycanvas = document.getElementById('arc');
var content     = mycanvas.getContext('2d');

content.fillText("结束角2*Math.PI",50,20);
content.arc(100,80,50,0,2*Math.PI);
content.stroke();
content.beginPath();
content.arc(150,80,5,0,2*Math.PI);
content.fillStyle="red";
content.fill();
content.fillStyle="black";
content.beginPath();
content.fillText("结束角Math.PI",180,20);
content.arc(220,80,50,0,Math.PI);
content.stroke();
content.beginPath();
content.fillText("结束角Math.PI / 2",310,20);
content.arc(340,80,50,0,Math.PI/2);
content.stroke();
content.beginPath();
content.fillText("结束角Math.PI / 3",440,20);
content.arc(460,80,50,0,Math.PI/3);
content.stroke();
</script>
</div>
<div class="highlighter-rouge"><pre class="highlight"><code>var mycanvas = document.getElementById('arc_fill');
var content     = mycanvas.getContext('2d');
content.arc(100,80,50,0,2*Math.PI);
content.fill();
</code></pre>
</div>
<div>
<canvas id="arc_fill" width="600px" style="border:1px solid #d3d3d3;"></canvas>
<script>
var mycanvas = document.getElementById('arc_fill');
var content     = mycanvas.getContext('2d');
content.fillText("结束角2*Math.PI",50,20);
content.arc(100,80,50,0,2*Math.PI);
content.fill();
content.beginPath();
content.arc(150,80,5,0,2*Math.PI);
content.fillStyle="red";
content.fill();
content.fillStyle="black";
content.beginPath();
content.fillText("结束角Math.PI",180,20);
content.arc(220,80,50,0,Math.PI);
content.fill();
content.beginPath();
content.fillText("结束角Math.PI / 2",310,20);
content.arc(340,80,50,0,Math.PI/2);
content.fill();
content.beginPath();
content.fillText("结束角Math.PI / 3",440,20);
content.arc(460,80,50,0,Math.PI/3);
content.fill();
</script>
</div>
<p>可以看出，绘制的起始角为0度的角是图中红色圆点，正好是钟表的3点时刻，方便记忆，绘制方向为顺时针。</p>

<p>上面介绍的方法都是在画布上画图形，或者线条的方法，也就是素描的样子，没有色彩，下面就介绍一些给画面添加颜色的属性和方法。给我们的画面上色。</p>

<p><strong>createLinearGradient(渐变开始点的 x 坐标，渐变开始点的 y 坐标，	渐变结束点的 x 坐标，渐变结束点的 y 坐标)，createRadialGradient(渐变开始点的 x 坐标，渐变开始点的 y 坐标，	渐变结束点的 x 坐标，渐变结束点的 y 坐标)</strong>：这两个方法都是创建渐变用的，<code class="highlighter-rouge">createLinearGradient()</code>是创建线性渐变，<code class="highlighter-rouge">createRadialGradient()</code>是创建放射性渐变，这两个方法必须和下一个<code class="highlighter-rouge">addColorStop()</code>方法和下下个fillStyle()或者strokeStyle()属性配合使用才能看到渐变色的效果。</p>

<p><strong>addColorStop(介于 0.0 与 1.0 之间的值，表示渐变中开始与结束之间的位置，在结束位置显示的 CSS 颜色值)</strong>：学习渐变的时候就说过，有渐变就一定要创建渐变的开始点和结束点，开始颜色和结束颜色，如果不对渐变（gradient）对象使用该方法，那么渐变将不可见，所以说为了渐变可见，我们需要创建至少一个色标。</p>

<p><strong>fillStyle(),strokeStyle()</strong> : 这两个属性是设置我们绘制图像要填充的颜色，渐变或者模式。现在我们创建了渐变<code class="highlighter-rouge">createLinearGradient()</code>,并且为渐变添加了色标<code class="highlighter-rouge">addColorStop()</code>,但是要在canvas绘制出一个渐变色的图形，要通过这个两个属性告诉canvas我们确定要用渐变绘图，他才能知道我们要使用渐变绘图。前面所有创建的黑色矩形或者是黑色圆圈，都是因为这个属性的默认值是#000000，语法为：<code class="highlighter-rouge">context.fillStyle=color|gradient|pattern</code></p>

<p>js</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var mycanvas = document.getElementById('fillstyle');
var content     = mycanvas.getContext('2d');
content.fillStyle = "green";  //只用单色填充
content.fillRect(0,0,200,100);
</code></pre>
</div>
<div>
<canvas id="fillstyle" style="border:1px solid #d3d3d3;"></canvas>
<script>
var mycanvas = document.getElementById('fillstyle');
var content     = mycanvas.getContext('2d');
content.fillStyle = "green"; 
content.fillRect(0,0,200,100);
</script>
</div>
<div class="highlighter-rouge"><pre class="highlight"><code>var mycanvas = document.getElementById('strokestyle');
var content     = mycanvas.getContext('2d');
content.strokeStyle = "green"; //只用单色绘制，可以理解为用绿色的铅笔画图
content.strokeRect(0,0,200,100);
</code></pre>
</div>
<div>
<canvas id="strokestyle" style="border:1px solid #d3d3d3;"></canvas>
<script>
var mycanvas = document.getElementById('strokestyle');
var content     = mycanvas.getContext('2d');
content.strokeStyle = "green";
content.strokeRect(0,0,200,100);
</script>
</div>
<div class="highlighter-rouge"><pre class="highlight"><code>var mycanvas = document.getElementById('gradient');
var content     = mycanvas.getContext('2d');
var grd = content.createLinearGradient(0,0,170,0);
grd.addColorStop(0,"#8D0DA8");
grd.addColorStop(0.5,"#354FD7");
grd.addColorStop(1,"#40AB51");
content.fillStyle = grd;   //使用渐变色填充
content.fillRect(0,0,200,100);
</code></pre>
</div>
<div>
<canvas id="fillgradient" style="border:1px solid #d3d3d3;"></canvas>
<script>
var mycanvas = document.getElementById('fillgradient');
var content     = mycanvas.getContext('2d');
var grd = content.createLinearGradient(0,0,170,0);
grd.addColorStop(0,"#8D0DA8");
grd.addColorStop(0.5,"#354FD7");
grd.addColorStop(1,"#40AB51");
content.fillStyle = grd;
content.fillRect(0,0,200,100);
</script>
</div>
<div class="highlighter-rouge"><pre class="highlight"><code>var mycanvas = document.getElementById('strokestyle');
var content     = mycanvas.getContext('2d');
var grd = content.createLinearGradient(0,0,170,0); //创建一个线性渐变，开始坐标为（0，0），结束坐标为（170，0）。
grd.addColorStop(0,"#8D0DA8");// 添加一个色标
grd.addColorStop(0.5,"#354FD7"); // 又一个色标
grd.addColorStop(1,"#40AB51");  //最后一个色标
content.strokeStyle = grd;  //使用渐变色绘制，可以理解为渐变色的画笔。
content.strokeRect(0,0,200,100);  //实际绘制
</code></pre>
</div>
<div>
<canvas id="strokegradient" style="border:1px solid #d3d3d3;"></canvas>
<script>
var mycanvas = document.getElementById('strokegradient');
var content     = mycanvas.getContext('2d');
var grd = content.createLinearGradient(0,0,170,0);
grd.addColorStop(0,"#8D0DA8");
grd.addColorStop(0.7,"#354FD7");
grd.addColorStop(1,"#40AB51");
content.strokeStyle = grd;
content.strokeRect(0,0,200,100);
</script>
</div>
<p><strong>font</strong>：这个属性就理解成css中的font属性就可以，规定文字的字体，大小，粗细。语法为：	<code class="highlighter-rouge">context.font="italic small-caps bold 12px arial";</code></p>

<p><strong>fillText()，strokeText()</strong>：这两个方法就是用来在canvas绘制文字用的。</p>

<p>js</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var mycanvas = document.getElementById('font');
var content     = mycanvas.getContext('2d');
content.font = "40px KaiTi";
content.fillText("我是canvas绘制出的文字",20,50);
</code></pre>
</div>
<div>
<canvas id="fillText" width="600px" style="border:1px solid #d3d3d3;"></canvas>
<script>
var mycanvas = document.getElementById('fillText');
var content     = mycanvas.getContext('2d');
content.font = "40px KaiTi";
content.fillText("我是canvas绘制出的文字",20,50);
</script>
</div>
<div class="highlighter-rouge"><pre class="highlight"><code>var mycanvas = document.getElementById('font');
var content     = mycanvas.getContext('2d');
content.font = "40px KaiTi";
content.strokeText("我是canvas绘制出的文字",20,50);
</code></pre>
</div>
<div>
<canvas id="strokeText" width="600px" style="border:1px solid #d3d3d3;"></canvas>
<script>
var mycanvas = document.getElementById('strokeText');
var content     = mycanvas.getContext('2d');
content.font = "40px KaiTi";
content.strokeText("我是canvas绘制出的文字",20,50);
</script>
</div>

<p>如果配合前面的<code class="highlighter-rouge">fillStyle()</code>,<code class="highlighter-rouge">strokeStyle()</code>填充样式和绘制样式，就能画出很漂亮的文字</p>

<p>js</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var mycanvas = document.getElementById('textstyle');
var content     = mycanvas.getContext('2d');
var grd           = content.createLinearGradient(0,0,mycanvas.width,0);
grd.addColorStop(0,'#8919B7');
grd.addColorStop("0.5","blue");
grd.addColorStop("1.0","red");
content.font = "40px KaiTi";
content.fillStyle  = grd;
content.fillText("我是canvas绘制出的文字",20,50);
</code></pre>
</div>
<div>
<canvas id="textstyle" width="600px" style="border:1px solid #d3d3d3;"></canvas>
<script>
var mycanvas = document.getElementById('textstyle');
var content     = mycanvas.getContext('2d');
var grd           = content.createLinearGradient(0,0,mycanvas.width,0);
grd.addColorStop(0,'#8919B7');
grd.addColorStop("0.5","blue");
grd.addColorStop("1.0","red");
content.font = "40px KaiTi";
content.fillStyle  = grd;
content.fillText("我是canvas绘制出的文字",20,50);
</script>
</div>
<div class="highlighter-rouge"><pre class="highlight"><code>var mycanvas = document.getElementById('textstyle2');
var content     = mycanvas.getContext('2d');
var grd           = content.createLinearGradient(0,0,mycanvas.width,0);
grd.addColorStop(0,'#8919B7');
grd.addColorStop("0.5","blue");
grd.addColorStop("1.0","red");
content.font = "40px KaiTi";
content.strokeStyle  = grd;
content.strokeText("我是canvas绘制出的文字",20,50);
</code></pre>
</div>
<div>
<canvas id="textstyle2" width="600px" style="border:1px solid #d3d3d3;"></canvas>
<script>
var mycanvas = document.getElementById('textstyle2');
var content     = mycanvas.getContext('2d');
var grd           = content.createLinearGradient(0,0,mycanvas.width,0);
grd.addColorStop(0,'#8919B7');
grd.addColorStop("0.5","blue");
grd.addColorStop("1.0","red");
content.font = "40px KaiTi";
content.strokeStyle  = grd;
content.strokeText("我是canvas绘制出的文字",20,50);
</script>
</div>
<p>这个效果很赞吧，想象一下，空心的文字渐变效果如果用别的方法实现怎么实现呢？我目前真的想不到别的办法了，平时的渐变属性应用实体文字是有效果的，空心的可就无能为力，是不是深深的感觉到canvas的强大，除此之外，canvas还能绘制图片，视频，简直不能再牛逼了，剩下的一些API就不展示了，留到以后折腾出好玩的东西再单独举例展示，去撒个尿~~
回来继续。</p>

<h3 id="四漫天繁星终于到了">四、漫天繁星终于到了</h3>
<p>梳理了一下基础知识，毕竟要灵活运用，基础是最重要的，地基搭不好，楼房盖不起来，盖起来也是危房。下面就是我们的漫天繁星的效果了，先来看下demo。<a href="/test/canvas_star/rect_star.html" target="_blank">漫天繁星</a></p>

<p>整体思路：</p>

<p>1.准备一张画布.</p>

<p>2.绘制位置，透明度随机的星星。</p>

<p>3.改变星星位置和透明度的draw方法。</p>

<p>4.画布不停的清除-绘制。</p>

<p>难点在于：越靠近屏幕上面天空越黑，星星越稠密，反之，余晖附近，星星很少。</p>

<p>html</p>
<div class="highlighter-rouge"><pre class="highlight"><code>&lt;canvas id="mycanvas" class="mycanvas"&gt;&lt;/canvas&gt;
</code></pre>
</div>
<p>css</p>
<div class="highlighter-rouge"><pre class="highlight"><code>body{
	background: url(img/area.jpg) no-repeat;
	background-color: #000;
	background-size:cover;
}
.mycanvas{
	position: absolute;
	width: 1920px;
	height: 800px;
	left: 50%;
	margin-left: -960px;
}
</code></pre>
</div>

<p>必要的js</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var getMinRandom = function(){   //此函数大概率返回一个数值较大的值。因此就有了越往上越稠密的分布。
		var rand = Math.random();
		//step的大小决定了往上的聚拢程度。
		var step = Math.ceil(1 / (1 - rand));
		var arr  = [];
		for(var i = 0 ; i &lt;step; i++){
			arr.push(Math.random());
		}
		return Math.max.apply(null,arr);
	};
</code></pre>
</div>

<p>其他详细js代码就不贴了，如果有需要的话直接在demo中右键查看吧。</p>

<h3 id="结语">结语</h3>
<p>此demo的效果并非原创，参考自张鑫旭博客中的一篇文章，主要想借机梳理和练习一下有关canvas的知识，待日后自己弄出好玩的东西会更新上来，菜鸟一枚，有不妥之处希望同行多多指教。</p>

<p>貌似一会儿要下大雨，得赶紧下班回家，嗯 ，就这样。</p>

                <div class="comment_box">
                    <!-- UY BEGIN -->
                    <div class="chakan">查看评论</div>
                    <div id="uyan_frame"></div>
                    <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2126846"></script>
                    <!-- UY END -->
                </div>
            </div>
          </div>
       </div>
    </div>
  <script src="/source/js/highlight.min.js"></script>
  <script type="text/javascript" src="/source/js/jquery.js"></script>
  <script type="text/javascript" src="/source/js/index.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
    $(document).ready(function(){
      $('.chakan').on('click',function(){
         $('#uyan_frame').toggleClass('show');
      })
    })
  </script>