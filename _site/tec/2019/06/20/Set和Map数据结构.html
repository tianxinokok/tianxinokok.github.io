<!DOCTYPE HTML>
<html>
<head>
  <meta charset="UTF-8">
    <link rel="stylesheet" href="/source/css/index.css" type="text/css">
    <link rel="stylesheet" href="/source/css/post_last.css" type="text/css">
    <link rel="stylesheet" href="/source/css/obsidian.min.css">
    <link rel="stylesheet" type="text/css" href="/source/css/font-awesome-4.7.0/css/font-awesome.min.css">
    <link rel="icon" href="/source/img/Favicon.png" sizes="32x32" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>摆渡先生</title>
</head>

 <body>
 <div class="nav_box" style="z-index: 10000">
<nav class="nav">
	<ul class="nav__list">
		<li class="nav__item">
			<a class="nav__link" href="/">
				<div class="nav__link-content">
					<span class="nav__link-num">01</span>
					<div class="nav__link-title">Works</div>
					<div class="nav__link-desc">What I'm made</div>
				</div>
				<div class="nav__link-base"></div>
			</a>
			<div class="nav__item-line"></div>
		</li>
		<li class="nav__item">
			<a class="nav__link" href="/new">
				<div class="nav__link-content">
					<span class="nav__link-num">02</span>
					<div class="nav__link-title">News</div>
					<div class="nav__link-desc">Latest ramblings</div>
				</div>
				<div class="nav__link-base"></div>
			</a>
			<div class="nav__item-line"></div>
		</li>
		<li class="nav__item">
			<a class="nav__link" href="/book">
				<div class="nav__link-content">
					<span class="nav__link-num">03</span>
					<div class="nav__link-title">Books</div>
					<div class="nav__link-desc">Many good books</div>
				</div>
				<div class="nav__link-base"></div>
			</a>
			<div class="nav__item-line"></div>
		</li>
		<li class="nav__item">
			<a class="nav__link" href="/contact">
				<div class="nav__link-content">
					<span class="nav__link-num">04</span>
					<div class="nav__link-title">Contact</div>
					<div class="nav__link-desc">Don't be shy</div>
				</div>
				<div class="nav__link-base"></div>
			</a>
			<div class="nav__item-line"></div>
		</li>
        <li class="phone_btn_close nav__item">
            x
        </li>
	</ul>
  <div class="header_logo">
    <svg version="1.1"  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
   viewBox="0 0 825 299" style="enable-background:new 0 0 825 299;" xml:space="preserve">
<g class="logo_baidu">
  <path class="st0 logo_baidu_letter" fill="#fff" d="M132.94,183.58c-5.84,0.73-10.94,1.46-15.31,2.19c-2.19,0.73-4.02,0-5.47-2.19c0-5.1,1.82-8.02,5.47-8.75
    c3.64,0.73,8.75,1.09,15.31,1.09c0-5.1-0.37-10.2-1.09-15.31c0-2.91,1.09-4.38,3.28-4.38c7.29,0.73,10.57,3.65,9.84,8.75
    c-0.73,2.92-1.09,6.56-1.09,10.94h8.75c2.91,0.73,4.38,2.19,4.38,4.38c-2.19,1.46-6.56,2.19-13.13,2.19v9.84
    c7.29-1.45,11.3-1.45,12.03,0c0.73,2.19-3.28,4.74-12.03,7.66c0,11.67,0.36,21.52,1.09,29.53c0.73,5.84-1.46,10.21-6.56,13.13
    c-4.38,2.19-10.94,1.83-19.69-1.09c-7.3-3.64-11.3-7.29-12.03-10.94c17.5,4.38,26.25,3.65,26.25-2.19c0.73-9.48,0.73-17.86,0-25.16
    c-8.75,2.92-14.95,4.74-18.59,5.47c-2.92,0-4.74-1.45-5.47-4.38c-0.73-3.64,0.73-5.83,4.38-6.56c5.1-0.73,11.66-1.82,19.69-3.28
    V183.58z M217.16,162.8c3.64,0.73,5.47,3.28,5.47,7.66c-1.46,5.84-2.19,11.67-2.19,17.5c-0.73,3.65-2.92,5.11-6.56,4.38
    c-6.56-1.45-12.77-2.19-18.59-2.19c-0.73,2.19-0.73,4.38,0,6.56h14.22c3.64,0,5.83,0.73,6.56,2.19c0.73,2.92-1.09,4.38-5.47,4.38
    h-15.31c-0.73,2.19-0.73,4.38,0,6.56c15.31,0.73,28.8,0.73,40.47,0c-5.11,10.94-12.4,14.22-21.88,9.84
    c-6.56-2.19-13.13-3.28-19.69-3.28l-5.47,6.56c-2.92,2.92-5.11,5.47-6.56,7.66c3.64,2.92,7.66,4.02,12.03,3.28
    c5.1-1.45,8.38-3.28,9.84-5.47c-1.46-0.73-3.28-1.82-5.47-3.28c0.73-3.64,2.55-5.47,5.47-5.47c2.91-0.73,6.2,0.73,9.84,4.38
    c5.1,4.38,8.75,8.39,10.94,12.03c2.19,4.38,0.73,5.84-4.38,4.38c-3.65-2.91-7.66-5.83-12.03-8.75c-5.11,7.3-11.3,10.58-18.59,9.84
    c-8.02-3.64-13.13-5.1-15.31-4.38c-2.92,0.73-5.84,1.83-8.75,3.28c-2.92,0.73-5.11-0.36-6.56-3.28c-0.73-2.19,0-4.01,2.19-5.47
    c2.91-2.19,5.83-4.01,8.75-5.47c6.56-3.64,10.57-6.92,12.03-9.84c-14.59,0.73-24.06,1.83-28.44,3.28
    c-3.65,0.73-5.11-0.73-4.38-4.38c1.45-3.64,3.28-5.83,5.47-6.56c6.56,1.46,15.67,1.83,27.34,1.09c0.73-2.19,0.73-4.38,0-6.56
    c-7.3,0-13.49,0.37-18.59,1.09c-3.65,0.73-4.74-1.09-3.28-5.47c1.45-1.45,3.64-2.55,6.56-3.28c5.1,0.73,10.2,1.09,15.31,1.09
    c0.73-2.19,0.73-4.38,0-6.56c-6.56,0-11.67,0.73-15.31,2.19c-3.65,1.46-5.84,0.37-6.56-3.28c-0.73-8.75-1.46-15.67-2.19-20.78
    c0-4.38,2.55-6.2,7.66-5.47C181.8,164.99,198.93,164.99,217.16,162.8z M167.94,170.46c-0.73,2.92-0.73,7.3,0,13.13
    c3.64,1.46,6.56,1.46,8.75,0c0.73-4.38,0.73-8.75,0-13.13C174.51,169.73,171.58,169.73,167.94,170.46z M184.35,183.58
    c3.64,0.73,6.56,0.73,8.75,0c0.73-5.1,0.73-9.48,0-13.13c-2.92-0.73-5.84-0.73-8.75,0C183.62,175.57,183.62,179.94,184.35,183.58z
     M200.76,170.46c-0.73,3.65-0.73,8.02,0,13.13c4.38,1.46,7.66,1.46,9.84,0c2.19-3.64,2.55-8.02,1.09-13.13
    C208.05,169.73,204.4,169.73,200.76,170.46z"/>
  <path class="st0 logo_baidu_letter" fill="#fff" d="M255.44,189.05c8.75,2.92,17.5,5.11,26.25,6.56c1.45,0.73,1.45,1.83,0,3.28c-5.84,2.19-11.3,3.28-16.41,3.28
    c-7.3,0.73-13.13,0-17.5-2.19c-2.92-2.19-2.92-5.1,0-8.75C249.98,189.05,252.52,188.33,255.44,189.05z M255.44,216.4
    c8.75-1.45,17.5-4.01,26.25-7.66c1.45-0.73,2.55-0.73,3.28,0c-2.19,4.38-5.11,8.02-8.75,10.94c-4.38,3.65-10.94,6.93-19.69,9.84
    c-2.92,0-5.11-1.82-6.56-5.47C249.24,219.68,251.07,217.13,255.44,216.4z M262.01,166.08c7.29,5.11,14.95,9.48,22.97,13.13
    c-0.73,1.46-4.38,2.19-10.94,2.19s-12.77-1.45-18.59-4.38c-2.19-1.45-2.92-3.28-2.19-5.47
    C254.71,167.18,257.63,165.36,262.01,166.08z M313.41,186.87c-4.38-0.73-8.39-0.36-12.03,1.09c0,5.84-0.73,13.13-2.19,21.88
    c-0.73,4.38-2.19,8.39-4.38,12.03c-2.19,3.65-4.38,6.56-6.56,8.75c-5.11,4.38-9.48,6.93-13.13,7.66c-2.92,0-5.47-0.36-7.66-1.09
    c-1.46-1.45-2.55-2.55-3.28-3.28c2.91-2.19,6.2-4.01,9.84-5.47c3.64-2.19,6.92-5.1,9.84-8.75c2.19-3.64,4.01-7.29,5.47-10.94
    c1.45-5.83,2.19-11.3,2.19-16.41c0.73-8.75-0.37-16.04-3.28-21.88c0-4.38,2.19-6.56,6.56-6.56c4.38,1.46,12.39,2.19,24.06,2.19
    v-6.56c1.45-2.91,4.38-4.01,8.75-3.28c2.19,0.73,4.01,1.83,5.47,3.28v6.56h20.78c6.56,0,9.84,1.46,9.84,4.38
    c-1.46,1.46-7.66,2.19-18.59,2.19c-1.46,2.92-1.46,5.47,0,7.66h8.75c5.83,0,8.75,1.09,8.75,3.28s-1.09,3.28-3.28,3.28h-14.22
    c-0.73,3.65-0.73,6.93,0,9.84c0.73,3.65-1.09,5.11-5.47,4.38c-2.92-1.45-5.84-2.55-8.75-3.28c-2.19,0-4.38,0-6.56,0
    c-2.19,0.73-4.02,1.46-5.47,2.19c-3.65,0.73-5.47-0.36-5.47-3.28C314.14,192.33,314.14,189.05,313.41,186.87z M314.51,202.18
    c2.19,0.73,4.38,1.09,6.56,1.09c7.29-0.73,14.95-0.36,22.97,1.09c5.1,1.46,6.92,4.02,5.47,7.66c-2.19,2.92-5.11,6.93-8.75,12.03
    c16.04,5.11,28.07,7.66,36.09,7.66c-7.3,10.94-14.59,14.58-21.88,10.94c-6.56-4.38-13.49-8.75-20.78-13.13
    c-9.48,5.11-17.87,8.75-25.16,10.94c-6.56,1.46-10.58-0.73-12.03-6.56c0.73-0.73,4.73-1.82,12.03-3.28
    c8.02-1.45,14.22-3.64,18.59-6.56c-4.38-2.91-8.39-5.47-12.03-7.66c0-3.64,1.82-5.1,5.47-4.38c3.64,2.19,7.66,4.74,12.03,7.66
    c2.91-2.19,4.73-4.73,5.47-7.66c0.73-2.19-0.73-3.28-4.38-3.28c-6.56,0-12.77,0.37-18.59,1.09c-3.65,2.19-5.84,2.19-6.56,0
    C309.76,205.46,311.58,202.91,314.51,202.18z M313.41,172.65c-3.65-0.73-8.02-0.73-13.13,0c-0.73,2.92-0.73,5.47,0,7.66
    c4.38,0.73,8.75,0.73,13.13,0C314.14,177.39,314.14,174.83,313.41,172.65z M322.16,172.65c-0.73,2.92-0.73,5.47,0,7.66
    c5.1,0.73,9.48,0.73,13.13,0c0.73-2.91,0.73-5.47,0-7.66C330.91,171.92,326.54,171.92,322.16,172.65z M336.38,186.87
    c-4.38-0.73-9.12-0.73-14.22,0c0,1.46,0,3.28,0,5.47c4.38,0.73,8.38,0.73,12.03,0C336.38,192.33,337.11,190.51,336.38,186.87z"/>
</g>
<polyline class="st1 logo_baidu_border" points="409.5,179.35 409.5,261 81.5,261 81.5,140 367.18,140 " fill="none" stroke="#fff" stroke-miterlimit="10" stroke-width="16"/>
<g class="logo__plus" fill="none" stroke="#fff" stroke-miterlimit="10" stroke-width="16">
  <line class="st1 logo__plus-horz" x1="382.5" y1="140.5" x2="436.5" y2="140.5"/>
  <!-- <path class="st1" d="M411.5,117.5"/> -->
  <line class="st1 logo__plus-vert" x1="409.5" y1="167.5" x2="409.5" y2="113.5"/>
</g>
<g class="logo__xiansheng">
  <path class="st2 logo_xiansheng_letter" fill="#fff" d="M484.78,60.65c-5.11,3.65-9.12,5.47-12.03,5.47c-4.38,0-5.47-1.09-3.28-3.28c5.1-2.91,8.75-8.02,10.94-15.31
    c1.45-6.56,3.64-9.48,6.56-8.75c2.91,0,4.73,1.46,5.47,4.38c0,3.65-1.09,6.56-3.28,8.75h16.41V39.87c0-4.38,1.82-6.92,5.47-7.66
    c6.56,0,9.84,2.92,9.84,8.75V51.9h25.16c4.38,0,6.2,1.83,5.47,5.47c-0.73,2.19-2.19,3.28-4.38,3.28h-26.25v8.75
    c10.94,0,22.6,0.37,35,1.09c2.91,0,4.73,1.09,5.47,3.28c0.73,4.38-1.83,6.56-7.66,6.56c-10.21-0.73-19.69-1.09-28.44-1.09v10.94
    c0,8.02,6.56,12.03,19.69,12.03c14.58,0.73,26.25-1.45,35-6.56c-2.92,10.94-6.2,17.5-9.84,19.69c-7.3,5.11-17.87,5.84-31.72,2.19
    c-5.11-1.45-9.48-3.28-13.13-5.47c-7.3-4.38-11.3-10.57-12.03-18.59V79.24h-6.56c-0.73,4.38-2.55,9.48-5.47,15.31
    c-6.56,9.48-14.22,16.05-22.97,19.69c-7.3,2.92-14.59,3.65-21.88,2.19c-6.56-2.91-8.75-5.83-6.56-8.75
    c24.79-0.73,40.1-10.2,45.94-28.44c-5.84-0.73-13.49,0-22.97,2.19c-7.3,2.19-10.58,0.73-9.84-4.38c3.64-5.83,6.92-8.38,9.84-7.66
    c8.02,1.46,18.95,1.46,32.81,0v-8.75H484.78z"/>

  <path class="st3 logo_xiansheng_letter" fill="#fff" d="M645.29,63.43c-6.56-0.73-14.22-0.73-22.97,0c-2.92,3.65-7.3,6.93-13.13,9.84c-2.92,0.73-4.02,0-3.28-2.19
    c5.83-6.56,9.84-13.48,12.03-20.78c2.19-8.75,6.2-12.03,12.03-9.84c4.38,2.92,3.64,8.02-2.19,15.31h17.5
    c0.73-6.56,0.73-12.39,0-17.5c0-4.38,2.19-6.92,6.56-7.66c5.83,0,8.75,2.55,8.75,7.66c0,8.75,0.36,14.59,1.09,17.5h22.97
    c8.02-0.73,12.03,0.73,12.03,4.38c2.19,3.65-9.48,4.74-35,3.28c-1.46,3.65-1.46,7.3,0,10.94l21.88,1.09c2.91,0,6.2,0.73,9.84,2.19
    c1.45,2.92,1.09,4.74-1.09,5.47c-8.75-0.73-18.23-0.73-28.44,0c-2.19,0-3.28,3.65-3.28,10.94c0.73,6.56,16.04,8.02,45.94,4.38
    c3.64,0,8.02-0.73,13.13-2.19c-3.65,16.77-12.03,22.97-25.16,18.59c-22.61-8.02-48.13-10.2-76.56-6.56
    c-10.94,2.19-17.87,3.65-20.78,4.38c-5.84,1.46-8.02-0.36-6.56-5.47c2.91-5.83,6.92-9.48,12.03-10.94
    c2.91-0.73,7.29-0.36,13.13,1.09c18.95,2.19,28.8,1.46,29.53-2.19c1.45-8.02,0-12.03-4.38-12.03c-7.3-0.73-14.22,0-20.78,2.19
    c-4.38,1.46-5.84-0.36-4.38-5.47c0.73-2.19,2.91-4.38,6.56-6.56c2.91-1.45,5.83-1.09,8.75,1.09c5.83,0.73,10.2,0.73,13.13,0
    C646.38,72.91,646.74,69.27,645.29,63.43z"/>
</g>
<polyline class="st1 logo_xiansheng_border" points="409.5,101.65 409.5,20 737.5,20 737.5,141 451.82,141 " fill="none" stroke="#fff" stroke-miterlimit="10" stroke-width="16"/>
</svg>
  </div>
</nav>
<svg class="nav__bg" width="100%" height="100%" viewBox="0 0 100 100" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg">
    <defs>
        <linearGradient class="nav__grad" x1="92.6356902%" y1="7.36430977%" x2="0%" y2="100%" id="nav-grad">
            <!-- <stop stop-color="#000000" offset="20%"></stop>
            <stop stop-color="#223e36" offset="100%"></stop> -->
            <!-- <stop stop-color="#43C6AC" offset="20%"></stop>
            <stop stop-color="#191654" offset="100%"></stop> -->
            <stop stop-color="#00dbde" offset="20%"></stop>
            <stop stop-color="#fc00ff" offset="100%"></stop>
        </linearGradient>
		<mask id="nav__bg-mask" class="nav__bg-mask" maskUnits="userSpaceOnUse"x="0" y="0" width="100" height="100">
		  	<rect class="nav__bg-mask-rect" x="0" y="0" width="25" height="100" fill="white"/>
			<rect class="nav__bg-mask-rect" x="24.9" y="0" width="25.1" height="100" fill="white"/>
			<rect class="nav__bg-mask-rect" x="49.9" y="0" width="25.1" height="100" fill="white"/>
			<rect class="nav__bg-mask-rect" x="74.9" y="0" width="25.1" height="100" fill="white"/>
		</mask>
    </defs>
    <rect x="0" y="0" width="100" height="100" fill="url(#nav-grad)" mask="url(#nav__bg-mask)"></rect>
</svg>
 <!--pc_menu_btn--> 
<button class="nav-btn">
  <svg class="burger <?php echo $darkBurgerClass; ?>" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 36 36">
  <rect class="burger__stroke"  x="2" y="2" width="32" height="32" fill="none" stroke="" stroke-miterlimit="10" stroke-width="4"/>
  <polyline class="burger__stroke-over"points="18 2 34 2 34 34 2 34 2 2 18 2" fill="none" stroke="" stroke-miterlimit="10" stroke-width="4"/>
  <g class="burger__plus">
    <rect class="burger__plus-left" x="8" y="16" width="10" height="4"/>
    <rect class="burger__plus-btm" x="16" y="18" width="4" height="10"/>
    <rect class="burger__plus-right" x="18" y="16" width="10" height="4"/>
    <rect class="burger__plus-top" x="16" y="8" width="4" height="10"/>
  </g>
  </svg>
</button>
</div>

   <div class="content_container">
      <div class="common_box">
        <div class="slide_img" id="slide_img_1"><div class="slide_img_shade"></div></div>
        <div class="title_box">
          <h2 class="main_title"><span>WORKS</span></h2>
        </div> 
      </div>
      <div class="content_box">
          <div class="content_content" >
            <div class="post_content">
                <div class="content_title">
                  <h1>Set和Map数据结构</h1><span id="busuanzi_container_page_pv">
                  <span><time datetime=""></time></span>
                </div>
                  <h3 id="代码总结">代码总结</h3>
<pre><code>let s = new Set();
[1,2,3,3,4,4].forEach((x) =&gt; s.add(x));

for(let i of s){
    console.log(i);  //1,2,3,4
}
--------------------------------------------------------------------------------------------------------------------
let s = new Set([1,2,3,4]);
//例子1
console.log(s);            //Set(4) {1, 2, 3, 4}
console.log([...s]);       //[1, 2, 3, 4]
//例子2
let items = new Set([1,3,4]);
console.log(items.size);   //3
//例子3
let  sDiv = new Set(document.querySelectorAll('div'));
console.log(sDiv.size);   //1
//类似于
let sDiv2 = new Set();
document.querySelectorAll('div').forEach(div =&gt; sDiv2.add(div));
--------------------------------------------------------------------------------------------------------------------
//去除数组中重复项
[...new Set([1,4,4,5,6])]; //[1, 4, 5, 6]

//去除字符串中重复字符
[...new Set('hello')].join(''); //"helo"
--------------------------------------------------------------------------------------------------------------------
//Array.from()方法可以将Set结构转为数组
let set = new Set([1,2,3]);
let arr = Array.from(set);
console.log(arr);  //[1, 2, 3]

//除数组重复成员的另一种方法。
function dedupe(array) {
  return Array.from(new Set(array));
}
dedupe([1, 1, 2, 3]) // [1, 2, 3]
--------------------------------------------------------------------------------------------------------------------
let set = new Set(['red','blue','yellow']);

for(let items of set.keys()){
    console.log(items);
}
//red
//blue
//yellow
for(let items of set.values()){
    console.log(items);
}
//red
//blue
//yellow
for(let items of set.entries()){
    console.log(items);
}
//["red", "red"]
//["blue", "blue"]
//["yellow", "yellow"]
--------------------------------------------------------------------------------------------------------------------
let set = new Set([1,2,3]);

set.forEach((key,value) =&gt; console.log(key + ':' + value));
//1:1
//2:2
//3:3
--------------------------------------------------------------------------------------------------------------------
let set  = new Set([1,2,3]);
let arr   = [...set];
console.log(arr); //[1, 2, 3]
--------------------------------------------------------------------------------------------------------------------
let arr = [1,2,2,3,4];
let unique = [... new Set(arr)];
console.log(unique); //[1,2,3,4]
--------------------------------------------------------------------------------------------------------------------
let m = new Map();
let obj = {
    name:'tx'
};
m.set(obj,'123');
console.log(m.get(obj)); //'123'

console.log(m.has(obj)); //true
m.delete(obj);
console.log(m.has(obj)); //false
--------------------------------------------------------------------------------------------------------------------
let m = new Map([
    ['name','tx'],
    ['age',24]
    ]);
console.log(m.size);        //2
console.log(m.has('name')); //true
console.log(m.get('name')); //tx
console.log(m.has('age'));  //true
console.log(m.get('age'));  //24
--------------------------------------------------------------------------------------------------------------------
let  map = new Map([
  ['name', 'tx'],
  ['age',  24],
]);
for(let key of map.keys()){
    console.log(key);
}
//'name'
//'age'

for(let value of map.values()){
    console.log(value);
}
//'tx'
//24

for(let item of map.entries()){
    console.log(item);
}
//["name", "tx"]
//["age", 24]

//或者
for(let [key,value] of map.entries()){
    console.log(key,value);
}
//name tx
//age 24

//等同于
for(let [key,value] of map){
    console.log(key,value);
}
//name tx
//age 24
--------------------------------------------------------------------------------------------------------------------
let m  = new Map([
    ['name','tx'],
    ['age',24]
]);
[...m.keys()];
// ["name", "age"] 
[...m.values()];
// ["tx", 24]
[...m.entries()]; 
// ["name", "tx"]
// ["age", 24]
[...m];
// ["name", "tx"]
// ["age", 24]
--------------------------------------------------------------------------------------------------------------------
let m0 = new Map().set(1,'a').set(2,'b').set(3,'c');

let m1 = new Map(
    [...m0].filter(([key,value]) =&gt; key &lt; 3)
); 
console.log(m1); //map结构 {1 =&gt; "a", 2 =&gt; "b"}
--------------------------------------------------------------------------------------------------------------------
</code></pre>
<h3 id="一set">一、set</h3>

<h4 id="基本用法">基本用法</h4>
<p>es6提供了新的数据结构Set。她类似于数组，但是成员的值都是唯一的，没有重复值。</p>

<p>Set本身是一个构造函数，用来生成Set数据结构。</p>
<pre><code>let s = new Set();
[1,2,3,3,4,4].forEach((x) =&gt; s.add(x));

for(let i of s){
    console.log(i);  //1,2,3,4
}
</code></pre>
<p>上面代码通过add方法向Set结构添加成员，结果表明Set结构不会添加重复的值。</p>

<p>Set函数可以接受一个数组（或者具有iterable接口的其他数据结构）作为参数，用来初始化。</p>
<pre><code>let s = new Set([1,2,3,4]);
//例子1
console.log(s);            //Set(4) {1, 2, 3, 4}
console.log([...s]);       //[1, 2, 3, 4]
//例子2
let items = new Set([1,3,4]);
console.log(items.size);   //3
//例子3
let  sDiv = new Set(document.querySelectorAll('div'));
console.log(sDiv.size);   //1
//类似于
let sDiv2 = new Set();
document.querySelectorAll('div').forEach(div =&gt; sDiv2.add(div));
</code></pre>
<p>上面代码中，例子1和例子2都是接收数组作为参数，例子3是接收类似数组的对象作为参数。</p>

<p>上面代码展示了去除数组中重复成员的方法。</p>
<pre><code>//去除数组中重复项
[...new Set([1,4,4,5,6])]; //[1, 4, 5, 6]
</code></pre>
<p>上面的方法也可用于，去除字符串里面的重复字符。</p>
<pre><code>//去除字符串中重复字符
[...new Set('hello')].join(''); //"helo"
</code></pre>
<p>向Set加入值的时候，不会发生类型转换，所以加入5和”5”是两个不同的值，Set内部判断两个值是否相等，使用的算法叫做“Same-value-zero equality”，它类似于全等运算符(===),只要的区别是NaN等于自身，而全等运算符比较NaN不等于自身。</p>
<pre><code>let set = new Set();
let a = NaN;
let b = NaN;
set.add(a);
set.add(b);
console.log(set); //Set(1) {NaN}
</code></pre>
<p>上面代码向Set实例添加了两个NaN,但是只能加入一个，这表明，在Set内部，两个NaN是相等的。</p>

<p>另外，两个对象总是不相等的。</p>
<pre><code>let set = new Set();
set.add({});
set.add({});
set.size;  //2
</code></pre>
<p>上面代码表示：由于两个空对象不相等，所以set中被加进了两项。</p>

<h4 id="set实例的属性和方法">Set实例的属性和方法</h4>
<p>Set结构的实例有以下属性。</p>

<p>–Set.prototype.constructor:构造函数，默认就是Set函数。
–Set.prototype.size:返回Set实例的成员数量。</p>

<p>Set实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。</p>

<p>–add(value)：添加某个值，返回Set结构本身。
–delete(value)：删除某个值，返回一个布尔值，表示是否删除成功。
–has(value)：返回一个布尔值，表示该值是否为Set的成员。
–clear()：清除所有成员，没有返回值。</p>

<p>上面这些方法的例子如下:</p>
<pre><code>let set = new Set();
set.add(1).add(2).add(2);

set.size;       //2
set.has(2);     //true
set.delete(2);  //true
set.has(2);     //false
</code></pre>
<p>下面是一个对比，比较在判断是否包含某一个键上面，Object结构和Set结构有什么不同。</p>
<pre><code>//Object
let obj = {
    name : 'tianxin',
    age :24
};

if(obj['name']){
    console.log('obj对象中包含name键'); 
}
//Set
let set = new Set();
set.add('name');
set.add('age');

if(set.has('name')){
    console.log('set结构中包含name键');
}
</code></pre>
<p>Array.from()方法可以将Set结构转为数组。</p>
<pre><code>let set = new Set([1,2,3]);
let arr = Array.from(set);
console.log(arr);  //[1, 2, 3]
</code></pre>
<p>这就提供了去除数组重复成员的另一种方法。</p>
<pre><code>function dedupe(array) {
  return Array.from(new Set(array));
}
dedupe([1, 1, 2, 3]) // [1, 2, 3]
</code></pre>
<h4 id="遍历操作">遍历操作</h4>

<p>Set结构的实例有四个遍历方法，可以用于遍历成员。</p>

<p>–key()：返回键名的遍历器。
–values：返回键值的遍历器。
–entries：返回键值对的遍历器。
–forEach：使用回调函数遍历每个成员。</p>

<p>需要特别说明的是：Set的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用Set保存一个回调函数的列表，调用时就能保证按照添加顺序调用。</p>

<h5 id="1keysvaluesentries">（1）keys()，values()，entries()</h5>
<p>keys()，values()，entries()这三个方法返回的都是遍历器对象。由于Set结构没有键名，只有键值(或者说键名和键值是同一个值)，所以keys()方法和values()方法的行为完全一致。</p>
<pre><code>let set = new Set(['red','blue','yellow']);

for(let items of set.keys()){
    console.log(items);
}
//red
//blue
//yellow
for(let items of set.values()){
    console.log(items);
}
//red
//blue
//yellow
for(let items of set.entries()){
    console.log(items);
}
//["red", "red"]
//["blue", "blue"]
//["yellow", "yellow"]
</code></pre>

<p>Set结构的实例默认可遍历，他的默认遍历器生成函数就是他的values方法。</p>
<pre><code>Set.prototype[Symbol.iterator] === Set.prototype.values
// true
</code></pre>
<p>这意味着，可以省略values方法，直接用for…of循环Set。</p>
<pre><code>let set = new Set(['red','blue','yellow']);

for(let items of set){
    console.log(items);
}
</code></pre>
<h5 id="2-foreach">(2) forEach()</h5>
<p>Set结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。</p>
<pre><code>let set = new Set([1,2,3]);

set.forEach((key,value) =&gt; console.log(key + ':' + value));
//1:1
//2:2
//3:3
</code></pre>
<p>上面代码说明，forEach方法的参数就是一个处理函数。该数组的参数与数组的forEach一致，依次为键值、键名、集合本身（上面没写）。这里需要注意的是：Set结构的键值跟键名相等，因此第一个参数和第二个参数永远是一样的。</p>

<p>另外，forEach方法还可以有第二个参数，表示绑定处理函数内部的this对象。</p>

<h5 id="3遍历的应用">（3）遍历的应用</h5>
<p>扩展运算符（…）内部使用for…of循环，所以也可以用于Set结构。</p>
<pre><code>let set  = new Set([1,2,3]);
let arr   = [...set];
console.log(arr); //[1, 2, 3]
</code></pre>
<p>扩展运算符和Set结构相结合，就可以去除数组的重复成员。</p>
<pre><code>let arr = [1,2,2,3,4];
let unique = [... new Set(arr)];
console.log(unique); //[1,2,3,4]
</code></pre>
<p>数组的map和filter方法也可以间接用于Set了。</p>
<pre><code>let set = new Set([1,2,3]);
set = new Set([...set].map(x =&gt; x*2));
console.log(set); //Set(3) {2, 4, 6}

let set = new Set([1,2,3]);
set = new Set([...set].filter(x=&gt; (x % 2) ==0 ));
console.log(set); //Set(1) {2}
</code></pre>
<p>因此使用Set可以很容易实现并集，交集和差集。</p>
<pre><code>let a = new Set([1,2,3]);
let b = new Set([2,3,4]);

//并集 
let union = new Set([...a,...b]);
console.log(union);     //Set(4) {1, 2, 3, 4}

//交集
let intersect = new Set([...a].filter(x =&gt; b.has(x)));
console.log(intersect); //{2, 3}


//差集
let difference = new Set([...a].filter(x =&gt; !b.has(x)));
console.log(difference); //Set(1) {1}
</code></pre>
<p>如果想在遍历操作中，同步改变原来的Set结构，目前没有直接的方法，但有两种变通方法。一种是利用原来的Set结构映射出一个新结构，然后赋值给原来的dSet结构，另一个方法是利用Array.from方法。</p>
<pre><code>let set = new Set([1,2,3]);
set = new Set([...set].map(val =&gt; val * 2));
console.log(set); //Set(3) {2, 4, 6}

let set = new Set([1,2,3]);
set = new Set(Array.from(set,val =&gt; val *2));
console.log(set); //Set(3) {2, 4, 6}
</code></pre>
<p>上面这两种方法可以在遍历的过程中改变原来的Set结构。</p>

<h3 id="二map">二、Map</h3>
<h4 id="含义和基本用法">含义和基本用法</h4>
<p>js的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键值。这给他的使用带来了很大的限制。</p>
<pre><code>let obj = {};
let Div = document.getElementById('test');
obj[Div] = 'hello';
console.log(obj);                             //{[object HTMLDivElement]: "hello"}
console.log(obj['[object HTMLDivElement]']);  //hello
</code></pre>
<p>上面代码是将dom节点作为对象的键，但是由于对象只接受字符串作为键名，所以Div被自动转为字符串[object HTMLDivElement]。</p>

<p>为了解决这个问题，es6提供了Map数据结构。他跟对象类似，不同的地方是”键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，object结构提供了”字符串–值”的对应，Map结构提供了”值–值”的对应，是一种更完善的Hash结构实现。如果你需要”键值对”的数据结构，Map比Object更合适。</p>
<pre><code>let m = new Map();
let obj = {
    name:'tx'
};
m.set(obj,'123');
console.log(m.get(obj)); //'123'

console.log(m.has(obj)); //true
m.delete(obj);
console.log(m.has(obj)); //false
</code></pre>
<p>上面代码使用Map结构的set方法，将对象obj当作m的一个键，使用get()可以读取这个键对应的值，使用delete()方法删除这个键。</p>

<p>上面的例子展示了如果向Map结构添加成员，作为构造函数，map也可以接受一个数组作为参数，该数组的成员是一个个表示键值对的数组。</p>
<pre><code>let m = new Map([
    ['name','tx'],
    ['age',24]
    ]);
console.log(m.size);        //2
console.log(m.has('name')); //true
console.log(m.get('name')); //tx
console.log(m.has('age'));  //true
console.log(m.get('age'));  //24
</code></pre>
<p>上面代码在新建Map实例时，就指定了两个键name和title。</p>

<p>Map构造函数接受数组作为参数，实际上执行的是下面的方法。</p>
<pre><code>let arr = [
    ['name','tx'],
    ['age',24]
];
let m = new Map();
arr.forEach(
    ([key:value]) =&gt; map.set(key,value);
)
</code></pre>
<p>不仅仅是数组，任何具有Iterator接口，且每个成员都是一个双元素的数组的数据结构都可以当作Map构造函数的参数。这就是说，Set和Map都可以用来生成新的Map。</p>
<pre><code>let set = new Set([
    ['name','tx'],
    ['age',24]
])

let m1 = new Map(set);
m1.get('name');             //'tx'

let m2 = new Map([
    ['foo','3']
]);
let m3 = new Map(m2);
console.log(m3.get('foo')); //3
</code></pre>
<p>上面代码中，我们分别使用Set对象和Map对象，作为Map构造函数的参数，结果都生成了新的Map对象。</p>

<p>如果对同一个键多次赋值，后面的值将覆盖前面的值。</p>
<pre><code>let m  = new Map();
m.set(1,'aaa');
m.set(1,'bbb');

console.log(m.get(1)); //'bbb'
</code></pre>
<p>如果读取一个未知的键，则返回undefined。</p>
<pre><code>new Map().get('name'); //undefined
</code></pre>
<p>注意：只有对同一个对象的引用，Map结构才将其视为同一个键。这一点要非常小心。</p>
<pre><code>let m = new Map();
m.set(['a'],123);
m.get(['a']);  //undefined
</code></pre>
<p>上面代码的set和get方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此get方法无法读取该键，返回undefined。</p>

<p>同理，同样的值的两个实例，在Map结构中被视为两个键。</p>
<pre><code>let m = new Map();

let k1 = ['a'];
let k2 = ['b'];
m.set(k1,111);
m.set(k2,222);

console.log(m.get(k1)); //111
console.log(m.get(k2)); //222
</code></pre>
<p>上面代码中，变量k1和变量k2的值是一样的，但是他们在Map结构中被视为两个键。</p>

<p>由上可知，Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性冲突的问题，我们扩展别人库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p>

<p>如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。</p>
<pre><code>let map = new Map();

map.set(-0, 123);
map.get(+0) // 123

map.set(true, 1);
map.set('true', 2);
map.get(true) // 1

map.set(undefined, 3);
map.set(null, 4);
map.get(undefined) // 3

map.set(NaN, 123);
map.get(NaN) // 123
</code></pre>
<h4 id="实例的属性和操作方法">实例的属性和操作方法</h4>
<p>Map结构的实例有以下属性和操作方法。</p>
<h5 id="1size属性">（1）size属性</h5>
<p>size属性返回Map结构的成员总数。</p>
<pre><code>let m = new Map();
m.set('name','tx');
m.set('age',24);
console.log(m.size); //2
</code></pre>
<h5 id="2setkeyvalue">（2）set(key,value)</h5>
<p>set()方法设置键名key对应的键值为value，然后返回整个Map结构。如果key已经有值，则键值会被更新，否则就新生成该键。</p>
<pre><code>let m = new Map();
m.set('name','tx');      //键是字符串
m.set(123,123);          //键是数值
m.set(undefined,'123');  //键是undefined
</code></pre>
<p>set方法返回的是当前的Map对象，因此可以采用链式写法。</p>
<pre><code>let m = new Map();
m.set(1,'a').set(2,'b').set(3,'c');
</code></pre>
<h5 id="3getkey">（3）get(key)</h5>
<p>get方法读取Map结构key对象的键值，如果对应的key，则返回undefined。</p>
<pre><code>m.set('name','tx');
m.get('123');  //undefined
</code></pre>
<h5 id="4haskey">（4）has(key)</h5>
<p>has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</p>
<pre><code>let m = new Map();
m.set('name','tx');
console.log(m.has('name'));  //true
</code></pre>
<h5 id="5deletekey">(5）delete(key)</h5>
<p>delete()方法删除某个键，返回true。如果删除失败，返回false。</p>
<pre><code>let m = new Map();
m.set('name','tx');
console.log(m.delete('name')); //true
</code></pre>
<h5 id="6clear">(6）clear()</h5>
<p>clear方法清除所有成员，没有返回值。</p>
<pre><code>let m = new Map();
m.set('name','tx');
m.set('age',24);
m.clear();
console.log(m.size); //0
</code></pre>
<h4 id="遍历方法">遍历方法</h4>
<p>Map结构原生提供三个遍历器生成函数和一个遍历方法。</p>

<p>–keys()：返回键名的遍历器。</p>

<p>–values()：返回键值的遍历器。</p>

<p>–entries()：返回所有成员的遍历器。</p>

<p>–forEach()：遍历 Map 的所有成员。</p>

<p>需要特别注意的是：Map的遍历顺序就是插入顺序。</p>
<pre><code>let  map = new Map([
  ['name', 'tx'],
  ['age',  24],
]);
for(let key of map.keys()){
    console.log(key);
}
//'name'
//'age'

for(let value of map.values()){
    console.log(value);
}
//'tx'
//24

for(let item of map.entries()){
    console.log(item);
}
//["name", "tx"]
//["age", 24]

//或者
for(let [key,value] of map.entries()){
    console.log(key,value);
}
//name tx
//age 24

//等同于
for(let [key,value] of map){
    console.log(key,value);
}
//name tx
//age 24
</code></pre>
<p>上面代码的最后一个例子，表示Map结构的默认遍历器接口，就是entries方法。</p>

<p>Map结构转为数组结构，比较快速的方法是使用扩展运算符（…）。</p>
<pre><code>let m  = new Map([
    ['name','tx'],
    ['age',24]
]);
[...m.keys()];
// ["name", "age"] 
[...m.values()];
// ["tx", 24]
[...m.entries()]; 
// ["name", "tx"]
// ["age", 24]
[...m];
// ["name", "tx"]
// ["age", 24]
</code></pre>
<p>结合数组的map方法、filter方法，可以实现Map的遍历和过滤（Map本身没有map和filter方法）。</p>
<pre><code>let m0 = new Map().set(1,'a').set(2,'b').set(3,'c');

let m1 = new Map(
    [...m0].filter(([key,value]) =&gt; key &lt; 3)
); 
console.log(m1); //map结构 {1 =&gt; "a", 2 =&gt; "b"}
</code></pre>
<h4 id="与其他数据结构的互相转换">与其他数据结构的互相转换</h4>

<h5 id="1map转为数组">（1）Map转为数组</h5>
<p>上面已经说过，Map转为数组最方便的方法，就是使用扩展运算符（…）。</p>
<pre><code>let m = new Map();
m.set(true,'123').set({'name':'tx'},'tx');
[...m];
//[ [true, "123"] , [ {[true, "123"]},"tx"] ]
</code></pre>
<h5 id="2数组转为map">（2）数组转为Map</h5>
<p>将数组传入Map构造函数，就可以转为Map。</p>
<pre><code>let m = new Map([
    ['name','tx'],
    ['age',24]
]);
console.log(m);
//map结构 {"name" =&gt; "tx", "age" =&gt; 24}
</code></pre>
<h5 id="3map转为对象">（3）Map转为对象</h5>
<p>如果Map所有的键都是字符串，就可以无损的转为对象。</p>
<pre><code>function strMapToObj(strMap) {
  let obj = Object.create(null);
  for (let [k,v] of strMap) {
    obj[k] = v;
  }
  return obj;
}

const myMap = new Map()
  .set('yes', true)
  .set('no', false);
strMapToObj(myMap)
// { yes: true, no: false }
</code></pre>
<p>如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。</p>

<h5 id="4对象转为map">（4）对象转为Map</h5>
<pre><code>function objToStrMap(obj) {
  let strMap = new Map();
  for (let k of Object.keys(obj)) {
    strMap.set(k, obj[k]);
  }
  return strMap;
}

objToStrMap({yes: true, no: false})
// Map {"yes" =&gt; true, "no" =&gt; false}
</code></pre>
<h5 id="5map转为json">（5）Map转为JSON</h5>
<p>Map的键名都是字符串：</p>
<pre><code>function strMapToJson(strMap) {
  return JSON.stringify(strMapToObj(strMap));
}

let myMap = new Map().set('yes', true).set('no', false);
strMapToJson(myMap)
// '{"yes":true,"no":false}'
</code></pre>
<p>Map 的键名有非字符串:</p>
<pre><code>function mapToArrayJson(map) {
  return JSON.stringify([...map]);
}

let myMap = new Map().set(true, 7).set({foo: 3}, ['abc']);
mapToArrayJson(myMap)
// '[[true,7],[{"foo":3},["abc"]]]'
</code></pre>
<h5 id="6json转为map">（6）JSON转为Map</h5>
<pre><code>function jsonToStrMap(jsonStr) {
  return objToStrMap(JSON.parse(jsonStr));
}

jsonToStrMap('{"yes": true, "no": false}')
// Map {'yes' =&gt; true, 'no' =&gt; false}
</code></pre>
<p>有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。</p>
<pre><code>function jsonToMap(jsonStr) {
  return new Map(JSON.parse(jsonStr));
}

jsonToMap('[[true,7],[{"foo":3},["abc"]]]')
// Map {true =&gt; 7, Object {foo: 3} =&gt; ['abc']}
</code></pre>

<p>备注：WeakSet和WeakMap没写。</p>


   
            </div>
            
          </div>
          
                <div class="next_page_box">
                  <div class="read_next">阅读下一篇文章</div>
                  <div class="next_page">
                    <a class="" href="http://localhost:4000/tec/2019/01/26/Symbol.html" data-post-href="http://localhost:4000/tec/2019/01/26/Symbol.html">
                      <h4>Symbol</h4>
                      <div></div>
                    </a>
                  </div>
                </div>
          
          <div class="phone_bottom">
              <a class="" href="http://localhost:4000/tec/2019/06/27/Iterator-%E5%92%8C-for...of-%E5%BE%AA%E7%8E%AF.html" data-post-href="http://localhost:4000/tec/2019/06/27/Iterator-%E5%92%8C-for...of-%E5%BE%AA%E7%8E%AF.html">
              PREV
              </a>
              <a class="" href="http://localhost:4000/tec/2019/01/26/Symbol.html" data-post-href="http://localhost:4000/tec/2019/01/26/Symbol.html">
                NEXT
              </a>
          </div>
       </div>
    </div>
  </body>
<script src="/source/js/highlight.min.js"></script>
<script type="text/javascript" src="/source/js/jquery.js"></script>
<script type="text/javascript" src="/source/js/TweenMax.min.js"></script>
<script type="text/javascript" src="/source/js/DrawSVGPlugin.min.js"></script>
<script type="text/javascript" src="/source/js/tween.js"></script>
<script type="text/javascript" src="/source/js/animation.js"></script>
  <script type="text/javascript" src="/source/js/index.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
    $(document).ready(function(){
      //评论
        $('.comments').on('click',function(e){
          e.preventDefault();
          $('#lv-container').show();
        });
    })
  </script>
</html>