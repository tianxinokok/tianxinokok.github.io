<!DOCTYPE HTML>
<html>
<head>
  <meta charset="UTF-8">
    <link rel="stylesheet" href="/source/css/index.css" type="text/css">
    <link rel="stylesheet" href="/source/css/post_last.css" type="text/css">
    <link rel="stylesheet" href="/source/css/obsidian.min.css">
    <link rel="stylesheet" type="text/css" href="/source/css/font-awesome-4.7.0/css/font-awesome.min.css">
    <link rel="icon" href="/source/img/Favicon.png" sizes="32x32" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>摆渡先生</title>
</head>

 <body>
 <div class="nav_box" style="z-index: 10000">
<nav class="nav">
	<ul class="nav__list">
		<li class="nav__item">
			<a class="nav__link" href="/">
				<div class="nav__link-content">
					<span class="nav__link-num">01</span>
					<div class="nav__link-title">Works</div>
					<div class="nav__link-desc">What I'm made</div>
				</div>
				<div class="nav__link-base"></div>
			</a>
			<div class="nav__item-line"></div>
		</li>
		<li class="nav__item">
			<a class="nav__link" href="/new">
				<div class="nav__link-content">
					<span class="nav__link-num">02</span>
					<div class="nav__link-title">News</div>
					<div class="nav__link-desc">Latest ramblings</div>
				</div>
				<div class="nav__link-base"></div>
			</a>
			<div class="nav__item-line"></div>
		</li>
		<li class="nav__item">
			<a class="nav__link" href="/book">
				<div class="nav__link-content">
					<span class="nav__link-num">03</span>
					<div class="nav__link-title">Books</div>
					<div class="nav__link-desc">Many good books</div>
				</div>
				<div class="nav__link-base"></div>
			</a>
			<div class="nav__item-line"></div>
		</li>
		<li class="nav__item">
			<a class="nav__link" href="/contact">
				<div class="nav__link-content">
					<span class="nav__link-num">04</span>
					<div class="nav__link-title">Contact</div>
					<div class="nav__link-desc">Don't be shy</div>
				</div>
				<div class="nav__link-base"></div>
			</a>
			<div class="nav__item-line"></div>
		</li>
        <li class="phone_btn_close nav__item">
            x
        </li>
	</ul>
  <div class="header_logo">
    <svg version="1.1"  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
   viewBox="0 0 825 299" style="enable-background:new 0 0 825 299;" xml:space="preserve">
<g class="logo_baidu">
  <path class="st0 logo_baidu_letter" fill="#fff" d="M132.94,183.58c-5.84,0.73-10.94,1.46-15.31,2.19c-2.19,0.73-4.02,0-5.47-2.19c0-5.1,1.82-8.02,5.47-8.75
    c3.64,0.73,8.75,1.09,15.31,1.09c0-5.1-0.37-10.2-1.09-15.31c0-2.91,1.09-4.38,3.28-4.38c7.29,0.73,10.57,3.65,9.84,8.75
    c-0.73,2.92-1.09,6.56-1.09,10.94h8.75c2.91,0.73,4.38,2.19,4.38,4.38c-2.19,1.46-6.56,2.19-13.13,2.19v9.84
    c7.29-1.45,11.3-1.45,12.03,0c0.73,2.19-3.28,4.74-12.03,7.66c0,11.67,0.36,21.52,1.09,29.53c0.73,5.84-1.46,10.21-6.56,13.13
    c-4.38,2.19-10.94,1.83-19.69-1.09c-7.3-3.64-11.3-7.29-12.03-10.94c17.5,4.38,26.25,3.65,26.25-2.19c0.73-9.48,0.73-17.86,0-25.16
    c-8.75,2.92-14.95,4.74-18.59,5.47c-2.92,0-4.74-1.45-5.47-4.38c-0.73-3.64,0.73-5.83,4.38-6.56c5.1-0.73,11.66-1.82,19.69-3.28
    V183.58z M217.16,162.8c3.64,0.73,5.47,3.28,5.47,7.66c-1.46,5.84-2.19,11.67-2.19,17.5c-0.73,3.65-2.92,5.11-6.56,4.38
    c-6.56-1.45-12.77-2.19-18.59-2.19c-0.73,2.19-0.73,4.38,0,6.56h14.22c3.64,0,5.83,0.73,6.56,2.19c0.73,2.92-1.09,4.38-5.47,4.38
    h-15.31c-0.73,2.19-0.73,4.38,0,6.56c15.31,0.73,28.8,0.73,40.47,0c-5.11,10.94-12.4,14.22-21.88,9.84
    c-6.56-2.19-13.13-3.28-19.69-3.28l-5.47,6.56c-2.92,2.92-5.11,5.47-6.56,7.66c3.64,2.92,7.66,4.02,12.03,3.28
    c5.1-1.45,8.38-3.28,9.84-5.47c-1.46-0.73-3.28-1.82-5.47-3.28c0.73-3.64,2.55-5.47,5.47-5.47c2.91-0.73,6.2,0.73,9.84,4.38
    c5.1,4.38,8.75,8.39,10.94,12.03c2.19,4.38,0.73,5.84-4.38,4.38c-3.65-2.91-7.66-5.83-12.03-8.75c-5.11,7.3-11.3,10.58-18.59,9.84
    c-8.02-3.64-13.13-5.1-15.31-4.38c-2.92,0.73-5.84,1.83-8.75,3.28c-2.92,0.73-5.11-0.36-6.56-3.28c-0.73-2.19,0-4.01,2.19-5.47
    c2.91-2.19,5.83-4.01,8.75-5.47c6.56-3.64,10.57-6.92,12.03-9.84c-14.59,0.73-24.06,1.83-28.44,3.28
    c-3.65,0.73-5.11-0.73-4.38-4.38c1.45-3.64,3.28-5.83,5.47-6.56c6.56,1.46,15.67,1.83,27.34,1.09c0.73-2.19,0.73-4.38,0-6.56
    c-7.3,0-13.49,0.37-18.59,1.09c-3.65,0.73-4.74-1.09-3.28-5.47c1.45-1.45,3.64-2.55,6.56-3.28c5.1,0.73,10.2,1.09,15.31,1.09
    c0.73-2.19,0.73-4.38,0-6.56c-6.56,0-11.67,0.73-15.31,2.19c-3.65,1.46-5.84,0.37-6.56-3.28c-0.73-8.75-1.46-15.67-2.19-20.78
    c0-4.38,2.55-6.2,7.66-5.47C181.8,164.99,198.93,164.99,217.16,162.8z M167.94,170.46c-0.73,2.92-0.73,7.3,0,13.13
    c3.64,1.46,6.56,1.46,8.75,0c0.73-4.38,0.73-8.75,0-13.13C174.51,169.73,171.58,169.73,167.94,170.46z M184.35,183.58
    c3.64,0.73,6.56,0.73,8.75,0c0.73-5.1,0.73-9.48,0-13.13c-2.92-0.73-5.84-0.73-8.75,0C183.62,175.57,183.62,179.94,184.35,183.58z
     M200.76,170.46c-0.73,3.65-0.73,8.02,0,13.13c4.38,1.46,7.66,1.46,9.84,0c2.19-3.64,2.55-8.02,1.09-13.13
    C208.05,169.73,204.4,169.73,200.76,170.46z"/>
  <path class="st0 logo_baidu_letter" fill="#fff" d="M255.44,189.05c8.75,2.92,17.5,5.11,26.25,6.56c1.45,0.73,1.45,1.83,0,3.28c-5.84,2.19-11.3,3.28-16.41,3.28
    c-7.3,0.73-13.13,0-17.5-2.19c-2.92-2.19-2.92-5.1,0-8.75C249.98,189.05,252.52,188.33,255.44,189.05z M255.44,216.4
    c8.75-1.45,17.5-4.01,26.25-7.66c1.45-0.73,2.55-0.73,3.28,0c-2.19,4.38-5.11,8.02-8.75,10.94c-4.38,3.65-10.94,6.93-19.69,9.84
    c-2.92,0-5.11-1.82-6.56-5.47C249.24,219.68,251.07,217.13,255.44,216.4z M262.01,166.08c7.29,5.11,14.95,9.48,22.97,13.13
    c-0.73,1.46-4.38,2.19-10.94,2.19s-12.77-1.45-18.59-4.38c-2.19-1.45-2.92-3.28-2.19-5.47
    C254.71,167.18,257.63,165.36,262.01,166.08z M313.41,186.87c-4.38-0.73-8.39-0.36-12.03,1.09c0,5.84-0.73,13.13-2.19,21.88
    c-0.73,4.38-2.19,8.39-4.38,12.03c-2.19,3.65-4.38,6.56-6.56,8.75c-5.11,4.38-9.48,6.93-13.13,7.66c-2.92,0-5.47-0.36-7.66-1.09
    c-1.46-1.45-2.55-2.55-3.28-3.28c2.91-2.19,6.2-4.01,9.84-5.47c3.64-2.19,6.92-5.1,9.84-8.75c2.19-3.64,4.01-7.29,5.47-10.94
    c1.45-5.83,2.19-11.3,2.19-16.41c0.73-8.75-0.37-16.04-3.28-21.88c0-4.38,2.19-6.56,6.56-6.56c4.38,1.46,12.39,2.19,24.06,2.19
    v-6.56c1.45-2.91,4.38-4.01,8.75-3.28c2.19,0.73,4.01,1.83,5.47,3.28v6.56h20.78c6.56,0,9.84,1.46,9.84,4.38
    c-1.46,1.46-7.66,2.19-18.59,2.19c-1.46,2.92-1.46,5.47,0,7.66h8.75c5.83,0,8.75,1.09,8.75,3.28s-1.09,3.28-3.28,3.28h-14.22
    c-0.73,3.65-0.73,6.93,0,9.84c0.73,3.65-1.09,5.11-5.47,4.38c-2.92-1.45-5.84-2.55-8.75-3.28c-2.19,0-4.38,0-6.56,0
    c-2.19,0.73-4.02,1.46-5.47,2.19c-3.65,0.73-5.47-0.36-5.47-3.28C314.14,192.33,314.14,189.05,313.41,186.87z M314.51,202.18
    c2.19,0.73,4.38,1.09,6.56,1.09c7.29-0.73,14.95-0.36,22.97,1.09c5.1,1.46,6.92,4.02,5.47,7.66c-2.19,2.92-5.11,6.93-8.75,12.03
    c16.04,5.11,28.07,7.66,36.09,7.66c-7.3,10.94-14.59,14.58-21.88,10.94c-6.56-4.38-13.49-8.75-20.78-13.13
    c-9.48,5.11-17.87,8.75-25.16,10.94c-6.56,1.46-10.58-0.73-12.03-6.56c0.73-0.73,4.73-1.82,12.03-3.28
    c8.02-1.45,14.22-3.64,18.59-6.56c-4.38-2.91-8.39-5.47-12.03-7.66c0-3.64,1.82-5.1,5.47-4.38c3.64,2.19,7.66,4.74,12.03,7.66
    c2.91-2.19,4.73-4.73,5.47-7.66c0.73-2.19-0.73-3.28-4.38-3.28c-6.56,0-12.77,0.37-18.59,1.09c-3.65,2.19-5.84,2.19-6.56,0
    C309.76,205.46,311.58,202.91,314.51,202.18z M313.41,172.65c-3.65-0.73-8.02-0.73-13.13,0c-0.73,2.92-0.73,5.47,0,7.66
    c4.38,0.73,8.75,0.73,13.13,0C314.14,177.39,314.14,174.83,313.41,172.65z M322.16,172.65c-0.73,2.92-0.73,5.47,0,7.66
    c5.1,0.73,9.48,0.73,13.13,0c0.73-2.91,0.73-5.47,0-7.66C330.91,171.92,326.54,171.92,322.16,172.65z M336.38,186.87
    c-4.38-0.73-9.12-0.73-14.22,0c0,1.46,0,3.28,0,5.47c4.38,0.73,8.38,0.73,12.03,0C336.38,192.33,337.11,190.51,336.38,186.87z"/>
</g>
<polyline class="st1 logo_baidu_border" points="409.5,179.35 409.5,261 81.5,261 81.5,140 367.18,140 " fill="none" stroke="#fff" stroke-miterlimit="10" stroke-width="16"/>
<g class="logo__plus" fill="none" stroke="#fff" stroke-miterlimit="10" stroke-width="16">
  <line class="st1 logo__plus-horz" x1="382.5" y1="140.5" x2="436.5" y2="140.5"/>
  <!-- <path class="st1" d="M411.5,117.5"/> -->
  <line class="st1 logo__plus-vert" x1="409.5" y1="167.5" x2="409.5" y2="113.5"/>
</g>
<g class="logo__xiansheng">
  <path class="st2 logo_xiansheng_letter" fill="#fff" d="M484.78,60.65c-5.11,3.65-9.12,5.47-12.03,5.47c-4.38,0-5.47-1.09-3.28-3.28c5.1-2.91,8.75-8.02,10.94-15.31
    c1.45-6.56,3.64-9.48,6.56-8.75c2.91,0,4.73,1.46,5.47,4.38c0,3.65-1.09,6.56-3.28,8.75h16.41V39.87c0-4.38,1.82-6.92,5.47-7.66
    c6.56,0,9.84,2.92,9.84,8.75V51.9h25.16c4.38,0,6.2,1.83,5.47,5.47c-0.73,2.19-2.19,3.28-4.38,3.28h-26.25v8.75
    c10.94,0,22.6,0.37,35,1.09c2.91,0,4.73,1.09,5.47,3.28c0.73,4.38-1.83,6.56-7.66,6.56c-10.21-0.73-19.69-1.09-28.44-1.09v10.94
    c0,8.02,6.56,12.03,19.69,12.03c14.58,0.73,26.25-1.45,35-6.56c-2.92,10.94-6.2,17.5-9.84,19.69c-7.3,5.11-17.87,5.84-31.72,2.19
    c-5.11-1.45-9.48-3.28-13.13-5.47c-7.3-4.38-11.3-10.57-12.03-18.59V79.24h-6.56c-0.73,4.38-2.55,9.48-5.47,15.31
    c-6.56,9.48-14.22,16.05-22.97,19.69c-7.3,2.92-14.59,3.65-21.88,2.19c-6.56-2.91-8.75-5.83-6.56-8.75
    c24.79-0.73,40.1-10.2,45.94-28.44c-5.84-0.73-13.49,0-22.97,2.19c-7.3,2.19-10.58,0.73-9.84-4.38c3.64-5.83,6.92-8.38,9.84-7.66
    c8.02,1.46,18.95,1.46,32.81,0v-8.75H484.78z"/>

  <path class="st3 logo_xiansheng_letter" fill="#fff" d="M645.29,63.43c-6.56-0.73-14.22-0.73-22.97,0c-2.92,3.65-7.3,6.93-13.13,9.84c-2.92,0.73-4.02,0-3.28-2.19
    c5.83-6.56,9.84-13.48,12.03-20.78c2.19-8.75,6.2-12.03,12.03-9.84c4.38,2.92,3.64,8.02-2.19,15.31h17.5
    c0.73-6.56,0.73-12.39,0-17.5c0-4.38,2.19-6.92,6.56-7.66c5.83,0,8.75,2.55,8.75,7.66c0,8.75,0.36,14.59,1.09,17.5h22.97
    c8.02-0.73,12.03,0.73,12.03,4.38c2.19,3.65-9.48,4.74-35,3.28c-1.46,3.65-1.46,7.3,0,10.94l21.88,1.09c2.91,0,6.2,0.73,9.84,2.19
    c1.45,2.92,1.09,4.74-1.09,5.47c-8.75-0.73-18.23-0.73-28.44,0c-2.19,0-3.28,3.65-3.28,10.94c0.73,6.56,16.04,8.02,45.94,4.38
    c3.64,0,8.02-0.73,13.13-2.19c-3.65,16.77-12.03,22.97-25.16,18.59c-22.61-8.02-48.13-10.2-76.56-6.56
    c-10.94,2.19-17.87,3.65-20.78,4.38c-5.84,1.46-8.02-0.36-6.56-5.47c2.91-5.83,6.92-9.48,12.03-10.94
    c2.91-0.73,7.29-0.36,13.13,1.09c18.95,2.19,28.8,1.46,29.53-2.19c1.45-8.02,0-12.03-4.38-12.03c-7.3-0.73-14.22,0-20.78,2.19
    c-4.38,1.46-5.84-0.36-4.38-5.47c0.73-2.19,2.91-4.38,6.56-6.56c2.91-1.45,5.83-1.09,8.75,1.09c5.83,0.73,10.2,0.73,13.13,0
    C646.38,72.91,646.74,69.27,645.29,63.43z"/>
</g>
<polyline class="st1 logo_xiansheng_border" points="409.5,101.65 409.5,20 737.5,20 737.5,141 451.82,141 " fill="none" stroke="#fff" stroke-miterlimit="10" stroke-width="16"/>
</svg>
  </div>
</nav>
<svg class="nav__bg" width="100%" height="100%" viewBox="0 0 100 100" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg">
    <defs>
        <linearGradient class="nav__grad" x1="92.6356902%" y1="7.36430977%" x2="0%" y2="100%" id="nav-grad">
            <!-- <stop stop-color="#000000" offset="20%"></stop>
            <stop stop-color="#223e36" offset="100%"></stop> -->
            <!-- <stop stop-color="#43C6AC" offset="20%"></stop>
            <stop stop-color="#191654" offset="100%"></stop> -->
            <stop stop-color="#00dbde" offset="20%"></stop>
            <stop stop-color="#fc00ff" offset="100%"></stop>
        </linearGradient>
		<mask id="nav__bg-mask" class="nav__bg-mask" maskUnits="userSpaceOnUse"x="0" y="0" width="100" height="100">
		  	<rect class="nav__bg-mask-rect" x="0" y="0" width="25" height="100" fill="white"/>
			<rect class="nav__bg-mask-rect" x="24.9" y="0" width="25.1" height="100" fill="white"/>
			<rect class="nav__bg-mask-rect" x="49.9" y="0" width="25.1" height="100" fill="white"/>
			<rect class="nav__bg-mask-rect" x="74.9" y="0" width="25.1" height="100" fill="white"/>
		</mask>
    </defs>
    <rect x="0" y="0" width="100" height="100" fill="url(#nav-grad)" mask="url(#nav__bg-mask)"></rect>
</svg>
 <!--pc_menu_btn--> 
<button class="nav-btn">
  <svg class="burger <?php echo $darkBurgerClass; ?>" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 36 36">
  <rect class="burger__stroke"  x="2" y="2" width="32" height="32" fill="none" stroke="" stroke-miterlimit="10" stroke-width="4"/>
  <polyline class="burger__stroke-over"points="18 2 34 2 34 34 2 34 2 2 18 2" fill="none" stroke="" stroke-miterlimit="10" stroke-width="4"/>
  <g class="burger__plus">
    <rect class="burger__plus-left" x="8" y="16" width="10" height="4"/>
    <rect class="burger__plus-btm" x="16" y="18" width="4" height="10"/>
    <rect class="burger__plus-right" x="18" y="16" width="10" height="4"/>
    <rect class="burger__plus-top" x="16" y="8" width="4" height="10"/>
  </g>
  </svg>
</button>
</div>

   <div class="content_container">
      <div class="common_box">
        <div class="slide_img" id="slide_img_1"><div class="slide_img_shade"></div></div>
        <div class="title_box">
          <h2 class="main_title"><span>WORKS</span></h2>
        </div> 
      </div>
      <div class="content_box">
          <div class="content_content" >
            <div class="post_content">
                <div class="content_title">
                  <h1>对象的新增方法</h1><span id="busuanzi_container_page_pv">
                  <span><time datetime=""></time></span>
                </div>
                  <h3 id="代码总结">代码总结</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>let obj = {a:1};
console.log(Object.is(obj,obj)); //true
console.log(Object.is({},{}));   //true
--------------------------------------------------------------------------------------------------------------------
console.log(+0 === -0);   //true
console.log(NaN === NaN); //false

console.log(Object.is(+0,-0));   //false
console.log(Object.is(NaN,NaN)); //true
--------------------------------------------------------------------------------------------------------------------
//Object.assign()
let target = {name:'tx'};
let source1 = {age:24};
let source2 = {sex:'男'};
Object.assign(target,source1,source2);
console.log(target); //{name: "tx", age: 24, sex: "男"}
--------------------------------------------------------------------------------------------------------------------
//Object.assign用途
class point {
construntor(x,y){
Object.assign(this,{x,y});
}
}
--------------------------------------------------------------------------------------------------------------------
////Object.assign用途
bject.assign(someClass.prototype,{
someMethod(arg1,arg2){

},
anotherMethod(){

}
});
//等同于下面的写法
someClass.prototype.someMethod = function(arg1,arg2){

};
someClass.prototype.anotherMethod = function(){

};
--------------------------------------------------------------------------------------------------------------------
//合并多个对象
const mergeobj = (target,...sources) =&gt; Object.assign(target,...sources);
--------------------------------------------------------------------------------------------------------------------
//为属性指定默认值(可用作默认配置参数)
const defaultconfig = {
name:'tx',
age :24
};

function processContent(options){
options = Object.assign({},defaultconfig,options);
console.log(options);
}
--------------------------------------------------------------------------------------------------------------------
//Object.keys()
let obj = {
	name:'tx',
	age : 24
};
Object.keys(obj); //["name", "age"]
--------------------------------------------------------------------------------------------------------------------
let {keys, values, entries} = Object;
let obj = { a: 1, b: 2, c: 3 };

for (let key of keys(obj)) {
  console.log(key); // 'a', 'b', 'c'
}

for (let value of values(obj)) {
  console.log(value); // 1, 2, 3
}

for (let [key, value] of entries(obj)) {
  console.log([key, value]); // ['a', 1], ['b', 2], ['c', 3]
}
--------------------------------------------------------------------------------------------------------------------
//Object.values()
let obj = {
	name:'tx',
	age :24
};
Object.values(obj); //["tx", 24]
--------------------------------------------------------------------------------------------------------------------
//Object.entries()
let obj = {
	name:'tx',
	age :24
};
Object.entries(obj); //[["name", "tx"],["age", 24]]
--------------------------------------------------------------------------------------------------------------------
//Object.entries的基本用途是遍历对象的属性。
let obj = { one: 1, two: 2 };
for (let [k, v] of Object.entries(obj)) {
  console.log(
    `${JSON.stringify(k)}: ${JSON.stringify(v)}`
  );
}
// "one": 1
// "two": 2

</code></pre>
</div>
<h3 id="一objectis">一、Object.is()</h3>
<p>es5比较两个值是否相等，只有两个运算符。相等运算符（==）和全等运算符（===）。他们都有缺点，前者会自动转换数据类型，后者的nNaN不等于自身，以及+0等于-0。javascript缺乏一种运算，在所有环境中，只要两个值是一样的，他们就应该像等。</p>

<p>es6提出同值相等算法，用来解决这个问题。Object.is就是部署这个算法的新方法。他用来比较两个值是否严格相等。与全等运算符（===）的作用基本一致。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let obj = {a:1};
console.log(Object.is(obj,obj)); //true
console.log(Object.is({},{}));   //true
</code></pre>
</div>
<p>不同之处只有两个：一是+0不等于-0，而是NaN等于自身。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>console.log(+0 === -0);   //true
console.log(NaN === NaN); //false

console.log(Object.is(+0,-0));   //false
console.log(Object.is(NaN,NaN)); //true
</code></pre>
</div>
<p>es5可以通过下面的代码，实现Object.is()。直接复制的。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Object.defineProperty(Object, 'is', {
value: function(x, y) {
if (x === y) {
// 针对+0 不等于 -0的情况
return x !== 0 || 1 / x === 1 / y;
}
// 针对NaN的情况
return x !== x &amp;&amp; y !== y;
},
configurable: true,
enumerable: false,
writable: true
});

</code></pre>
</div>
<h3 id="二objectassign">二、Object.assign()</h3>

<h4 id="基本用法">基本用法</h4>
<p>Object.assign方法用于对象的合并，将源对象的所有可枚举属性，复制到目标对象。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let target = {name:'tx'};
let source1 = {age:24};
let source2 = {sex:'男'};
Object.assign(target,source1,source2);
console.log(target); //{name: "tx", age: 24, sex: "男"}
</code></pre>
</div>
<p>Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。</p>

<p>注意：如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let target = {name:'tx'};
let source1 = {age:24};
let source2 = {name:'123'};
Object.assign(target,source1,source2);
console.log(target); {name: "123", age: 24}
</code></pre>
</div>
<p>如果只有一个参数，Object.assign会直接返回该参数。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let obj = {name:'tx'};
console.log(Object.assign(obj) === obj); //true
</code></pre>
</div>
<p>如果该参数不是对象，则会先转成对象，然后返回。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>console.log(Object.assign(2));        //Number {2}
console.log(typeof Object.assign(2)); //object
</code></pre>
</div>
<p>由于undefined和null无法转成对象，所以如果他们作为参数，就会报错。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Object.assign(undefined); //报错
Object.assign(null);      //报错
</code></pre>
</div>
<p>如果非对象参数不是出现在首参数的位置，那么处理规则有点不同，如果不能转成对象的会跳过。也就是说null和undefined如果不在首参数，就不会报错。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let obj = {name:'tx'};

console.log(Object.assign(obj,null) === obj);     //true
console.log(Object.assign(obj,undefined) === obj);//true 
</code></pre>
</div>
<p>其他类型的值（即数值，字符串和布尔值），不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝至目标对象，其他值都不会产生效果。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let target = {};
let source1 = 'hello';
let source2 = 24;
let source3 = true;
Object.assign(target,source1,source2,source3);
console.log(target); //{0: "h", 1: "e", 2: "l", 3: "l", 4: "o"}
</code></pre>
</div>
<p>上面代码中，只有字符串以数组的形式合入b目标对象，数字合布尔值都会忽略。这是因为只有字符串的包装对象，会产生可枚举属性。</p>

<p>Object.assign只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable:false）。</p>

<p>属性名为Symbol值的属性，也会被Object.assign拷贝。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>console.log(Object.assign({},{[Symbol('c')]:'d' })); 
//{Symbol(c): "d"}
</code></pre>
</div>
<h4 id="注意点">注意点</h4>

<h5 id="1浅拷贝">（1）浅拷贝</h5>
<p>Object.assign方法实行的是浅拷贝，如果源对象的某个属性值是对象，那么目标对象拷贝得到的是对这个对象的引用。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let obj = {a:{b:'tx'}};
let newobj = Object.assign({},obj);
obj.a.b = 'new';
console.log(newobj.a.b); //new
</code></pre>
</div>
<p>上面代码中，源对象a属性的值是一个对象，Object.assign拷贝得到的是这个对象的引用。这个对象的任何变化，都会反应到目标对象上。</p>

<h5 id="2同名属性的替换">（2）同名属性的替换</h5>
<p>对于嵌套的对象，一旦遇到同名属性，Object.assign的处理方式是替换，而不是添加。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let obj = {config:{name:'tx',age:24,sex:'男'}};
let obj2 = {config:{age:'28'}};
Object.assign(obj,obj2);
console.log(obj); //{config: {age:'28'}}
</code></pre>
</div>
<p>上面代码中，obj中的config属性被obj2的config属性这个替换掉了，而不是得到   {config:{name:’tx’,age:28,sex:’男’}}的结果，这通常不是开发者想要的，要特别小心。</p>

<h5 id="3数组的处理">（3）数组的处理</h5>
<p>Object.assign可以用来处理数组，但是会把数组视为对象。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let target = [1,2,3];
let source = [4,5];
Object.assign(target,source);
console.log(target); //[4, 5, 3]
</code></pre>
</div>
<p>上面代码中，Object.assign把数组视为属性名为0，1，2的对象，因此源数组的0好属性4和1号属性分别覆盖了目标数组的0号和1号。</p>

<h5 id="4取值函数的处理">（4）取值函数的处理</h5>
<p>Object.assign只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let target = {};
let source = {
get getnum() {
return 1;
}
};
Object.assign(target,source);
console.log(target); //{getnum: 1}
</code></pre>
</div>
<p>上面代码中，源对象的getname属性是一个取值函数，Object不会复制这个取值函数，只会拿到值以后，将这个值复制过去。</p>

<h4 id="常见用途">常见用途</h4>
<p>Object.assign方法有很多用处</p>

<h5 id="1为对象添加属性">（1）为对象添加属性</h5>
<div class="highlighter-rouge"><pre class="highlight"><code>class point {
construntor(x,y){
Object.assign(this,{x,y});
}
}
</code></pre>
</div>
<p>上面方法通过Object.assign方法，将x属性和y属性添加到point类的实例对象。【】不太明白。</p>

<h5 id="2为对象添加方法">（2）为对象添加方法</h5>
<div class="highlighter-rouge"><pre class="highlight"><code>Object.assign(someClass.prototype,{
someMethod(arg1,arg2){

},
anotherMethod(){

}
});
//等同于下面的写法
someClass.prototype.someMethod = function(arg1,arg2){

};
someClass.prototype.anotherMethod = function(){

};
</code></pre>
</div>
<p>上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用assign方法添加到someClass.prototype之中。</p>

<h5 id="3克隆对象">（3）克隆对象</h5>
<div class="highlighter-rouge"><pre class="highlight"><code>function clone(origin){
Object.assign({},origin);
}
</code></pre>
</div>
<p>上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。</p>

<p>采用这种克隆方法，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function clone(origin){
let originProto = Object.getPrototypeOf(origin);
return Object.assign(Object.create(originProto),origin);
}
</code></pre>
</div>
<h5 id="4---合并多个对象">(4)   合并多个对象</h5>
<p>将多个对象合并到某个对象</p>
<div class="highlighter-rouge"><pre class="highlight"><code>const mergeobj = (target,...sources) =&gt; Object.assign(target,...sources);
</code></pre>
</div>
<p>如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>const mergeobj = (...sources) =&gt;Object.assign({},...sources); 
</code></pre>
</div>
<h5 id="5-为属性指定默认值可用作默认配置参数">(5) 为属性指定默认值(可用作默认配置参数)</h5>
<div class="highlighter-rouge"><pre class="highlight"><code>const defaultconfig = {
name:'tx',
age :24
};

function processContent(options){
options = Object.assign({},defaultconfig,options);
console.log(options);
}
</code></pre>
</div>
<p>上面代码中，defaultconfig对象是默认配置，options是对象提供的参数。通过Object.assign方法将defaultconfig和options合并成一个新对象，如果两者有同名属性，则options的属性值会覆盖defaultconfig的属性值。</p>

<p>注意：由于存在浅拷贝的问题，defaultconfig对象和options对象的所有属性的值，最好都是基本数据类型，不要是复合类型。否则，defaultconfig的该属性很可能不起作用。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>const  defaultconfig = {
url : {
host : 'tianxinokok.com',
port : '8080'
}
};
function processContent(options){
options = Object.assign({},defaultconfig,options);
console.log(options); 
}
processContent( { url: {port:'123'} } ); //url: {port:'123'}}
</code></pre>
</div>
<p>上面代码的原意是将url.port改成123，url.host不变。实际结果确是options.url覆盖掉defaultconfig.url,导致url.host就不存在了。</p>

<h3 id="三objectgetownpropertydescriptors">三、Object.getOwnPropertyDescriptors()</h3>
<p>es5的Object.getOwnPropertyDescripto()方法会返回某个对象属性的描述对象，es6引入了Object.getOwnPropertyDescriptors()方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let obj  = {
	name:'tx',
	getName(){

	}
};
console.log(Object.getOwnPropertyDescriptors(obj));
// getName: {value: ƒ, writable: true, enumerable: true, configurable: true}
// name: {value: "tx", writable: true, enumerable: true, configurable: true}
</code></pre>
</div>
<p>上面代码中，Object.getOwnPropertyDescriptors()方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。</p>

<p>引入该方法的目的是为了解决Object.assign()无法正确拷贝get属性和set属性的问题。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let source = {
	set foo(value){
		console.log(value);
	}
};
let target = {};
Object.assign(target,source);
console.log(Object.getOwnPropertyDescriptor(target,'foo'));
// {
// 		configurable: true
// 		enumerable: true
// 		value: undefined
// 		writable: true
// }
</code></pre>
</div>
<p>上面代码中，source对象的foo属性的值是一个赋值函数，Object.assign将这个属性复制给target对象，结果该属性的值变为了undefined。这是因为Object.assign()方法总是拷贝一个属性的值，而不会拷贝他背后的赋值方法或者取值方法。</p>

<p>这时，Object.getOwnPropertyDescriptors()方法配合Object.defineProperties()方法，就可以实现正确拷贝。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let source = {
	set foo(value){
		console.log(value);
	}
};
let target = {};
Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));
console.log(Object.getOwnPropertyDescriptor(target,'foo'));
// {
// 	configurable: true
// 	enumerable: true
// 	get: undefined
// 	set: ƒ foo(value)
// }
</code></pre>
</div>
<p>上面代码中，两个对象合并的逻辑可以写成一个函数。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let shallowMerge = (target,source) =&gt; Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));
</code></pre>
</div>
<p>Object.getOwnPropertyDescriptors()方法的另一个作用，是配合Object.create()方法，将对象属性拷贝到一个新对象，这属于浅拷贝。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
//或者
let shallowclone = (obj) =&gt;  Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
</code></pre>
</div>
<p>上面代码会拷贝对象obj。</p>

<p>Object.getOwnPropertyDescriptors()可以实现一个对象继承另一个对象。以前，继承另一个对象，通常写成下面这样。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let obj = {
	__proto__:source,
	name:'tx'
};
</code></pre>
</div>
<p>es6规定__protot__只有浏览器要部署，其他环境不用部署。如果没有__protot__，上面代码就要写成这样。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let obj = Object.create(source);
obj.name = 'tx';
//或者 
let obj = Object.assign(Object.create(source),{name:'tx'});
</code></pre>
</div>
<p>有了Object.getOwnPropertyDescriptors()方法我们就有了另一种写法。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>const obj = Object.create(
  prot,
  Object.getOwnPropertyDescriptors({
    foo: 123,
  })
);
</code></pre>
</div>
<h3 id="四__proto__属性objectsetprototypeofobjectgetprototypeof">四、__proto__属性，Object.setPrototypeOf(),Object.getPrototypeOf()</h3>
<p>js的对象继承性是通过原型链实现的。es6提供了更多原型对象的操作方法。</p>

<h4 id="__proto__属性">__proto__属性</h4>
<p>__proto__属性：用来读取或者设置当前对象的prototype对象。目前，所有浏览都部署了这个属性。</p>
<div class="highlighter-rouge"><pre class="highlight"><code> //es5 
let obj = {
	getName:function(){

	}
};
obj.__proto__ = otherObj;
//es6
let obj = Object.create(otherObj);
obj.getName = funciton(){
	
}
</code></pre>
</div>
<p>该属性没有写入es6的正文，而是写入了附录，原因是__proto__写法的前后两个双下划线，说明他本质上是一个内部属性，而不是一个正式的对外API，只是由于浏览器广泛支持，才被加入了es6。标准明确规定，只有浏览器必须部署这个属性，其他环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的Objcet.setPrototypeOf()(写操作)和Object.getPrototypeOf()(读操作),Object.create()（生成操作）代替。</p>

<p>如果一个对象本身部署了__proto__属性，该属性的值就是对象的原型。</p>
<div class="highlighter-rouge"><pre class="highlight"><code> Object.getPrototypeOf({ __proto__: null }); //null
</code></pre>
</div>
<p>#### Object.setPrototypeOf()
 Object.setPrototypeOf()方法的作用与__proto__一样，用来设置一个对象的prototype对象，返回参数对象本身。它是es6正式推荐的设置原型对象的方法。</p>
<div class="highlighter-rouge"><pre class="highlight"><code> //格式 
Object.setPrototypeOf(object,prototype);
//用法
let obj = Object.setPrototypeOf({},null);  //{}
</code></pre>
</div>
<p>该方法等同于下面的函数。</p>
<div class="highlighter-rouge"><pre class="highlight"><code> function setPrototypeOf(obj,proto){
	obj.__proto__ = proto;
	return obj;
}
</code></pre>
</div>
<p>下面是一个例子。</p>
<div class="highlighter-rouge"><pre class="highlight"><code> let proto = {};
let obj = {
	name:'tx'
};
Object.setPrototypeOf(obj,proto);
proto.age = 24;
console.log(obj.age); //24
</code></pre>
</div>
<p>上面把obj的原型对象设为proto，所以obj可以读取proto原型对象上的属性。</p>

<p>如果第一个参数不是对象，会自动转为对象。但是由于返回还是第一个参数，所以这个操作不会产生任何效果。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Object.setPrototypeOf(123,{});      //123
Object.setPrototypeOf('hello',{});  //hello
Object.setPrototypeOf(true,{});     //true
</code></pre>
</div>
<p>由于undefined和null无法转为对象，所以如果第一个参数是undefined或者null，就会报错。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Object.setPrototypeOf(undefined,{});  //报错
Object.setPrototypeOf(null,{});       //报错
</code></pre>
</div>
<p>#### Object.getPrototypeOf()
 该方法与Object.setPrototypeOf()方法配套，用于获取一个对象的原型对象。</p>

<p>下面是一个例子。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function gzfunction(){}
let rec = new gzfunction();
Object.getPrototypeOf(rec) === gzfunction.prototype;              //true
Object.setPrototypeOf(rec,Object.prototype);
console.log(Object.getPrototypeOf(rec) === gzfunction.prototype); //false
</code></pre>
</div>
<p>跟setPrototypeOf()一样，如果第一个参数不是对象，会自动转为对象，如果是undefined或者null，会报错。</p>

<h3 id="五objectkeysobjectvaluesobjectentries">五、Object.keys(),Object.values(),Object.entries()</h3>

<h4 id="objectkeys">Object.keys()</h4>
<p>es5引入了Object.keys()方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let obj = {
	name:'tx',
	age : 24
};
Object.keys(obj); //["name", "age"]
</code></pre>
</div>
<p>es6引入了跟Object.keys()配套的Object.values()和Object.entries()，作为遍历一个对象的补充手段，供for…in循环使用。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let {keys, values, entries} = Object;
let obj = { a: 1, b: 2, c: 3 };

for (let key of keys(obj)) {
  console.log(key); // 'a', 'b', 'c'
}

for (let value of values(obj)) {
  console.log(value); // 1, 2, 3
}

for (let [key, value] of entries(obj)) {
  console.log([key, value]); // ['a', 1], ['b', 2], ['c', 3]
}
</code></pre>
</div>
<h4 id="objectvalues">Object.values()</h4>
<p>Object.values()方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumable）属性的键值。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let obj = {
	name:'tx',
	age :24
};
Object.values(obj); //["tx", 24]
</code></pre>
</div>
<p>返回的数组成员顺序，与上面介绍的规则一致。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let obj = {
	10  :'a',
	1   :'b',
	name:'tx'
};
Object.values(obj); //["b", "a", "tx"]
</code></pre>
</div>
<p>上面代码中，属性名为数值的属性是按照数值大小，从小到大遍历的，然后是属性名为字符串的属性。</p>

<p>Object.values()只返回对象自身的可遍历属性。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let obj = Object.create({}, {name:{vlaue:'tx'}});
console.log(Object.values(obj)); //[]
</code></pre>
</div>
<p>上面代码中，Object.create()方法的第二个参数添加的对象属性（属性name），如果不显示声明，默认是不可遍历的，因为name属性的描述对象的enumerable默认为false，
Object.values()不会返回这个属性。只要把name属性的enumerable改为true，Object.values()方法就会返回属性name的值。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let obj = Object.create({}, {name:
	{
	  value:'tx',
	  enumerable:true
    }
});
Object.values(obj); //["tx"]
</code></pre>
</div>
<p>注意：【】Object.create()总是忘记。不理解。</p>

<p>Object.values()方法会过滤属性名为Symbol值的属性。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Object.values({[Symbol()]:123 , name: 'tx'}); //["tx"]
</code></pre>
</div>
<p>如果Object.values(）方法的参数是一个字符出，会返回各个字符组成的数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Object.values('hello'); //["h", "e", "l", "l", "o"]
</code></pre>
</div>
<p>上面代码中，字符串会先转成一个类似数组的对象，字符串的每一个字符，就是该对象的一个属性。</p>

<p>如果参数不是对象，Object.values()会先将其转为对象。由于数组和布尔的包装对象，都不会为实例添加非继承的属性。所以，Object.values()会返回空数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Object.values(123) // []
Object.values(true) // []
</code></pre>
</div>
<h4 id="objectentries">Object.entries()</h4>
<p>Object.entries()方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let obj = {
	name:'tx',
	age :24
};
Object.entries(obj); //[["name", "tx"],["age", 24]]
</code></pre>
</div>
<p>除了返回值不一样，该方法的行为与Object.values()基本一样。</p>

<p>如果原对象的属性名是一个 Symbol 值，该属性会被忽略。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Object.entries({ [Symbol()]: 123, foo: 'abc' }); // [ [ 'foo', 'abc' ] ]
</code></pre>
</div>
<p>Object.entries的基本用途是遍历对象的属性。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let obj = { one: 1, two: 2 };
for (let [k, v] of Object.entries(obj)) {
  console.log(
    `${JSON.stringify(k)}: ${JSON.stringify(v)}`
  );
}
// "one": 1
// "two": 2
</code></pre>
</div>
<p>【】上面console里面的写法很喜欢。</p>

<p>Object.entries方法的另一个用处是，将对象转为真正的Map结构。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let obj = {
	name:'tx',
	age :24
};
let map = new Map(Object.entries(obj))
console.log(map); //{"name" =&gt; "tx", "age" =&gt; 24}
</code></pre>
</div>
<p>【】Map不懂</p>
<h3 id="六objectfromentries">六、Object.fromEntries()</h3>
<p>Object.fromEntries()方法是Object.entries()的逆操作，用于将一个键值对数组转为对象。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Object.fromEntries([['name','tx'],['age',24]]); //{name: "tx", age: 24}
</code></pre>
</div>
<p>注意:chrome版本要73以上</p>

<p>该方法的主要目的，是将键值对的数据解构还原为对象，因此特别适合将Map结构转为对象。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let entries = new Map([
	 ['name','tx'],
	 ['age',24]
]);
Object.fromEntries(entries); //{name: "tx", age: 24}
</code></pre>
</div>
<p>该方法的一个用处是配合URLSearchParams对象，将查询字符串转为对象。【】神奇</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Object.fromEntries(new URLSearchParams('foo=bar&amp;baz=qux'));
// { foo: "bar", baz: "qux" }
</code></pre>
</div>


   
            </div>
            
          </div>
          
                <div class="next_page_box">
                  <div class="read_next">阅读下一篇文章</div>
                  <div class="next_page">
                    <a class="" href="http://localhost:4000/tec/2018/12/23/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95.html" data-post-href="http://localhost:4000/tec/2018/12/23/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95.html">
                      <h4>对象的扩展</h4>
                      <div></div>
                    </a>
                  </div>
                </div>
          
          <div class="phone_bottom">
              <a class="" href="http://localhost:4000/tec/2019/01/26/Symbol.html" data-post-href="http://localhost:4000/tec/2019/01/26/Symbol.html">
              PREV
              </a>
              <a class="" href="http://localhost:4000/tec/2018/12/23/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95.html" data-post-href="http://localhost:4000/tec/2018/12/23/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95.html">
                NEXT
              </a>
          </div>
       </div>
    </div>
  </body>
<script src="/source/js/highlight.min.js"></script>
<script type="text/javascript" src="/source/js/jquery.js"></script>
<script type="text/javascript" src="/source/js/TweenMax.min.js"></script>
<script type="text/javascript" src="/source/js/DrawSVGPlugin.min.js"></script>
<script type="text/javascript" src="/source/js/tween.js"></script>
<script type="text/javascript" src="/source/js/animation.js"></script>
  <script type="text/javascript" src="/source/js/index.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
    $(document).ready(function(){
      //评论
        $('.comments').on('click',function(e){
          e.preventDefault();
          $('#lv-container').show();
        });
    })
  </script>
</html>