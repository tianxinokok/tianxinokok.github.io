<!DOCTYPE HTML>
<html>
<head>
  <meta charset="UTF-8">
    <link rel="stylesheet" href="/source/css/index.css" type="text/css">
    <link rel="stylesheet" href="/source/css/post_last.css" type="text/css">
    <link rel="stylesheet" href="/source/css/obsidian.min.css">
    <link rel="stylesheet" type="text/css" href="/source/css/font-awesome-4.7.0/css/font-awesome.min.css">
    <link rel="icon" href="/source/img/Favicon.png" sizes="32x32" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>摆渡先生</title>
</head>

 <body>
 <div class="nav_box" style="z-index: 10000">
<nav class="nav">
	<ul class="nav__list">
		<li class="nav__item">
			<a class="nav__link" href="/">
				<div class="nav__link-content">
					<span class="nav__link-num">01</span>
					<div class="nav__link-title">Works</div>
					<div class="nav__link-desc">What I'm made</div>
				</div>
				<div class="nav__link-base"></div>
			</a>
			<div class="nav__item-line"></div>
		</li>
		<li class="nav__item">
			<a class="nav__link" href="/new">
				<div class="nav__link-content">
					<span class="nav__link-num">02</span>
					<div class="nav__link-title">News</div>
					<div class="nav__link-desc">Latest ramblings</div>
				</div>
				<div class="nav__link-base"></div>
			</a>
			<div class="nav__item-line"></div>
		</li>
		<li class="nav__item">
			<a class="nav__link" href="/book">
				<div class="nav__link-content">
					<span class="nav__link-num">03</span>
					<div class="nav__link-title">Books</div>
					<div class="nav__link-desc">Many good books</div>
				</div>
				<div class="nav__link-base"></div>
			</a>
			<div class="nav__item-line"></div>
		</li>
		<li class="nav__item">
			<a class="nav__link" href="/contact">
				<div class="nav__link-content">
					<span class="nav__link-num">04</span>
					<div class="nav__link-title">Contact</div>
					<div class="nav__link-desc">Don't be shy</div>
				</div>
				<div class="nav__link-base"></div>
			</a>
			<div class="nav__item-line"></div>
		</li>
        <li class="phone_btn_close nav__item">
            x
        </li>
	</ul>
  <div class="header_logo">
    <svg version="1.1"  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
   viewBox="0 0 825 299" style="enable-background:new 0 0 825 299;" xml:space="preserve">
<g class="logo_baidu">
  <path class="st0 logo_baidu_letter" fill="#fff" d="M132.94,183.58c-5.84,0.73-10.94,1.46-15.31,2.19c-2.19,0.73-4.02,0-5.47-2.19c0-5.1,1.82-8.02,5.47-8.75
    c3.64,0.73,8.75,1.09,15.31,1.09c0-5.1-0.37-10.2-1.09-15.31c0-2.91,1.09-4.38,3.28-4.38c7.29,0.73,10.57,3.65,9.84,8.75
    c-0.73,2.92-1.09,6.56-1.09,10.94h8.75c2.91,0.73,4.38,2.19,4.38,4.38c-2.19,1.46-6.56,2.19-13.13,2.19v9.84
    c7.29-1.45,11.3-1.45,12.03,0c0.73,2.19-3.28,4.74-12.03,7.66c0,11.67,0.36,21.52,1.09,29.53c0.73,5.84-1.46,10.21-6.56,13.13
    c-4.38,2.19-10.94,1.83-19.69-1.09c-7.3-3.64-11.3-7.29-12.03-10.94c17.5,4.38,26.25,3.65,26.25-2.19c0.73-9.48,0.73-17.86,0-25.16
    c-8.75,2.92-14.95,4.74-18.59,5.47c-2.92,0-4.74-1.45-5.47-4.38c-0.73-3.64,0.73-5.83,4.38-6.56c5.1-0.73,11.66-1.82,19.69-3.28
    V183.58z M217.16,162.8c3.64,0.73,5.47,3.28,5.47,7.66c-1.46,5.84-2.19,11.67-2.19,17.5c-0.73,3.65-2.92,5.11-6.56,4.38
    c-6.56-1.45-12.77-2.19-18.59-2.19c-0.73,2.19-0.73,4.38,0,6.56h14.22c3.64,0,5.83,0.73,6.56,2.19c0.73,2.92-1.09,4.38-5.47,4.38
    h-15.31c-0.73,2.19-0.73,4.38,0,6.56c15.31,0.73,28.8,0.73,40.47,0c-5.11,10.94-12.4,14.22-21.88,9.84
    c-6.56-2.19-13.13-3.28-19.69-3.28l-5.47,6.56c-2.92,2.92-5.11,5.47-6.56,7.66c3.64,2.92,7.66,4.02,12.03,3.28
    c5.1-1.45,8.38-3.28,9.84-5.47c-1.46-0.73-3.28-1.82-5.47-3.28c0.73-3.64,2.55-5.47,5.47-5.47c2.91-0.73,6.2,0.73,9.84,4.38
    c5.1,4.38,8.75,8.39,10.94,12.03c2.19,4.38,0.73,5.84-4.38,4.38c-3.65-2.91-7.66-5.83-12.03-8.75c-5.11,7.3-11.3,10.58-18.59,9.84
    c-8.02-3.64-13.13-5.1-15.31-4.38c-2.92,0.73-5.84,1.83-8.75,3.28c-2.92,0.73-5.11-0.36-6.56-3.28c-0.73-2.19,0-4.01,2.19-5.47
    c2.91-2.19,5.83-4.01,8.75-5.47c6.56-3.64,10.57-6.92,12.03-9.84c-14.59,0.73-24.06,1.83-28.44,3.28
    c-3.65,0.73-5.11-0.73-4.38-4.38c1.45-3.64,3.28-5.83,5.47-6.56c6.56,1.46,15.67,1.83,27.34,1.09c0.73-2.19,0.73-4.38,0-6.56
    c-7.3,0-13.49,0.37-18.59,1.09c-3.65,0.73-4.74-1.09-3.28-5.47c1.45-1.45,3.64-2.55,6.56-3.28c5.1,0.73,10.2,1.09,15.31,1.09
    c0.73-2.19,0.73-4.38,0-6.56c-6.56,0-11.67,0.73-15.31,2.19c-3.65,1.46-5.84,0.37-6.56-3.28c-0.73-8.75-1.46-15.67-2.19-20.78
    c0-4.38,2.55-6.2,7.66-5.47C181.8,164.99,198.93,164.99,217.16,162.8z M167.94,170.46c-0.73,2.92-0.73,7.3,0,13.13
    c3.64,1.46,6.56,1.46,8.75,0c0.73-4.38,0.73-8.75,0-13.13C174.51,169.73,171.58,169.73,167.94,170.46z M184.35,183.58
    c3.64,0.73,6.56,0.73,8.75,0c0.73-5.1,0.73-9.48,0-13.13c-2.92-0.73-5.84-0.73-8.75,0C183.62,175.57,183.62,179.94,184.35,183.58z
     M200.76,170.46c-0.73,3.65-0.73,8.02,0,13.13c4.38,1.46,7.66,1.46,9.84,0c2.19-3.64,2.55-8.02,1.09-13.13
    C208.05,169.73,204.4,169.73,200.76,170.46z"/>
  <path class="st0 logo_baidu_letter" fill="#fff" d="M255.44,189.05c8.75,2.92,17.5,5.11,26.25,6.56c1.45,0.73,1.45,1.83,0,3.28c-5.84,2.19-11.3,3.28-16.41,3.28
    c-7.3,0.73-13.13,0-17.5-2.19c-2.92-2.19-2.92-5.1,0-8.75C249.98,189.05,252.52,188.33,255.44,189.05z M255.44,216.4
    c8.75-1.45,17.5-4.01,26.25-7.66c1.45-0.73,2.55-0.73,3.28,0c-2.19,4.38-5.11,8.02-8.75,10.94c-4.38,3.65-10.94,6.93-19.69,9.84
    c-2.92,0-5.11-1.82-6.56-5.47C249.24,219.68,251.07,217.13,255.44,216.4z M262.01,166.08c7.29,5.11,14.95,9.48,22.97,13.13
    c-0.73,1.46-4.38,2.19-10.94,2.19s-12.77-1.45-18.59-4.38c-2.19-1.45-2.92-3.28-2.19-5.47
    C254.71,167.18,257.63,165.36,262.01,166.08z M313.41,186.87c-4.38-0.73-8.39-0.36-12.03,1.09c0,5.84-0.73,13.13-2.19,21.88
    c-0.73,4.38-2.19,8.39-4.38,12.03c-2.19,3.65-4.38,6.56-6.56,8.75c-5.11,4.38-9.48,6.93-13.13,7.66c-2.92,0-5.47-0.36-7.66-1.09
    c-1.46-1.45-2.55-2.55-3.28-3.28c2.91-2.19,6.2-4.01,9.84-5.47c3.64-2.19,6.92-5.1,9.84-8.75c2.19-3.64,4.01-7.29,5.47-10.94
    c1.45-5.83,2.19-11.3,2.19-16.41c0.73-8.75-0.37-16.04-3.28-21.88c0-4.38,2.19-6.56,6.56-6.56c4.38,1.46,12.39,2.19,24.06,2.19
    v-6.56c1.45-2.91,4.38-4.01,8.75-3.28c2.19,0.73,4.01,1.83,5.47,3.28v6.56h20.78c6.56,0,9.84,1.46,9.84,4.38
    c-1.46,1.46-7.66,2.19-18.59,2.19c-1.46,2.92-1.46,5.47,0,7.66h8.75c5.83,0,8.75,1.09,8.75,3.28s-1.09,3.28-3.28,3.28h-14.22
    c-0.73,3.65-0.73,6.93,0,9.84c0.73,3.65-1.09,5.11-5.47,4.38c-2.92-1.45-5.84-2.55-8.75-3.28c-2.19,0-4.38,0-6.56,0
    c-2.19,0.73-4.02,1.46-5.47,2.19c-3.65,0.73-5.47-0.36-5.47-3.28C314.14,192.33,314.14,189.05,313.41,186.87z M314.51,202.18
    c2.19,0.73,4.38,1.09,6.56,1.09c7.29-0.73,14.95-0.36,22.97,1.09c5.1,1.46,6.92,4.02,5.47,7.66c-2.19,2.92-5.11,6.93-8.75,12.03
    c16.04,5.11,28.07,7.66,36.09,7.66c-7.3,10.94-14.59,14.58-21.88,10.94c-6.56-4.38-13.49-8.75-20.78-13.13
    c-9.48,5.11-17.87,8.75-25.16,10.94c-6.56,1.46-10.58-0.73-12.03-6.56c0.73-0.73,4.73-1.82,12.03-3.28
    c8.02-1.45,14.22-3.64,18.59-6.56c-4.38-2.91-8.39-5.47-12.03-7.66c0-3.64,1.82-5.1,5.47-4.38c3.64,2.19,7.66,4.74,12.03,7.66
    c2.91-2.19,4.73-4.73,5.47-7.66c0.73-2.19-0.73-3.28-4.38-3.28c-6.56,0-12.77,0.37-18.59,1.09c-3.65,2.19-5.84,2.19-6.56,0
    C309.76,205.46,311.58,202.91,314.51,202.18z M313.41,172.65c-3.65-0.73-8.02-0.73-13.13,0c-0.73,2.92-0.73,5.47,0,7.66
    c4.38,0.73,8.75,0.73,13.13,0C314.14,177.39,314.14,174.83,313.41,172.65z M322.16,172.65c-0.73,2.92-0.73,5.47,0,7.66
    c5.1,0.73,9.48,0.73,13.13,0c0.73-2.91,0.73-5.47,0-7.66C330.91,171.92,326.54,171.92,322.16,172.65z M336.38,186.87
    c-4.38-0.73-9.12-0.73-14.22,0c0,1.46,0,3.28,0,5.47c4.38,0.73,8.38,0.73,12.03,0C336.38,192.33,337.11,190.51,336.38,186.87z"/>
</g>
<polyline class="st1 logo_baidu_border" points="409.5,179.35 409.5,261 81.5,261 81.5,140 367.18,140 " fill="none" stroke="#fff" stroke-miterlimit="10" stroke-width="16"/>
<g class="logo__plus" fill="none" stroke="#fff" stroke-miterlimit="10" stroke-width="16">
  <line class="st1 logo__plus-horz" x1="382.5" y1="140.5" x2="436.5" y2="140.5"/>
  <!-- <path class="st1" d="M411.5,117.5"/> -->
  <line class="st1 logo__plus-vert" x1="409.5" y1="167.5" x2="409.5" y2="113.5"/>
</g>
<g class="logo__xiansheng">
  <path class="st2 logo_xiansheng_letter" fill="#fff" d="M484.78,60.65c-5.11,3.65-9.12,5.47-12.03,5.47c-4.38,0-5.47-1.09-3.28-3.28c5.1-2.91,8.75-8.02,10.94-15.31
    c1.45-6.56,3.64-9.48,6.56-8.75c2.91,0,4.73,1.46,5.47,4.38c0,3.65-1.09,6.56-3.28,8.75h16.41V39.87c0-4.38,1.82-6.92,5.47-7.66
    c6.56,0,9.84,2.92,9.84,8.75V51.9h25.16c4.38,0,6.2,1.83,5.47,5.47c-0.73,2.19-2.19,3.28-4.38,3.28h-26.25v8.75
    c10.94,0,22.6,0.37,35,1.09c2.91,0,4.73,1.09,5.47,3.28c0.73,4.38-1.83,6.56-7.66,6.56c-10.21-0.73-19.69-1.09-28.44-1.09v10.94
    c0,8.02,6.56,12.03,19.69,12.03c14.58,0.73,26.25-1.45,35-6.56c-2.92,10.94-6.2,17.5-9.84,19.69c-7.3,5.11-17.87,5.84-31.72,2.19
    c-5.11-1.45-9.48-3.28-13.13-5.47c-7.3-4.38-11.3-10.57-12.03-18.59V79.24h-6.56c-0.73,4.38-2.55,9.48-5.47,15.31
    c-6.56,9.48-14.22,16.05-22.97,19.69c-7.3,2.92-14.59,3.65-21.88,2.19c-6.56-2.91-8.75-5.83-6.56-8.75
    c24.79-0.73,40.1-10.2,45.94-28.44c-5.84-0.73-13.49,0-22.97,2.19c-7.3,2.19-10.58,0.73-9.84-4.38c3.64-5.83,6.92-8.38,9.84-7.66
    c8.02,1.46,18.95,1.46,32.81,0v-8.75H484.78z"/>

  <path class="st3 logo_xiansheng_letter" fill="#fff" d="M645.29,63.43c-6.56-0.73-14.22-0.73-22.97,0c-2.92,3.65-7.3,6.93-13.13,9.84c-2.92,0.73-4.02,0-3.28-2.19
    c5.83-6.56,9.84-13.48,12.03-20.78c2.19-8.75,6.2-12.03,12.03-9.84c4.38,2.92,3.64,8.02-2.19,15.31h17.5
    c0.73-6.56,0.73-12.39,0-17.5c0-4.38,2.19-6.92,6.56-7.66c5.83,0,8.75,2.55,8.75,7.66c0,8.75,0.36,14.59,1.09,17.5h22.97
    c8.02-0.73,12.03,0.73,12.03,4.38c2.19,3.65-9.48,4.74-35,3.28c-1.46,3.65-1.46,7.3,0,10.94l21.88,1.09c2.91,0,6.2,0.73,9.84,2.19
    c1.45,2.92,1.09,4.74-1.09,5.47c-8.75-0.73-18.23-0.73-28.44,0c-2.19,0-3.28,3.65-3.28,10.94c0.73,6.56,16.04,8.02,45.94,4.38
    c3.64,0,8.02-0.73,13.13-2.19c-3.65,16.77-12.03,22.97-25.16,18.59c-22.61-8.02-48.13-10.2-76.56-6.56
    c-10.94,2.19-17.87,3.65-20.78,4.38c-5.84,1.46-8.02-0.36-6.56-5.47c2.91-5.83,6.92-9.48,12.03-10.94
    c2.91-0.73,7.29-0.36,13.13,1.09c18.95,2.19,28.8,1.46,29.53-2.19c1.45-8.02,0-12.03-4.38-12.03c-7.3-0.73-14.22,0-20.78,2.19
    c-4.38,1.46-5.84-0.36-4.38-5.47c0.73-2.19,2.91-4.38,6.56-6.56c2.91-1.45,5.83-1.09,8.75,1.09c5.83,0.73,10.2,0.73,13.13,0
    C646.38,72.91,646.74,69.27,645.29,63.43z"/>
</g>
<polyline class="st1 logo_xiansheng_border" points="409.5,101.65 409.5,20 737.5,20 737.5,141 451.82,141 " fill="none" stroke="#fff" stroke-miterlimit="10" stroke-width="16"/>
</svg>
  </div>
</nav>
<svg class="nav__bg" width="100%" height="100%" viewBox="0 0 100 100" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg">
    <defs>
        <linearGradient class="nav__grad" x1="92.6356902%" y1="7.36430977%" x2="0%" y2="100%" id="nav-grad">
            <!-- <stop stop-color="#000000" offset="20%"></stop>
            <stop stop-color="#223e36" offset="100%"></stop> -->
            <!-- <stop stop-color="#43C6AC" offset="20%"></stop>
            <stop stop-color="#191654" offset="100%"></stop> -->
            <stop stop-color="#00dbde" offset="20%"></stop>
            <stop stop-color="#fc00ff" offset="100%"></stop>
        </linearGradient>
		<mask id="nav__bg-mask" class="nav__bg-mask" maskUnits="userSpaceOnUse"x="0" y="0" width="100" height="100">
		  	<rect class="nav__bg-mask-rect" x="0" y="0" width="25" height="100" fill="white"/>
			<rect class="nav__bg-mask-rect" x="24.9" y="0" width="25.1" height="100" fill="white"/>
			<rect class="nav__bg-mask-rect" x="49.9" y="0" width="25.1" height="100" fill="white"/>
			<rect class="nav__bg-mask-rect" x="74.9" y="0" width="25.1" height="100" fill="white"/>
		</mask>
    </defs>
    <rect x="0" y="0" width="100" height="100" fill="url(#nav-grad)" mask="url(#nav__bg-mask)"></rect>
</svg>
 <!--pc_menu_btn--> 
<button class="nav-btn">
  <svg class="burger <?php echo $darkBurgerClass; ?>" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 36 36">
  <rect class="burger__stroke"  x="2" y="2" width="32" height="32" fill="none" stroke="" stroke-miterlimit="10" stroke-width="4"/>
  <polyline class="burger__stroke-over"points="18 2 34 2 34 34 2 34 2 2 18 2" fill="none" stroke="" stroke-miterlimit="10" stroke-width="4"/>
  <g class="burger__plus">
    <rect class="burger__plus-left" x="8" y="16" width="10" height="4"/>
    <rect class="burger__plus-btm" x="16" y="18" width="4" height="10"/>
    <rect class="burger__plus-right" x="18" y="16" width="10" height="4"/>
    <rect class="burger__plus-top" x="16" y="8" width="4" height="10"/>
  </g>
  </svg>
</button>
</div>

   <div class="content_container">
      <div class="common_box">
        <div class="slide_img" id="slide_img_1"><div class="slide_img_shade"></div></div>
        <div class="title_box">
          <h2 class="main_title"><span>WORKS</span></h2>
        </div> 
      </div>
      <div class="content_box">
          <div class="content_content" >
            <div class="post_content">
                <div class="content_title">
                  <h1>Class的基本语法</h1><span id="busuanzi_container_page_pv">
                  <span><time datetime=""></time></span>
                </div>
                  <h3 id="代码总结">代码总结</h3>
<pre><code>//es5写法
function func(a,b){
    this.a = a;
    this.b = b;
}
func.prototype.toString = function(){
    return '(' + this.a + ',' + this.b + ')'; 
}
var p =  new func(1,2);
p.toString(); //(1,2)

//es6写法
class func {
    constructor(a,b){
        this.a = a ;
        this.b = b;
    }

    toString(){
        return '(' + this.a + , this.b + ')' ;
    }
}
--------------------------------------------------------------------------------------------------------------------
class func {
    constructor(){

    }
    getName(){

    }
    toString(){

    }
}
//等同于
func.prototype = {
    constructor(){

    },
    getName(){

    },
    toString(){
        
    }
};
--------------------------------------------------------------------------------------------------------------------
//Object.assign向类的prototype添加方法
class func {
    constructor(){

    }
}
Object.assign(func.prototype,{
    getName(){},
    toString(){}
});
--------------------------------------------------------------------------------------------------------------------
//类的内部方法不可枚举
class func {
    constructor(){

    }
    toString(){

    }
}
Object.keys(func.prototype);                //[]
Object.getOwnPropertyNames(func.prototype); //["constructor", "toString"]

//es5的写法就是可枚举的
var func = function(a,b){

};
func.prototype.toString = function(){

};
Object.keys(func.prototype);                //["toString"]
Object.getOwnPropertyNames(func.prototype); //["constructor","toString"]
--------------------------------------------------------------------------------------------------------------------
//与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。
class Point {

  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  toString() {
    return '(' + this.x + ', ' + this.y + ')';
  }

}

var point = new Point(2, 3);

point.toString() // (2, 3)

point.hasOwnProperty('x') // true
point.hasOwnProperty('y') // true
point.hasOwnProperty('toString') // false
point.__proto__.hasOwnProperty('toString') // true
--------------------------------------------------------------------------------------------------------------------
//类不存在变量提升
new func(); //Cannot access 'func' before initialization
class func{}
--------------------------------------------------------------------------------------------------------------------
//类的内部含有this，默认指向类的实例。小心使用，单独使用该方法，可能报错。
class Logger{
    printName(name = "there"){
        this.print(`hello ${name}`);
    }
    print(text){
        console.log(text);
    }
}
const logger = new Logger();
const {printName} = logger;
printName();  //Cannot read property 'print' of undefined

//解决办法1：在构造函数中绑定this
class Logger{
    constructor(){
        this.printName = this.printName.bind(this);
    }

}
//解决办法2：使用箭头函数
class Obj {
    constructor(){
        this.getThis = () =&gt; this;
    }
}
const myobj = new Obj();
myobj.getThis() === myobj ;  //true
</code></pre>

<h3 id="一简介">一、简介</h3>

<h4 id="类的由来">类的由来</h4>
<p>js语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。</p>
<pre><code>function func(a,b){
    this.a = a;
    this.b = b;
}
func.prototype.toString = function(){
    return '(' + this.a + ',' + this.b + ')'; 
}
var p =  new func(1,2);
p.toString(); //(1,2)
</code></pre>
<p>上面这种写法跟传统的面向对象语言相差很大，很容易让新学习这门语言的程序员感到困惑。</p>

<p>es6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过Class关键字，可以定义类。</p>

<p>基本上，es6的class可以看作只是一个语法糖，它的绝大部分功能，es5都可以做大，新的class写法只是让对象原型的写法更加清晰，更像面向对象编程的语法而已。上面的代码用es6的class改写，就是下面这样。</p>
<pre><code>class func {
    constructor(a,b){
        this.a = a ;
        this.b = b;
    }

    toString(){
        return '(' + this.a + , this.b + ')' ;
    }
}
</code></pre>
<p>上面代码定义了一个类 ， 可以看到里面有一个constructor方法，这就是构造方法，而this关键字代表实例对象。也就是说，es5的构造函数func，对应es6的func类的构造方法。</p>

<p>func类除了构造方法，还定义了toString方法。注意，定义类的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去就可以了。而且，方法跟方法之间不需要逗号分隔，加了会报错。</p>

<p>es6的类，完全可以看作构造函数的另一种写法。</p>
<pre><code>class func {

}
console.log(typeof func);                          //"function"
console.log(func === func.prototype.constructor);  //true
</code></pre>
<p>上面代码说明，类的数据类型就是函数，类本身就指向构造函数。</p>

<p>使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。</p>
<pre><code>class func {
    getName(){
        console.log('hello')
    }
}
var b = new func();
b.getName(); //"hello"
</code></pre>
<p>构造函数的prototype属性，在es6的”类”上面继续存在，事实上，类的所有方法都定义在类的prototype属性上面。</p>
<pre><code>class func {
    constructor(){

    }
    getName(){

    }
    toString(){

    }
}
//等同于
func.prototype = {
    constructor(){

    },
    getName(){

    },
    toString(){
        
    }
};
</code></pre>
<p>在类的实例上调用方法，其实就是调用原型上的方法。</p>
<pre><code>class B {}
let b = new B();
console.log(b.constructor === B.prototype.constructor); //true
</code></pre>
<p>上面代码中，b是B类的实例，它的constructor方法就是B类原型上的constructor方法。</p>

<p>由于类的方法都定义在prototype上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便的一次向类添加多个方法。</p>
<pre><code>class func {
    constructor(){

    }
}
Object.assign(func.prototype,{
    getName(){},
    toString(){}
});
</code></pre>
<p>prototype对象的constructor属性，直接指向类的本身，这与es5的行为是一致的。</p>
<pre><code>class func {
    constructor(){

    }
}
func.prototype.constructor === func; //true
</code></pre>
<p>另外，类的内部所有定义的方法，都是不可枚举的。</p>
<pre><code>class func {
    constructor(){

    }
    toString(){

    }
}
Object.keys(func.prototype);                //[]
Object.getOwnPropertyNames(func.prototype); //["constructor", "toString"]
</code></pre>
<p>上面代码中，toString方法是func类内部定义的方法，它是不可枚举的。这一点与es5的行为不一致。</p>
<pre><code>var func = function(a,b){

};
func.prototype.toString = function(){

};
Object.keys(func.prototype);                //["toString"]
Object.getOwnPropertyNames(func.prototype); //["constructor","toString"]
</code></pre>
<p>上面代码采用es5的写法，toString方法就是可枚举的。</p>

<h4 id="constructor方法">constructor方法</h4>
<p>constructor方法是类的默认方法，通过new命令生成类的实例时，自动调用该方法。一个类一定会有constructor方法，如果没有显示定义，一个空的construction方法会被默认添加。</p>
<pre><code>class Point {
}
//等同于
class Point {
    constructor(){
        
    }
}
</code></pre>
<p>如果定义一个空的类Point，js引擎会自动为他添加一个空的constructor方法。</p>

<p>constructor方法默认会返回实例对象（即this），完全可以指定返回另外一个对象。</p>
<pre><code>class Point {
    constructor(){
        return Object.create(null);
    }
}
new Point() instanceof Point ; //false
</code></pre>
<p>上面代码中，constructor函数返回一个全新的对象，结果导致实例对象不是Point类的实例。</p>

<p>类必须使用new调用，否则会报错。这是他跟普通构造函数的一个主要区别，后者不用new也可以执行。</p>
<pre><code>class Point {
}
Point(); // Class constructor Point cannot be invoked without 'new'
</code></pre>
<h4 id="类的实例">类的实例</h4>
<p>生成类的实例的写法，与es5一样，也是使用new命令，前面已经说过，类的实例如果忘记加new，会报错。</p>

<p>与es5一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。</p>
<pre><code>class Point {
    constructor(x,y){
        this.x = x;
        this.y = y;
    }
    toString(){
        return '(' + this.x + ',' + this.y + ')';
    }
}
let point = new Point(1,2);
console.log(point.hasOwnProperty('x'));                   //true
console.log(point.hasOwnProperty('y'));                   //true
console.log(point.hasOwnProperty('toString'));            //false
console.log(point.__proto__.hasOwnProperty('toString'));  //true
</code></pre>
<p>上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，而toString方法是原型对象的属性（因为定义在Point类上），所以hasOwnPrototype方法返回false。这些都与es5的行为保持一致。</p>

<p>与es5一样，类的所有实例共享一个原型对象。</p>
<pre><code>class Point{

}
var x1 = new Point();
var x2 = new Point();
console.log(x1.__proto__ === x2.__proto__); //true
</code></pre>
<h4 id="属性表达式">属性表达式</h4>
<p>类的属性名，可以采用表达式。</p>
<pre><code>let methodName = 'getName';
class func {
    [methodName](){
        
    }
}
</code></pre>
<p>上面代码中，func类的方法名getName，是从表达式得到的。</p>
<h4 id="class表达式">Class表达式</h4>
<p>与函数一样，类也可以使用表达式的形式定义。</p>
<pre><code>let myclass = class func{
    getName(){
        return func.name;
    }
};
</code></pre>
<p>上面代码使用了表达式定义一个类。需要注意的是，这个类的名字是func，但是func只在Class的内部可用，指代当前类。在class的外部，这个类只能用myclass引用。看下面。</p>
<pre><code>let inst = new myclass();
inst.getName(); //"func"
func.Name;      //func is not defined
</code></pre>
<p>上面代码表示，func只在Class内部有定义。</p>

<p>如果类的内部没有用到的话，可以省略内部的名字func，也就是下面的形式。</p>
<pre><code>let myclass = class{

};
</code></pre>
<p>采用Class表达式，可以写出立即执行的Class。</p>
<pre><code>let myclass  = new class {
    constructor(name){
        this.name = name;
    }
    getName(){
        console.log(this.name);
    }
    }('tx');
myclass.getName();  //"tx"
</code></pre>
<p>上面代码中，myclass是一个立即执行的类的实例。</p>

<h4 id="注意点">注意点</h4>

<h5 id="1严格模式">（1）严格模式</h5>
<p>类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要代码写在类或者模块之中，默认就是严格模式。考虑到未来所有的代码，其实都是运行在模块之中，所以es6实际上把整个语言升级到了严格模式。</p>

<h5 id="2不存在提升">（2）不存在提升</h5>
<p>类不存在变量提升，这一点与es5不同。</p>
<pre><code>new func(); //Cannot access 'func' before initialization
class func{}
</code></pre>
<p>上面代码中，func类使用在前，声明在后，这样会报错，因为es6不会把类的声明提升到代码开头。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。</p>
<pre><code>{
  let Foo = class {};
  class Bar extends Foo {
  }
}
</code></pre>
<p>上面代码不会报错，因为Bar继承Foo的时候，Foo已经有定义了。但是，如果存在class的提升，上面的代码就会报错，因为Class会被提升到代码头部，而let命令是不提升的。所以导致Bar继承Foo的时候，Foo还没有被定义。</p>

<h5 id="3name属性">（3）name属性</h5>
<p>本质上，class只是es5构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。</p>
<pre><code>class func{}
console.log(func.name); //"func"
</code></pre>
<p>name属性总是返回紧跟在class关键字后面的类名。</p>
<h5 id="4generator-方法">（4）Generator 方法</h5>
<p>如果某个方法之前加上星号（* ) ，就表示该方法是一个Generator函数。</p>
<pre><code>class func{
    constructor(...args){
        this.args = args;
    }
    *[Symbol.iterator](){
        for(let arg of this.args){
            yield arg;
        }
    }
}
for(let v of new func('hello','world')){
    console.log(v);
}
//"hello"
//"world"
</code></pre>

<p>上面代码中，func类的Symbol.iterator方法前有一个星号，表示该方法是一个Generator函数。Symbol.iterator方法返回一个func类的默认遍历器，for…of循环会自动调用这个遍历器。</p>
<h5 id="5this的指向">（5）this的指向</h5>
<p>类的方法内部如果含有this，他们默认指向类的实例。但是必须非常小心，一旦单独使用该方法，很可能报错。</p>
<pre><code>class Logger{
    printName(name = "there"){
        this.print(`hello ${name}`);
    }
    print(text){
        console.log(text);
    }
}
const logger = new Logger();
const {printName} = logger;
printName();  //Cannot read property 'print' of undefined
</code></pre>
<p>上面代码中，prientName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境（由于class内部是严格模式，所以实际上this指向的是undefined），从而导致找不到print方法而报错。</p>

<p>一个比较简单的解决办法是，在构造函数中绑定this，这样就不会找不到print方法了。</p>
<pre><code>class Logger{
    constructor(){
        this.printName = this.printName.bind(this);
    }

}
</code></pre>
<p>另一种解决方法是使用箭头函数。</p>
<pre><code>class Obj {
    constructor(){
        this.getThis = () =&gt; this;
    }
}
const myobj = new Obj();
myobj.getThis() === myobj ;  //true
</code></pre>
<p>箭头函数内部的this总是指向定义时所在的对象。上面代码中，箭头函数位于构造函数内部，他的定义生效的时候，是在构造函数执行的时候。这时，箭头函数所在的运行环境，肯定是实例对象，所以this总是指向实例对象。</p>

<p>还有一种解决方法是使用Proxy，获取方法的时候，自动绑定this。【】没写代码 不懂</p>

<h3 id="二静态方法">二、静态方法</h3>
<p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为”静态方法”。</p>
<pre><code>class Obj {
    static classMethod(){
        console.log('hello')
    }
}
Obj.classMethod();           //"hello"
let newobj  =  new Obj();
newobj.classMethod();       //newobj.classMethod is not a function
</code></pre>
<p>上面代码中，Obj类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Obj类上使用，而不能在Obj的实例上调用。</p>

<p>注意：如果静态方法包含this关键字，这个this指的是类，而不是实例。</p>
<pre><code>class Obj {
    static getName(){
        this.getAge();
    }
    static getAge(){
        console.log('我是静态方法getAge');
    }
    getAge(){
        console.log('我不是静态方法的getAge');
    }

}
Obj.getName();  //我是静态方法getAge
</code></pre>
<p>上面代码中，静态方法getName调用了this.getAge(),这里的this指的是Obj类，而不是Obj的实例，等同于调用Obj.getName()。从这个例子也可以看出，静态方法可以与非静态方法重名。</p>

<p>父类的静态方法，可以被子类继承。</p>
<pre><code>class Obj {
    static classMethod(){
        console.log('我是父类的静态方法');
    }
}
class Bar extends Obj{

}
Bar.classMethod(); //我是父类的静态方法
</code></pre>
<p>上面代码中，父类Obj有一个静态的classMethod方法，子类Bar可以调用这个方法。</p>

<p>静态方法也是可以从super对象上调用的。【】下面这个不懂</p>
<pre><code>class Foo {
  static classMethod() {
    return 'hello';
  }
}

class Bar extends Foo {
  static classMethod() {
    return super.classMethod() + ', too';
  }
}

Bar.classMethod() // "hello, too"
</code></pre>
<h3 id="三实例属性的新写法">三、实例属性的新写法</h3>
<p>实例属性除了定义在constructor()方法里面this上，也可以定义在类的最顶层。</p>
<pre><code>class Obj {
   _name = 'tx';
   getName(){
       console.log(this._name);
   }
}
</code></pre>
<p>上面代码中,_name属性与函数getName ()方法处在同一个层级。这时，不需要在实例属性前面加上this。</p>

<p>这种写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去很整齐，一眼就能看出这个类有哪些实例属性。</p>
<h3 id="四静态属性">四、静态属性</h3>
<p>静态属性指的是Class本身的属性，即Class.propName,而不是定义在实例对象（this）上的属性。</p>
<pre><code>class Obj {}
Obj.name = 'tx';
</code></pre>
<p>上面写法为Obj类定义了一个静态属性name。</p>

<p>目前，只有这种写法可行，因为es6明确规定，Class内部只有静态方法，没有静态属性 ，现在有一个提案提供了类的静态属性，写法是在实例属性法的前面，加上static关键字。</p>
<pre><code>class Obj {
    static name = 'tx';
}
</code></pre>
<p>这个新写法大大方便了静态属性的表达。（貌似提案已经通过了，上面那种写法测试也是可以的）。</p>
<h3 id="五私有方法和私有属性">五、私有方法和私有属性</h3>

<h4 id="现有的解决方法">现有的解决方法</h4>

<h5 id="1命名前加_">（1）命名前加_</h5>
<h5 id="2利用symbol值的唯一性将私有方法的名字命名为一个symbol值">（2）利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。</h5>

<p>现有的提案是：为class加了私有属性。方法是在属性名之前，使用#表示。</p>

<h3 id="六newtarget属性">六、new.target属性</h3>
<p>new是从构造函数生成实例对象的命令。es6为new命令引入了一个new.target属性，该属性一般用在构造函数中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令或Reflect.construct()调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。</p>
<pre><code>function Person(name){
    if(new.target != undefined){
        this.name = name;
    }else{
        throw new Error('必须使用new命令生成实例');
    }
}
//另一种写法
function Person(name){
    if(new.target === Person){
        this.name = name;
    }else{
        throw new Error('必须使用new命令生成实例');
    }
}
var person = new Person('tx');
var notAPerson = Person.call(person, 'tx');  // 报错
</code></pre>
<p>上面代码确保构造函数只能通过new命令调用。</p>

<p>Class内部调用new.target，返回当前Class。</p>
<pre><code>class Obj {
    constructor(name,age){
        console.log(new.target === Obj)
        this.name = name;
        this.age = age;
    }
}
var obj = new Obj('tx',24); //true
</code></pre>
<p>需要注意的是，子类继承父类时，new.taget会返回子类。</p>
<pre><code>class Parentclass {
    constructor(name,age){
        console.log(new.target === Parentclass);
    }
}
class childrenclass extends Parentclass{
    constructor(name){
        super(name);
    }
}
var obj = new childrenclass('tx');  //false
</code></pre>
<p>利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。</p>
<pre><code>lass Shape {
  constructor() {
    if (new.target === Shape) {
      throw new Error('本类不能实例化');
    }
  }
}

class Rectangle extends Shape {
  constructor(length, width) {
    super();
    // ...
  }
}

var x = new Shape();  // 报错
var y = new Rectangle(3, 4);  // 正确
</code></pre>
<p>上面代码中，Shape类不能被实例化，只能用于继承。</p>

<p>注意：在函数外部，使用new.target会报错。</p>


   
            </div>
            
          </div>
          
                <div class="next_page_box">
                  <div class="read_next">阅读下一篇文章</div>
                  <div class="next_page">
                    <a class="" href="http://localhost:4000/tec/2019/06/27/Iterator-%E5%92%8C-for...of-%E5%BE%AA%E7%8E%AF.html" data-post-href="http://localhost:4000/tec/2019/06/27/Iterator-%E5%92%8C-for...of-%E5%BE%AA%E7%8E%AF.html">
                      <h4>Iterator 和 for...of 循环</h4>
                      <div></div>
                    </a>
                  </div>
                </div>
          
          <div class="phone_bottom">
              <a class="" href="http://localhost:4000/tec/2019/07/05/Class%E7%9A%84%E7%BB%A7%E6%89%BF.html" data-post-href="http://localhost:4000/tec/2019/07/05/Class%E7%9A%84%E7%BB%A7%E6%89%BF.html">
              PREV
              </a>
              <a class="" href="http://localhost:4000/tec/2019/06/27/Iterator-%E5%92%8C-for...of-%E5%BE%AA%E7%8E%AF.html" data-post-href="http://localhost:4000/tec/2019/06/27/Iterator-%E5%92%8C-for...of-%E5%BE%AA%E7%8E%AF.html">
                NEXT
              </a>
          </div>
       </div>
    </div>
  </body>
<script src="/source/js/highlight.min.js"></script>
<script type="text/javascript" src="/source/js/jquery.js"></script>
<script type="text/javascript" src="/source/js/TweenMax.min.js"></script>
<script type="text/javascript" src="/source/js/DrawSVGPlugin.min.js"></script>
<script type="text/javascript" src="/source/js/tween.js"></script>
<script type="text/javascript" src="/source/js/animation.js"></script>
  <script type="text/javascript" src="/source/js/index.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
    $(document).ready(function(){
      //评论
        $('.comments').on('click',function(e){
          e.preventDefault();
          $('#lv-container').show();
        });
    })
  </script>
</html>