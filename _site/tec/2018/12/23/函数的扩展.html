<!DOCTYPE HTML>
<html>
<head>
  <meta charset="UTF-8">
    <link rel="stylesheet" href="/source/css/index.css" type="text/css">
    <link rel="stylesheet" href="/source/css/post_last.css" type="text/css">
    <link rel="stylesheet" href="/source/css/obsidian.min.css">
<!--     <link rel="stylesheet" type="text/css" href="/source/css/nav.css"> -->
    <link rel="stylesheet" type="text/css" href="/source/css/font-awesome-4.7.0/css/font-awesome.min.css">
    <link rel="icon" href="favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>摆渡先生</title>
   <!-- <link rel="stylesheet" href="/css/highlight.css" type="text/css">-->
</head>

 <body>
 <div class="nav_box" style="z-index: 10000">
<nav class="nav">
	<ul class="nav__list">
		<li class="nav__item">
			<a class="nav__link" href="/">
				<div class="nav__link-content">
					<span class="nav__link-num">01</span>
					<div class="nav__link-title">Works</div>
					<div class="nav__link-desc">What I'm made</div>
				</div>
				<div class="nav__link-base"></div>
			</a>
			<div class="nav__item-line"></div>
		</li>
		<li class="nav__item">
			<a class="nav__link" href="/new">
				<div class="nav__link-content">
					<span class="nav__link-num">02</span>
					<div class="nav__link-title">News</div>
					<div class="nav__link-desc">Latest ramblings</div>
				</div>
				<div class="nav__link-base"></div>
			</a>
			<div class="nav__item-line"></div>
		</li>
		<li class="nav__item">
			<a class="nav__link" href="/book">
				<div class="nav__link-content">
					<span class="nav__link-num">03</span>
					<div class="nav__link-title">Books</div>
					<div class="nav__link-desc">Many good books</div>
				</div>
				<div class="nav__link-base"></div>
			</a>
			<div class="nav__item-line"></div>
		</li>
		<li class="nav__item">
			<a class="nav__link" href="/contact">
				<div class="nav__link-content">
					<span class="nav__link-num">04</span>
					<div class="nav__link-title">Contact</div>
					<div class="nav__link-desc">Don't be shy</div>
				</div>
				<div class="nav__link-base"></div>
			</a>
			<div class="nav__item-line"></div>
		</li>
        <li class="phone_btn_close nav__item">
            x
        </li>
	</ul>
  <div class="header_logo">
    <svg version="1.1"  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
   viewBox="0 0 825 299" style="enable-background:new 0 0 825 299;" xml:space="preserve">
<g class="logo_baidu">
  <path class="st0 logo_baidu_letter" fill="#fff" d="M132.94,183.58c-5.84,0.73-10.94,1.46-15.31,2.19c-2.19,0.73-4.02,0-5.47-2.19c0-5.1,1.82-8.02,5.47-8.75
    c3.64,0.73,8.75,1.09,15.31,1.09c0-5.1-0.37-10.2-1.09-15.31c0-2.91,1.09-4.38,3.28-4.38c7.29,0.73,10.57,3.65,9.84,8.75
    c-0.73,2.92-1.09,6.56-1.09,10.94h8.75c2.91,0.73,4.38,2.19,4.38,4.38c-2.19,1.46-6.56,2.19-13.13,2.19v9.84
    c7.29-1.45,11.3-1.45,12.03,0c0.73,2.19-3.28,4.74-12.03,7.66c0,11.67,0.36,21.52,1.09,29.53c0.73,5.84-1.46,10.21-6.56,13.13
    c-4.38,2.19-10.94,1.83-19.69-1.09c-7.3-3.64-11.3-7.29-12.03-10.94c17.5,4.38,26.25,3.65,26.25-2.19c0.73-9.48,0.73-17.86,0-25.16
    c-8.75,2.92-14.95,4.74-18.59,5.47c-2.92,0-4.74-1.45-5.47-4.38c-0.73-3.64,0.73-5.83,4.38-6.56c5.1-0.73,11.66-1.82,19.69-3.28
    V183.58z M217.16,162.8c3.64,0.73,5.47,3.28,5.47,7.66c-1.46,5.84-2.19,11.67-2.19,17.5c-0.73,3.65-2.92,5.11-6.56,4.38
    c-6.56-1.45-12.77-2.19-18.59-2.19c-0.73,2.19-0.73,4.38,0,6.56h14.22c3.64,0,5.83,0.73,6.56,2.19c0.73,2.92-1.09,4.38-5.47,4.38
    h-15.31c-0.73,2.19-0.73,4.38,0,6.56c15.31,0.73,28.8,0.73,40.47,0c-5.11,10.94-12.4,14.22-21.88,9.84
    c-6.56-2.19-13.13-3.28-19.69-3.28l-5.47,6.56c-2.92,2.92-5.11,5.47-6.56,7.66c3.64,2.92,7.66,4.02,12.03,3.28
    c5.1-1.45,8.38-3.28,9.84-5.47c-1.46-0.73-3.28-1.82-5.47-3.28c0.73-3.64,2.55-5.47,5.47-5.47c2.91-0.73,6.2,0.73,9.84,4.38
    c5.1,4.38,8.75,8.39,10.94,12.03c2.19,4.38,0.73,5.84-4.38,4.38c-3.65-2.91-7.66-5.83-12.03-8.75c-5.11,7.3-11.3,10.58-18.59,9.84
    c-8.02-3.64-13.13-5.1-15.31-4.38c-2.92,0.73-5.84,1.83-8.75,3.28c-2.92,0.73-5.11-0.36-6.56-3.28c-0.73-2.19,0-4.01,2.19-5.47
    c2.91-2.19,5.83-4.01,8.75-5.47c6.56-3.64,10.57-6.92,12.03-9.84c-14.59,0.73-24.06,1.83-28.44,3.28
    c-3.65,0.73-5.11-0.73-4.38-4.38c1.45-3.64,3.28-5.83,5.47-6.56c6.56,1.46,15.67,1.83,27.34,1.09c0.73-2.19,0.73-4.38,0-6.56
    c-7.3,0-13.49,0.37-18.59,1.09c-3.65,0.73-4.74-1.09-3.28-5.47c1.45-1.45,3.64-2.55,6.56-3.28c5.1,0.73,10.2,1.09,15.31,1.09
    c0.73-2.19,0.73-4.38,0-6.56c-6.56,0-11.67,0.73-15.31,2.19c-3.65,1.46-5.84,0.37-6.56-3.28c-0.73-8.75-1.46-15.67-2.19-20.78
    c0-4.38,2.55-6.2,7.66-5.47C181.8,164.99,198.93,164.99,217.16,162.8z M167.94,170.46c-0.73,2.92-0.73,7.3,0,13.13
    c3.64,1.46,6.56,1.46,8.75,0c0.73-4.38,0.73-8.75,0-13.13C174.51,169.73,171.58,169.73,167.94,170.46z M184.35,183.58
    c3.64,0.73,6.56,0.73,8.75,0c0.73-5.1,0.73-9.48,0-13.13c-2.92-0.73-5.84-0.73-8.75,0C183.62,175.57,183.62,179.94,184.35,183.58z
     M200.76,170.46c-0.73,3.65-0.73,8.02,0,13.13c4.38,1.46,7.66,1.46,9.84,0c2.19-3.64,2.55-8.02,1.09-13.13
    C208.05,169.73,204.4,169.73,200.76,170.46z"/>
  <path class="st0 logo_baidu_letter" fill="#fff" d="M255.44,189.05c8.75,2.92,17.5,5.11,26.25,6.56c1.45,0.73,1.45,1.83,0,3.28c-5.84,2.19-11.3,3.28-16.41,3.28
    c-7.3,0.73-13.13,0-17.5-2.19c-2.92-2.19-2.92-5.1,0-8.75C249.98,189.05,252.52,188.33,255.44,189.05z M255.44,216.4
    c8.75-1.45,17.5-4.01,26.25-7.66c1.45-0.73,2.55-0.73,3.28,0c-2.19,4.38-5.11,8.02-8.75,10.94c-4.38,3.65-10.94,6.93-19.69,9.84
    c-2.92,0-5.11-1.82-6.56-5.47C249.24,219.68,251.07,217.13,255.44,216.4z M262.01,166.08c7.29,5.11,14.95,9.48,22.97,13.13
    c-0.73,1.46-4.38,2.19-10.94,2.19s-12.77-1.45-18.59-4.38c-2.19-1.45-2.92-3.28-2.19-5.47
    C254.71,167.18,257.63,165.36,262.01,166.08z M313.41,186.87c-4.38-0.73-8.39-0.36-12.03,1.09c0,5.84-0.73,13.13-2.19,21.88
    c-0.73,4.38-2.19,8.39-4.38,12.03c-2.19,3.65-4.38,6.56-6.56,8.75c-5.11,4.38-9.48,6.93-13.13,7.66c-2.92,0-5.47-0.36-7.66-1.09
    c-1.46-1.45-2.55-2.55-3.28-3.28c2.91-2.19,6.2-4.01,9.84-5.47c3.64-2.19,6.92-5.1,9.84-8.75c2.19-3.64,4.01-7.29,5.47-10.94
    c1.45-5.83,2.19-11.3,2.19-16.41c0.73-8.75-0.37-16.04-3.28-21.88c0-4.38,2.19-6.56,6.56-6.56c4.38,1.46,12.39,2.19,24.06,2.19
    v-6.56c1.45-2.91,4.38-4.01,8.75-3.28c2.19,0.73,4.01,1.83,5.47,3.28v6.56h20.78c6.56,0,9.84,1.46,9.84,4.38
    c-1.46,1.46-7.66,2.19-18.59,2.19c-1.46,2.92-1.46,5.47,0,7.66h8.75c5.83,0,8.75,1.09,8.75,3.28s-1.09,3.28-3.28,3.28h-14.22
    c-0.73,3.65-0.73,6.93,0,9.84c0.73,3.65-1.09,5.11-5.47,4.38c-2.92-1.45-5.84-2.55-8.75-3.28c-2.19,0-4.38,0-6.56,0
    c-2.19,0.73-4.02,1.46-5.47,2.19c-3.65,0.73-5.47-0.36-5.47-3.28C314.14,192.33,314.14,189.05,313.41,186.87z M314.51,202.18
    c2.19,0.73,4.38,1.09,6.56,1.09c7.29-0.73,14.95-0.36,22.97,1.09c5.1,1.46,6.92,4.02,5.47,7.66c-2.19,2.92-5.11,6.93-8.75,12.03
    c16.04,5.11,28.07,7.66,36.09,7.66c-7.3,10.94-14.59,14.58-21.88,10.94c-6.56-4.38-13.49-8.75-20.78-13.13
    c-9.48,5.11-17.87,8.75-25.16,10.94c-6.56,1.46-10.58-0.73-12.03-6.56c0.73-0.73,4.73-1.82,12.03-3.28
    c8.02-1.45,14.22-3.64,18.59-6.56c-4.38-2.91-8.39-5.47-12.03-7.66c0-3.64,1.82-5.1,5.47-4.38c3.64,2.19,7.66,4.74,12.03,7.66
    c2.91-2.19,4.73-4.73,5.47-7.66c0.73-2.19-0.73-3.28-4.38-3.28c-6.56,0-12.77,0.37-18.59,1.09c-3.65,2.19-5.84,2.19-6.56,0
    C309.76,205.46,311.58,202.91,314.51,202.18z M313.41,172.65c-3.65-0.73-8.02-0.73-13.13,0c-0.73,2.92-0.73,5.47,0,7.66
    c4.38,0.73,8.75,0.73,13.13,0C314.14,177.39,314.14,174.83,313.41,172.65z M322.16,172.65c-0.73,2.92-0.73,5.47,0,7.66
    c5.1,0.73,9.48,0.73,13.13,0c0.73-2.91,0.73-5.47,0-7.66C330.91,171.92,326.54,171.92,322.16,172.65z M336.38,186.87
    c-4.38-0.73-9.12-0.73-14.22,0c0,1.46,0,3.28,0,5.47c4.38,0.73,8.38,0.73,12.03,0C336.38,192.33,337.11,190.51,336.38,186.87z"/>
</g>
<polyline class="st1 logo_baidu_border" points="409.5,179.35 409.5,261 81.5,261 81.5,140 367.18,140 " fill="none" stroke="#fff" stroke-miterlimit="10" stroke-width="16"/>
<g class="logo__plus" fill="none" stroke="#fff" stroke-miterlimit="10" stroke-width="16">
  <line class="st1 logo__plus-horz" x1="382.5" y1="140.5" x2="436.5" y2="140.5"/>
  <!-- <path class="st1" d="M411.5,117.5"/> -->
  <line class="st1 logo__plus-vert" x1="409.5" y1="167.5" x2="409.5" y2="113.5"/>
</g>
<g class="logo__xiansheng">
  <path class="st2 logo_xiansheng_letter" fill="#fff" d="M484.78,60.65c-5.11,3.65-9.12,5.47-12.03,5.47c-4.38,0-5.47-1.09-3.28-3.28c5.1-2.91,8.75-8.02,10.94-15.31
    c1.45-6.56,3.64-9.48,6.56-8.75c2.91,0,4.73,1.46,5.47,4.38c0,3.65-1.09,6.56-3.28,8.75h16.41V39.87c0-4.38,1.82-6.92,5.47-7.66
    c6.56,0,9.84,2.92,9.84,8.75V51.9h25.16c4.38,0,6.2,1.83,5.47,5.47c-0.73,2.19-2.19,3.28-4.38,3.28h-26.25v8.75
    c10.94,0,22.6,0.37,35,1.09c2.91,0,4.73,1.09,5.47,3.28c0.73,4.38-1.83,6.56-7.66,6.56c-10.21-0.73-19.69-1.09-28.44-1.09v10.94
    c0,8.02,6.56,12.03,19.69,12.03c14.58,0.73,26.25-1.45,35-6.56c-2.92,10.94-6.2,17.5-9.84,19.69c-7.3,5.11-17.87,5.84-31.72,2.19
    c-5.11-1.45-9.48-3.28-13.13-5.47c-7.3-4.38-11.3-10.57-12.03-18.59V79.24h-6.56c-0.73,4.38-2.55,9.48-5.47,15.31
    c-6.56,9.48-14.22,16.05-22.97,19.69c-7.3,2.92-14.59,3.65-21.88,2.19c-6.56-2.91-8.75-5.83-6.56-8.75
    c24.79-0.73,40.1-10.2,45.94-28.44c-5.84-0.73-13.49,0-22.97,2.19c-7.3,2.19-10.58,0.73-9.84-4.38c3.64-5.83,6.92-8.38,9.84-7.66
    c8.02,1.46,18.95,1.46,32.81,0v-8.75H484.78z"/>

  <path class="st3 logo_xiansheng_letter" fill="#fff" d="M645.29,63.43c-6.56-0.73-14.22-0.73-22.97,0c-2.92,3.65-7.3,6.93-13.13,9.84c-2.92,0.73-4.02,0-3.28-2.19
    c5.83-6.56,9.84-13.48,12.03-20.78c2.19-8.75,6.2-12.03,12.03-9.84c4.38,2.92,3.64,8.02-2.19,15.31h17.5
    c0.73-6.56,0.73-12.39,0-17.5c0-4.38,2.19-6.92,6.56-7.66c5.83,0,8.75,2.55,8.75,7.66c0,8.75,0.36,14.59,1.09,17.5h22.97
    c8.02-0.73,12.03,0.73,12.03,4.38c2.19,3.65-9.48,4.74-35,3.28c-1.46,3.65-1.46,7.3,0,10.94l21.88,1.09c2.91,0,6.2,0.73,9.84,2.19
    c1.45,2.92,1.09,4.74-1.09,5.47c-8.75-0.73-18.23-0.73-28.44,0c-2.19,0-3.28,3.65-3.28,10.94c0.73,6.56,16.04,8.02,45.94,4.38
    c3.64,0,8.02-0.73,13.13-2.19c-3.65,16.77-12.03,22.97-25.16,18.59c-22.61-8.02-48.13-10.2-76.56-6.56
    c-10.94,2.19-17.87,3.65-20.78,4.38c-5.84,1.46-8.02-0.36-6.56-5.47c2.91-5.83,6.92-9.48,12.03-10.94
    c2.91-0.73,7.29-0.36,13.13,1.09c18.95,2.19,28.8,1.46,29.53-2.19c1.45-8.02,0-12.03-4.38-12.03c-7.3-0.73-14.22,0-20.78,2.19
    c-4.38,1.46-5.84-0.36-4.38-5.47c0.73-2.19,2.91-4.38,6.56-6.56c2.91-1.45,5.83-1.09,8.75,1.09c5.83,0.73,10.2,0.73,13.13,0
    C646.38,72.91,646.74,69.27,645.29,63.43z"/>
</g>
<polyline class="st1 logo_xiansheng_border" points="409.5,101.65 409.5,20 737.5,20 737.5,141 451.82,141 " fill="none" stroke="#fff" stroke-miterlimit="10" stroke-width="16"/>
</svg>
  </div>
</nav>
<svg class="nav__bg" width="100%" height="100%" viewBox="0 0 100 100" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg">
    <defs>
        <linearGradient class="nav__grad" x1="92.6356902%" y1="7.36430977%" x2="0%" y2="100%" id="nav-grad">
            <!-- <stop stop-color="#000000" offset="20%"></stop>
            <stop stop-color="#223e36" offset="100%"></stop> -->
            <!-- <stop stop-color="#43C6AC" offset="20%"></stop>
            <stop stop-color="#191654" offset="100%"></stop> -->
            <stop stop-color="#00dbde" offset="20%"></stop>
            <stop stop-color="#fc00ff" offset="100%"></stop>
        </linearGradient>
		<mask id="nav__bg-mask" class="nav__bg-mask" maskUnits="userSpaceOnUse"x="0" y="0" width="100" height="100">
		  	<rect class="nav__bg-mask-rect" x="0" y="0" width="25" height="100" fill="white"/>
			<rect class="nav__bg-mask-rect" x="24.9" y="0" width="25.1" height="100" fill="white"/>
			<rect class="nav__bg-mask-rect" x="49.9" y="0" width="25.1" height="100" fill="white"/>
			<rect class="nav__bg-mask-rect" x="74.9" y="0" width="25.1" height="100" fill="white"/>
		</mask>
    </defs>
    <rect x="0" y="0" width="100" height="100" fill="url(#nav-grad)" mask="url(#nav__bg-mask)"></rect>
</svg>
<button class="nav-btn">
	<svg class="burger <?php echo $darkBurgerClass; ?>" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 36 36">
	<rect class="burger__stroke"  x="2" y="2" width="32" height="32" fill="none" stroke="" stroke-miterlimit="10" stroke-width="4"/>
	<polyline class="burger__stroke-over"points="18 2 34 2 34 34 2 34 2 2 18 2" fill="none" stroke="" stroke-miterlimit="10" stroke-width="4"/>
	<g class="burger__plus">
		<rect class="burger__plus-left" x="8" y="16" width="10" height="4"/>
		<rect class="burger__plus-btm" x="16" y="18" width="4" height="10"/>
		<rect class="burger__plus-right" x="18" y="16" width="10" height="4"/>
		<rect class="burger__plus-top" x="16" y="8" width="4" height="10"/>
	</g>
	</svg>
</button>
   <!--phone_menu-->  
<button class="nav_btn_phone">
  <svg version="1.1" id="" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
     viewBox="0 0 213 200" style="enable-background:new 0 0 213 200;" xml:space="preserve">
  <g>
    <line class="svg_menu_phone" x1="33" y1="58" x2="177" y2="58"/>
    <line class="svg_menu_phone" x1="33" y1="100" x2="177" y2="100"/>
    <line class="svg_menu_phone" x1="33" y1="142" x2="177" y2="142"/>
  </g>
  </svg>
</button>
</div>

   <div class="content_container">
      <div class="common_box">
        <div class="slide_img" id="slide_img_1"><div class="slide_img_shade"></div></div>
        <div class="title_box">
          <h2 class="main_title"><span>WORKS</span></h2>
        </div> 
      </div>
      <div class="content_box">
          <div class="content_content" >
            <div class="post_content">
                <div class="content_title">
                  <h1>ES6基础-函数的扩展</h1><span id="busuanzi_container_page_pv">
                  <span><time datetime=""></time></span>
                </div>
                  <h3 id="一函数参数的默认值">一、函数参数的默认值</h3>
<h4 id="基本用法">基本用法</h4>
<p>ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function log(x,y){
  y = y || 'world';
  console.log(x,y);
}
log() //undefined world
log('Hello') // Hello world
log('Hello', 'abc') // Hello abc
log('Hello', '') // Hello world
</code></pre>
</div>
<p>上面代码检查函数的参数y有没有赋值，如果没有，则指定默认值为world。这种写法的缺点是：如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用，log(‘Hello’,’‘)中y传入空字符串，结果被改为默认值。</p>

<p>为了避免这个问题，通常需要先判断一下参数y是否被赋值，如果没有，再等于默认值。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function log(x,y){
  if (typeof y === 'undefined') {
  y = 'World';
 }
  console.log(x,y);
}
log('hello');                //hello world
log('hello' , '');           //hello
log('hello' , 'abc');        //hello abc
log('hello' , undefined);    //hello world
log('hello' , 'undefined');  //hello undefined
</code></pre>
</div>
<p>ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function log(x,y = 'world'){
  console.log(x,y);
}
log();                       //undefined "world"
log('hello');                //hello world
log('hello' , '');           //hello
log('hello' , 'abc');        //hello abc
log('hello' , undefined);    //hello world
log('hello' , 'undefined');  //hello undefined
</code></pre>
</div>
<p>ES6的写法比ES5简单很多。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(x = 0,y = 0){
	this.x = x;
	this.y = y;
}
const abc = new func();
console.log(abc);
</code></pre>
</div>
<p>除了写法简洁明了之外，ES6的写法还有两个好处：1.阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体 2. 有利于将来的代码优化，即使代码在未来彻底拿掉这个参数，也不会导致以前的代码无法运行。
【】最后一句啥意思 ? 是执行的时候拿掉参数 ？，声明的时候拿掉参数代码还能运行么？</p>

<p>参数变量默认是声明的，所以不能用let或者const再次声明。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(x = 0){
	let x = 1; //报错
}
func();
</code></pre>
</div>
<p>使用参数默认值时，函数不能有同名参数。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>//不报错
function func(x ,x, y){

}
//报错
function func(x,x,y=1){

}
</code></pre>
</div>
<p>注意：参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let a = 1;
function func(x = a + 1){
	console.log(x);
}
func(); //2
a = 2;
func(); //3
</code></pre>
</div>
<p>上面代码中，函数func的参数x的默认值是a + 1，每次执行都会重新计算a + 1的值，而不是一直等于第一次的结果。</p>

<h4 id="与解构赋值默认值结合使用">与解构赋值默认值结合使用</h4>
<p>参数默认值可以与解构赋值的默认值结合起来使用。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func({x,y=1}){
	console.log(x,y);
}
func({x:1,y:2}); //1,2
func({x:1}); 	 //1,1
func({y:2});     //undefined,2
func({});        //undefined,1
func();          //报错 Cannot destructure property `x` of 'undefined' or 'null'.
</code></pre>
</div>
<p>上面代码给对象的解构赋值设置了默认值值，并没有给函数参数本身设置默认值，只有当函数的参数是一个对象时，变量x和y才会通过解构赋值生成，如果调用函数时没有传递任何参数，不能通过解构赋值生成变量x和y，导致函数出错。知道了这个原因，如果给函数的参数设置一个默认值，就可以避免这种情况。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func({x,y=1} = {}){
	console.log(x,y);
}
func(); //undefined，1
</code></pre>
</div>
<p>上面代码中，如果没有传递参数，默认值为一个空对象。</p>

<p>下面是一个解构赋值默认值的例子。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(url,{a,b ='abc',c}){
	console.log(b);
}
func('https://xxxx',{});  //abc
func('https://xxxx');  //报错
</code></pre>
</div>
<p>上面代码中，函数func的第二个参数是一个对象，可以给这个对象的三个属性设置默认值，这种写法不能省略第二个参数，这时如果给这个对象（函数的第二个参数）一个参数默认值，就可以省略第二个参数。这时，就有了双重默认值。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(url,{a,b ='abc',c} = {}){
	console.log(b);
}
func('https://xxxx',{}); //abc
func('https://xxxx');    //abc
</code></pre>
</div>
<p>上面代码中，函数没有传入第二个参数时，函数参数的默认值开始生效，然后是解构赋值的默认值生效，变量b才会取到默认值。</p>

<p>下面两种写法有什么区别？</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func({a=1,b=2} = {}){
	console.log(a,b);
}          

function func1({a,b} = {a:1,b:2}){
	console.log(a,b);
}
</code></pre>
</div>
<p>上面两种写法 第一种写法是设置了函数的参数的默认值为一个空对象，但是设置了对象解构赋值的默认值，第二种写法是设置了函数参数的默认值为一个有属性和值的对象，但是没有设置对象解构赋值的默认值。这两种写法的函数传参运行情况如下。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>//都不传入参数
func();  		 //1,2
func1(); 		 //1,2
//都传入参数
func({a:3,b:4}); //3,4
func1({a:3,b:4});//3,4
//只传入a参数
func({a:5});     //5,2
func1({a:5});    //5,undefined
//传入空对象
func({});        //1,2
func1({});       //undefined,undefined
//传入错误参数
func({a:6,c:7}); //6,2
func1({a:6,c:6});//6,undefined
</code></pre>
</div>
<h4 id="参数默认值的位置">参数默认值的位置</h4>
<p>通常情况下，设置了默认值的参数，应该放在参数额最后，这样比较容易看出来省略了哪些参数。如果不是尾部的参数设置了默认值，实际上这个参数是没法省略的。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(a,b=2,c){
	console.log(a,b,c);
}
func();              //undefined,undefined
func(1);			 //1,2,undefined
func(1,2);           //1,2,undefined
func(1,,3);          //报错
func(1,2,3);         //1,2,3
func(1,undefined,3); //1,2,3
</code></pre>
</div>
<p>上面的函数有默认值的参数是第二个，所以没法只省略第二个参数，而不省略其他参数，除非传入undefined。</p>

<p>如果传入undefined，该参数将等于默认值，null则不是这样。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(a,b=2,c){
	console.log(a,b,c);
}
func(1,null,3); //1,null,3
</code></pre>
</div>
<h4 id="函数的length属性">函数的length属性</h4>
<p>函数的length属性，将返回没有制定默认值的参数个数，所以函数参数设置了默认值后，函数的length属性将不准确。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var func  = function (a,b,c=3){
};
console.log(func.length); //2
</code></pre>
</div>
<p>上面的函数中，末位参数设置了默认值，所以函数的length返回了2（3-1），之所以这样是因为length的含义是：该函数预期传入的参数个数，某个参数制定默认值之后，预期传入的参数就不包括这个参数了 。 同理， 后文的rest参数也不会计入length。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>(function(...args) {}).length // 0
</code></pre>
</div>
<p>【】直接复制</p>

<p>如果设置了默认值的的参数不是尾参数，那么这个参数和之后的参数都不计入length。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var func  = function (a,b=2,c){
};
console.log(func.length);//1
</code></pre>
</div>
<h4 id="作用域">作用域</h4>
<p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域。等到初始化结束，这个作用域会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let x = 1;
function func(x , y = x){
	console.log(y);
}
func(2);//2
</code></pre>
</div>
<p>上面代码中，参数y的默认值是x，调用函数func时，参数会形成一个单独的作用域。在这个作用域里面，默认值变量等于第一个参数x，而不是全局的x，所以输出是2。</p>

<p>再看下面的例子：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let x = 1;
function func(y = x){
	let x = 2;
	console.log(y);
}
func();//1
</code></pre>
</div>
<p>上面的代码中，函数func调用时，参数y=x形成一个单独的作用域。在这个作用域里面，变量x本身没有定义，所以向外寻找全局的变量x。函数调用时，函数体内部的变量x不影响默认值变量x。</p>

<p>如果此时，全局变量x不存在，就会报错。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(y = x){
	let x = 2;
	console.log(y);
}
func();//x is not defined
</code></pre>
</div>
<p>下面这样写，也会报错。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let x = 1;
function func(x = x){
	console.log(x);
}
func();//x is not defined
</code></pre>
</div>
<p>上面代码中，参数x = x形成一个单独的作用域。实际执行的是let x = x，这行代码会报错。</p>

<p>如果参数的默认值是一个函数的，该函数的作用域也遵守这个规则。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let foo = 'tx';
function bar(func = () =&gt;foo){
	let foo = '123';
	console.log(func());
}
bar();//tx
</code></pre>
</div>
<p>上面的代码中，函数bar的参数func的默认值是一个匿名函数，返回值为变量foo。函数参数形成的单独作用域里面，并没有定义变量foo，所以向外（全局）寻找变量foo，因此输出tx。</p>

<p>下面这样写，会报错。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function bar(func = () =&gt;foo){
	let foo = '123';
	console.log(func());
}
bar(); //报错
</code></pre>
</div>
<p>由于函数参数的单独作用域中没有foo变量，向外寻找的时候全局也没有foo变量，所以报错了。</p>

<p>下面是另一个例子：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var x = 1;
function func(x,y = function(){ x = 2;}){
	var x = 3;
	y();
	console.log(x);
}
func();        //3
console.log(x) //1
</code></pre>
</div>
<p>上面代码中，函数func的参数形成了单独的作用域，这个作用域里面，参数y的默认值是一个匿名函数。这个函数的内部变量x，指向同一个作用域中第一个参数x。函数func内部又声明了一个变量x，该变量跟参数x不在同一个作用域，所以不是同一个变量，所以执行y后函数内部的变量x和全局变量x都没有改变。</p>

<p>如果将函数内部的变量x前面的var去掉，函数内部的变量x就指向第一个参数x，与匿名函数的内部是一致的，所以最后输出的就是2，而外层的全局变量x不受影响。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var x = 1;
function func(x,y = function(){ x = 2;}){
	x = 3;
	y();
	console.log(x);
}
func();        //3
console.log(x) //1
</code></pre>
</div>
<h4 id="应用">应用</h4>
<p>利用默认值参数，可以指定某一个参数不得省略，如果省略就抛出一个错误。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function throwIfMissing(){
	throw new Error('Missing');
}
function func(x = throwIfMissing()){
	return x;
}
func(); //Error:Missing
</code></pre>
</div>
<p>上面的函数func参数x的默认值是一个抛出错误的函数，如果这个函数函数调用的时候没有传入参数，就会触发这个默认值函数，从而抛出一个错误。</p>

<p>从上面的函数还可以看到，参数x的默认值等于throwIfMissing函数的运行结果（注意函数名throwIfMissing之后有一对圆括号），这表情参数的默认值不是在定义时执行，而是在运行时执行，如果参数已经传入，那么默认值将不会执行。</p>

<p>可以将参数默认值设置为undefined，这表明这个参数是可以省略的。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(x = undefined){
	console.log(x);
}
func();//undefined
</code></pre>
</div>
<h3 id="二rest参数">二、rest参数</h3>
<p>ES6引入rest参数(形式为…变量名)，用于获取函数的多余参数，这样就不用使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function add(...values){
	let sum = 0;
	for(let val of values){
		sum += val;
	}
	console.log(sum);
}
add(1,2,3);//6
</code></pre>
</div>
<p>上面的函数是一个求和函数，利用rest参数，可以向函数中传入任意数量的参数。</p>

<p>下面是一个rest参数代替arguments变量的例子。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>//Array.prototype.slice.call将一个具有length属性的对象转化为数组。
function es5sortNumber(){
	console.log(Array.prototype.slice.call(arguments).sort());
}

function es6sortNumber(...numbers){
	console.log(numbers.sort());
}
es5sortNumber(5,3,4,1); //[1, 3, 4, 5]
es6sortNumber(5,3,4,1); //[1, 3, 4, 5]
</code></pre>
</div>
<p>上面的两种写法，明显看出ES6的写法更加简洁。</p>

<p>arguments不是一个数组，而是一个具有length属性的对象。所以为了使用数组方法，必须使用Array.prototype.slice.call将其转为数组。rest参数就不存在这个问题，它本身就是一个纯数组，数组上的方法都可以使用。下面是一个利用rest参数改写数组push方法的例子。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function push(array,...items){
	items.forEach(function(item){
		array.push(item);
		console.log(item);
	})
}
var a = [];
push(a,1,2,3,4);
console.log(a) //[1, 2, 3, 4]
</code></pre>
</div>
<p>注意：rest参数之后不能再有其他参数(只能是最后一个参数)，否则会报错。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(...values,y){} //报错
</code></pre>
</div>
<p>函数的length属性，不包括rest参数。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(x,...values){};
console.log(func.length); //1
</code></pre>
</div>
<h3 id="严格模式">严格模式</h3>
<p>从ES5开始，函数内部可以设定为严格模式。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(x,y){
	'use strict'
}
</code></pre>
</div>
<p>ES6做了一点修改，规定只要函数设定了默认值、解构赋值、扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(x,y=2){
	'use strict'
}

var func =  function(x,y=1){
	'use strict'
};

function func({x,y}){
	'use strict';
}

function func(...values){
	'use strict';
}
//以上都报错
</code></pre>
</div>
<p>这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是函数执行的时候，先执行函数参数，然后再执行函数体。这样就冲突了，只有从函数体内，才能知道函数参数是否应该以严格模式执行，但是函数参数先于函数体执行。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>//报错
function func(x = 070){
	'use strict'
	console.log(x);
}
</code></pre>
</div>
<p>上面代码中，函数的参数x的默认值是八进制数070，但是严格模式下不能用前缀0表示八进制，所以应该报错。但是实际上，js引擎会先成功执行x=070，然后执行函数体内部，发现需要用严格模式执行，这时才会报错。</p>

<p>虽然可以先解析函数体代码，再执行参数代码，但是这样无疑增加了复杂性。因此，标准干脆禁止了这种用法，只要参数使用了默认值、解构赋值、扩展运算符就不能显式指定严格模式。</p>

<p>两种方法可以规避这种限制。</p>

<p>第一种：设定全局性的严格模式。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>'use strict'
function func(x = 1){
	console.log(x);
}
</code></pre>
</div>
<p>第二种：把函数包在一个无参数的立即执行函数里面</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var func = (function(){
	'use strict';
	return function (x = 1){
		console.log(x);
	}
})();
func();//1
</code></pre>
</div>
<h3 id="name属性">name属性</h3>
<p>函数的name属性，返回该函数的函数名。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(){}
console.log(func.name);
</code></pre>
</div>
<p>这个属性早就支持，到ES6才写入标准。</p>

<p>ES6对这个属性做出了一点修改，如果将一个匿名函数赋值给一个变量，ES5的name属性会返回空字符串，ES6会返回实际的函数名。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>//es5
var func = function(){}
console.log(func.name); //空字符串
//es6
var func = function(){}
console.log(func.name);//func
</code></pre>
</div>
<p>如果将一个具体名字的函数赋值给一个变量，es5和es6的name属性都会返回这个函数原本的名字。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>//es5
var func = function foo(){}
console.log(func.name); //foo
//es6
var func = function foo(){}
console.log(func.name); //foo
</code></pre>
</div>
<p>Function构造函数返回的函数实例，name属性的值为anonymous。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var func = new Function();
console.log(func.name);//anonymous
</code></pre>
</div>
<p>bind返回的函数，name属性返回会加上bound前缀。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var func = new Function();
func.bind({}).name; //bound anonymous

function func(){};
console.log(func.bind({}).name);//bound func

(function(){}).bind({}).name // "bound "
</code></pre>
</div>
<h3 id="箭头函数">箭头函数</h3>
<p>ES6允许使用箭头(=&gt;)定义函数。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let func = x =&gt; x;
//等同于
let func2 = function(x){
	return x;
};
</code></pre>
</div>
<p>如果箭头函数不需要参数或者需要多个参数，就使用一个圆括号代表参数部分。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let func = () =&gt; 5;
func();//5
//相当于
let func = function(){
	return 5
};

let func2 = (x,y) =&gt; x+y;
func2(1,2);//3
//相当于
let func2 = function(x,y){
	return x+y;
};
</code></pre>
</div>
<p>如果箭头函数的函数体内部多余一条语句，就要使用大括号给他们括起来，并且使用return 语句返回。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let func = (x,y) =&gt;{return x+y;}
func(1,2);//3
</code></pre>
</div>
<p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号(),否则会报错。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let  func = (id) =&gt; {id:id,name:'tx'}; //报错
let  func = (id) =&gt; {id:id}; //不报错，但是执行函数后返回的是undefined
let  func = (id) =&gt; ({id:id,name:'tx'}); //{id: 1, name: "tx"}
</code></pre>
</div>
<p>这个试过之后，好像对象如果只有一个属性就不会报错，但是也不能返回正确的对象，返回的是undefined。</p>

<p>下面是另一种特殊情况，靠，貌似就是我上面的结论。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let func = () =&gt; {a:1};
func();//undefined
</code></pre>
</div>
<p>上面代码中，原意是返回一个对象{a:1}，但是由于引擎认为大括号是一个代码块，所以执行的语句是a:1。这时a可以被解释为语句的标签，因此实际执行的语句是1，然后函数就结束了，没有返回值。</p>

<p>如果箭头函数只有一行语句，且不需要返回值，语句就不用写大括号了。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let func = () =&gt; console.log('123');
</code></pre>
</div>
<p>箭头函数可以与变量解构一起使用。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var person = {
	name:'jl',
	age:29
};
let func = ({name,age}) =&gt; name + ':' + age ; 
func({name:'tx',age:25});//tx:25
func(person);//jl:29
//相当于
function func(person){
	return person.name + ':' + person.age;
}
</code></pre>
</div>
<p>箭头函数使得表达更加简洁。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let func = n =&gt; n % 2 ===0;
let func = n =&gt; n*n;
</code></pre>
</div>
<p>上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。</p>

<p>箭头函数的一个用处是简化回调函数。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>//正常函数
[1,2,3].map(function(n){
	return n * n ;
});

//箭头函数
[1,2,3].map(n =&gt; n * n);
</code></pre>
</div>
<p>另一个例子:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var values = [1,9,3,2,5];
//正常函数写法
var result = values.sort(function(a,b){
	return a-b;
});
console.log(result); //[1, 2, 3, 5, 9]
//箭头函数写法
var result2 = values.sort((a,b)=&gt;a-b);
console.log(result2); //[1, 2, 3, 5, 9]
</code></pre>
</div>
<p>rest参数与箭头函数结合的例子。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var func = (...values) =&gt; values;
func([1,2]);     //[1,2]
func({a:1,b:2}); //[{a:1,b:2}]

let func = (first,...second) =&gt; [first,second];
func(1,2,3,4);   //[1,[2,3,4]]
</code></pre>
</div>
<h4 id="使用注意点">使用注意点</h4>
<p>箭头函数有几个使用注意点。</p>

<p>（1）函数体内的this，就是定义时所在的对象，而不是使用时所在的对象。</p>

<p>（2）不可以当作构造函数，不能使用new命令，否则会报错。</p>

<p>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用rest参数代替。</p>

<p>（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。【】</p>

<p>第一点尤其需要注意，普通函数中this的指向是可变的，但是在箭头函数中，他是不变的。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>//不用箭头函数
function func2(){
	setTimeout(function(){
		console.log("id:" + this.id);
	},100)
}
var id = 1;
func2.call({id:2}); //id:1
//使用箭头函数
function func(){
	setTimeout(() =&gt; {
		console.log("id:" + this.id);
	},100)
}
var id = 1;
func.call({id:2}); //id:2
</code></pre>
</div>
<p>上面代码中，setTimeout的参数是一个箭头函数，这个箭头函数的定义生效是在func函数生成时，而他的真正执行要等到100毫秒之后。如果是普通函数，执行函数是this应该指向全局对象，这时应该输出1。但是箭头函数导致this总是指向函数定义生效时所在的对象(本例是:{id:2})，所以输出是2。【】</p>

<p>箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function Timer(){
	this.s1 = 0;
	this.s2 = 0;
	//箭头函数
	setInterval(()=&gt;this.s1++,1000);
	//普通函数
	setInterval(function(){
		this.s2 ++ ;
	},1000)
}
var timer = new Timer();
setTimeout(() =&gt; console.log(timer.s1),3500);
setTimeout(() =&gt; console.log(timer.s2),3500);
</code></pre>
</div>
<p>上面的函数Timer内部定义了两个定时器，分别使用了普通函数和箭头函数，普通函数的定时器this指向运行时的作用域（全局），箭头函数的this指向定义时所在的作用域（Timer函数），所以3500毫秒过后，timer.s1被更新了三次，而timer.s2一次都没更新。</p>

<p>箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM事件的回调函数封装在一个对象里。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var handler = {
	id :'123',
	init:function(){
		document.addEventListener('click',
	 	() =&gt; this.dosomething(event.type),false);
	},
	dosomething:function(type){
		console.log(this.id);
	}
};
handler.init();//123
</code></pre>
</div>
<p>上面对象handler的init函数中使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象。如果这里用普通函数，回到函数运行时，this.dosomething这一行会报错，因为此时this指向document。</p>

<p>this指向固定，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。也是由于本身没有this，所以也就不能用作构造函数。</p>

<p>所以，箭头函数转成普通函数的代码如下：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>//es6
function func(){
	setTimeout(() =&gt; {
		console.log(this.id); 
	},100);
}
//es5
function func2(){
	var _this = this;
	setTimeout(function(){
		console.log(_this.id);
	},100);
}
</code></pre>
</div>
<p>上面代码中，转换后的ES5版本清楚的说明了，箭头函数里根本没有自己的this，而是引用外层的this。</p>

<p>请问下面的代码中有几个this？</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(){
		return () =&gt; {
			return () =&gt; {
				return () =&gt; {
					console.log(this.id);
				};
			};
		};
}
var f = func.call({id:1});

var l = f.call({id:2})()();   //1
var l2 = f().call({id:3})();  //1
var l3 = f()().call({id:4});  //1
</code></pre>
</div>
<p>上面代码之中，只有一个this，就是函数func的this，所以l1,l2,l3输出的都是1。因为所有的内层函数都是箭头函数，都没有自己的this，他们的this都是最外层函数func的this。</p>

<p>除了this，以下三个变量在箭头函数中也是不存在的，都指向外层函数的对应变量。
arguments、super【】、newtarget【】。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(){
	setTimeout(()=&gt;{
		console.log(arguments);
	},100)
}
func(1,2,3); //[1,3,4]
</code></pre>
</div>
<p>上面的函数中，箭头函数的arguments变量就是外层函数func函数的arguments变量。</p>

<p>另外，由于箭头函数没有自己的this，所以也就不能使用call()、apply()、bind()这些方法去改变this的指向。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var id = '全局';
var func = () =&gt;{
	console.log(this.id);
};
var obj = {
	id:'obj对象'
};
func();           //全局
func.call(obj);   //全局
</code></pre>
</div>
<p>上面的代码中，func是箭头函数，由于没有自己的this，即使用call方法让她在obj对象中执行打印的依旧还是”全局”,call对箭头函数没有起作用。</p>

<p>长期以来，js语音的this对象一直是一个很蛋疼疼的问题，在封装的对象中使用this要非常小心。箭头函数的this固定，很大程度上解决了这个问题。</p>

<h4 id="不适用场合">不适用场合</h4>
<p>由于箭头函数没有自己this，不受调用的作用域不同而改变。所以下面两种情况，不应该使用箭头函数。</p>

<p>1.第一个不适合的场景是：定义对象上的方法，并且该方法内有this。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var obj = {
	id:1,
	func:() =&gt; {
	  this.id++;
	}
};
</code></pre>
</div>
<p>上面代码中，obj.func()方法是一个箭头函数，导致函数内部的this指向全局，如果是普通函数，这时的this就是指向obj对象，因此this.id++ 不会得到预期的结果。</p>

<p>2.第二个不适合的场景是：需要动态this的时候。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var btn = document.getElementById('btn');
btn.addEventListener('click', ()=&gt;{
	console.log(this);  //window
});
</code></pre>
</div>
<p>上面的代码中btn按钮的监听函数是一个箭头函数，导致里面的this已经固定了（window），而通常我们需要this指向监听的元素，所以这时需要写成普通函数。</p>

<p>另外，如果函数体很复杂，有许多行，后者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数，如果用普通函数，可以提高代码可读性。</p>

<h4 id="嵌套的箭头函数">嵌套的箭头函数</h4>
<p>【】</p>
<h3 id="六双冒号运算符">六、双冒号运算符</h3>
<p>箭头函数可以绑定this对象，大大减少了显示绑定this对象的写法(call、apply、bind)，但是，箭头函数并不适用于所有场合，所以现在有一个提案，提出了函数绑定运算符，用来取代call、apply、bind调用。</p>

<p>函数绑定运算符是并排的两个冒号(::)，双冒号左边是一个对象，右边是一个函数。该运算符会自动把左边的对象，上下文执行环境（即this对象）绑定到右边函数上。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>obj::func;
//等同于
func.bind(obj);

obj::func(...arguments);
//相当于
func.call(obj,arguments);
</code></pre>
</div>
<p>如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var method = obj::obj.getName;
//等同于
var method = ::obj.getName;

let log = ::console.log;
// 等同于
var log = console.log.bind(console);
</code></pre>
</div>
<p>如果双冒号运算符的运算结果，还是一个对象，就可以采用链式写法。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>import { map, takeWhile, forEach } from "iterlib";

getPlayers()
::map(x =&gt; x.character())
::takeWhile(x =&gt; x.strength &gt; 100)
::forEach(x =&gt; console.log(x));
</code></pre>
</div>
<p>【】直接复制过来。</p>
<h3 id="七尾调用优化">七、尾调用优化</h3>
<h4 id="什么是尾调用">什么是尾调用</h4>
<p>尾调用是函数式编程的一个重要概念，就是指某个函数的最后一步是调用另一个函数。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(x){
	return foo(x);
}
</code></pre>
</div>
<p>上面代码中，函数func的最后一步调用了函数foo，这就叫尾调用。</p>

<p>一下三种情况，都不是尾调用。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>//情况1
function func(x){
  var y = foo(x);
  return y;
}
//情况2
function func(x){
	return foo(x) + 1;
}
//情况3
function func(x){
	foo(x);
}
</code></pre>
</div>
<p>第一种情况是调用foo函数后还有赋值操作，所以不属于尾调用，即使语义完全一样。
情况二也属于调用后还有操作，即使写在一行内也不行。情况三等同于下面的代码。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(x){
	foo(x);
	return undefined;
}
</code></pre>
</div>
<p>尾调用不一定出现在函数最后一行，只要是最后一步操作即可。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(x){
	if(x &gt; 0){
		return m(x);
	}
	return n(x);
}
</code></pre>
</div>
<p>上面代码中，函数m和n都属于尾调用，因为他们都是函数func的最后一步。</p>
<h4 id="尾调用优化">尾调用优化</h4>
<p>尾调用之所以与其他调用不同，就在于他特殊的调用位置。</p>

<p>我们知道，函数调用会在内存形成一个”调用记录”，又称”调用帧”，保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回给A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个”调用栈”。</p>

<p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置，内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(){
	let m = 1;
	let n = 2;
	return foo(m+n);
}
//等同于
function func(){
	return foo(3);
}

//等同于
foo(3);
</code></pre>
</div>
<p>上面代码中，如果函数foo不是尾调用，函数f就需要保存内部变量m和n、g的调用位置等信息。但由于调用foo之后，函数foo就结束了，所以执行到最后一步，完全可以删除func的调用帧，只保留foo(3)的调用帧。</p>

<p>这就叫”尾调用优化”，即只保留内层函数的调用帧。如果所有函数都是尾调用，那么可以做到每次执行时，调用帧只有一项。这样可以大大节省内存，这就是尾调用优化的意义所在。</p>

<p>注意：只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行尾调用优化。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(a){
	var x = 1;
	function inner(b){
		return b + x ;
	}
	return inner(a);
}
</code></pre>
</div>
<p>上面的函数不会进行尾调用优化，因为内层函数inner用到了外层函数func的变量x。</p>
<h4 id="尾递归">尾递归</h4>
<p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p>

<p>递归非常耗费内存，因为需要同时保存成百上千个调用帧，很容易发生”栈溢出”错误。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生”栈溢出”错误。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(n){
	if(n &lt; 1){
		return 1;
	}else{
		return n * func(n-1);
	}
}
func(5); //120
</code></pre>
</div>
<p>上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录。</p>

<p>如果改成尾递归，只保留一个调用记录。【】测试过但不太理解</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(n,tal){
	if(n &lt; 1){
		return tal;
	}else{
		return func(n-1,n*tal)
	}
}
console.log(func(5,1));
</code></pre>
</div>
<p>还有一个著名的例子，就是计算Fibonacci数列，也能充分说明递归优化的重要性。</p>

<p>非尾递归的Fibonacci数列实现如下。【】复制</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function Fibonacci (n) {
  if ( n &lt;= 1 ) {return 1};

  return Fibonacci(n - 1) + Fibonacci(n - 2);
}

Fibonacci(10) // 89
Fibonacci(100) // 堆栈溢出
Fibonacci(500) // 堆栈溢出
</code></pre>
</div>
<p>尾递归优化过的 Fibonacci数列如下：【】复制</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
  if( n &lt;= 1 ) {return ac2};

  return Fibonacci2 (n - 1, ac2, ac1 + ac2);
}

Fibonacci2(100) // 573147844013817200000
Fibonacci2(1000) // 7.0330367711422765e+208
Fibonacci2(10000) // Infinity
</code></pre>
</div>
<p>由此可见，”尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。es6也是这样，第一次明确规定，所有ESMAScript的实现，都必须部署”尾调用优化”。也就是说，es6中只要使用尾递归，就不会发生栈溢出，相对节省内存。</p>

<h4 id="递归函数的改写">递归函数的改写</h4>
<p>尾递归的实现，需要改写递归函数，确保最后一步只只调用自身。做到这一点的方法就是，把所有内部用到的变量改写成函数的参数。比如上面阶乘的例子func需要用到一个中间变量tal，那就把中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1（这也是我上面打【】不太理解的地方）。</p>

<p>两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(num,tal){
	if(num &lt; 1){
		return tal;
	}else{
		return func(num-1,num * tal); 
	}
}
function funcNor(n){
	return func(n,1);
}
funcNor(5);
</code></pre>
</div>
<p>上面通过一个正常形式的阶乘函数funcNor，调用尾递归函数func，看起来就正常多了（我咋看的还是不正常）。</p>

<p>函数式编程有一个概念，叫做柯里化，意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function furrying(fn,n){
	return function(m){
		return fn.call(this,m,n);
	};
}

function func(num,tal){
	if(num &lt; 1){
		return tal;
	}else{
		return func(num-1,num * tal);
	}
}
let funcNor = furrying(func,1);
funcNor(5);//120
</code></pre>
</div>
<p>上面代码通过函数柯里化，将尾递归函数func变为只接受一个参数的funNor。</p>

<p>第二种方法就简单多了，就是采用es6的函数默认值。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(num,tal = 1){
	if(num &lt; 1){
		return tal;
	}else{
		return func(num -1 , num * tal);
	}
}
func(5);//120
</code></pre>
</div>
<p>上面代码中，参数tal有默认值，所以调用时不用传这个参数值。</p>

<p>总结一下：递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于支持”尾调用优化”的语言(ES6)，只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。</p>

<h4 id="严格模式-1">严格模式</h4>
<p>ES6的尾递归优化只在严格模式下开启，正常模式下是无效的。</p>

<p>这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p>

<p>（1）func.arguments:返回调用时函数的参数。</p>

<p>（2）func.caller:返回调用当前函数的那个函数。</p>

<p>尾调用优化发生时，函数的调用栈会改写，因此上面连个变量会报错。严格模式下禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(x){
	'use strict';
	console.log(func.arguments);  //报错
	console.log(func.caller);     //报错
}
</code></pre>
</div>
<h4 id="尾递归优化的实现">尾递归优化的实现</h4>
<p>尾递归优化只在严格模式下有效，那么正常模式下呢，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？肯定是可以的，就是自己实现尾递归优化。</p>

<p>他的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用”循环”换掉”递归”。</p>

<p>下面是一个正常的递归函数。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(x,y){
	if(y &gt; 0){
		return func(x+1,y - 1);
	}else{
		return x;
	}
}
func(1,1000000); //报错
</code></pre>
</div>
<p>上面是一个递归函数，函数的x参数进行累加，y参数控制递归次数。一但指定func递归10000次，就会报错，指出超出调用栈的最大次数。</p>

<p>蹦床函数(trampoline)可以将递归执行转为循环执行。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function trampoline(f) {
  while (f &amp;&amp; f instanceof Function) {
    f = f();
  }
  return f;
}
</code></pre>
</div>
<p>上面就是蹦床函数的一个实现，他接受一个函数f作为参数。只要f执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。</p>

<p>然后，要做的就是将原来的的递归函数，改写为每一步返回另一个函数。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(x,y){
	if(y &gt; 0){
		return func.bind(null,x+1,y - 1);
	}else{
		return x;
	}
}
</code></pre>
</div>
<p>上面代码中，将递归函数func改写为：函数的每次执行，都会返回自身的另一个版本。</p>

<p>现在，使用蹦床函数执行sum，就不会发生调用栈溢出。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>trampoline(func(1,10000)); //10001
</code></pre>
</div>
<p>蹦床函数并不是真正的尾递归优化，下面的实现才是。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function tco(f) {
  var value;
  var active = false;
  var accumulated = [];

  return function accumulator() {
    accumulated.push(arguments);
    if (!active) {
      active = true;
      while (accumulated.length) {
        value = f.apply(this, accumulated.shift());
      }
      active = false;
      return value;
    }
  };
}
function func(x,y){
	if(y &gt; 0){
		return func(x+1,y - 1);
	}else{
		return x;
	}
}
var sum = tco(func);
sum(1,10000);  //10001
</code></pre>
</div>
<p>上面代码中，【】tco的实现不是很理解，用途了解了。tco函数是尾递归优化的实现，他的奥妙体现在状态变量active。默认情况下，active变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归sum返回的都是undefined，所以就避免了递归执行。而accumulated数组存放每一轮sum执行的参数，总是有值的，这就保证了accumulator函数内部的while循环总是会执行。这样就很巧妙的将”递归”改成了”循环”,而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。</p>
<h3 id="八函数参数的尾逗号">八、函数参数的尾逗号</h3>
<p>ES2017 ，允许函数的最后一个参数有尾逗号。</p>

<p>此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(
	x,
	y
){}
func(
   1,
   2
);
</code></pre>
</div>
<p>上面代码中，按照以前的规定在参数y和参数2后面如果有逗号就会报错。</p>

<p>如果像上面一样，将参数写成多行（即每个参数占一行），以后修改代码的时候，想为函数func添加心的参数，或者调整参数的顺序，就要在原来最后一个参数后面加一个逗号。这对于版本管理系统来说，就会显示添加逗号的那一行也发生了改动。这看上去有点多余，因此新的语法允许定义和调用时，尾部直接有一个逗号。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(
	x,
	y,
){}
func(
   1,
   2,
);
</code></pre>
</div>
<p>这样的规定也使得，函数参数与数组和对象的尾逗号规则保持一致了。</p>


   
            </div>
            
          </div>
          
                <div class="next_page_box">
                  <div class="read_next">阅读下一篇文章</div>
                  <div class="next_page">
                    <a class="" href="http://localhost:4000/es6/2018/12/23/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95.html" data-post-href="http://localhost:4000/es6/2018/12/23/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95.html">
                      <h4>对象的扩展</h4>
                      <div></div>
                    </a>
                  </div>
                </div>
          
       </div>
    </div>
  </body>
<script src="/source/js/highlight.min.js"></script>
<script type="text/javascript" src="/source/js/jquery.js"></script>
<script type="text/javascript" src="/source/js/TweenMax.min.js"></script>
<script type="text/javascript" src="/source/js/DrawSVGPlugin.min.js"></script>
<script type="text/javascript" src="/source/js/tween.js"></script>
<script type="text/javascript" src="/source/js/animation.js"></script>
  <script type="text/javascript" src="/source/js/index.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
    $(document).ready(function(){
      //评论
        $('.comments').on('click',function(e){
          e.preventDefault();
          $('#lv-container').show();
        });
    })
  </script>
</html>