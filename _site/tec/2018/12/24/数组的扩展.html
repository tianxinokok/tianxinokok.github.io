<!DOCTYPE HTML>
<html>
<head>
  <meta charset="UTF-8">
    <link rel="stylesheet" href="/source/css/index.css" type="text/css">
    <link rel="stylesheet" href="/source/css/post_last.css" type="text/css">
    <link rel="stylesheet" href="/source/css/obsidian.min.css">
<!--     <link rel="stylesheet" type="text/css" href="/source/css/nav.css"> -->
    <link rel="stylesheet" type="text/css" href="/source/css/font-awesome-4.7.0/css/font-awesome.min.css">
    <link rel="icon" href="favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>摆渡先生</title>
   <!-- <link rel="stylesheet" href="/css/highlight.css" type="text/css">-->
</head>

 <body>
 <style type="text/css">

.nav {
  position: fixed;
  z-index: 100;
  top: 0;
  left: 0;
  width: 100%;
  height: 100vh;
  visibility: hidden;
}
.nav_open {
  visibility: visible;
}
.nav__list {
  display: flex;
  height: 100%;
  margin: 0;
  padding: 0;
  list-style: none;
}
.nav__item {
  position: relative;
  flex-basis: 25%;
  margin: 0;
  padding: 0;
}
.nav__link {
  position: relative;
  display: flex;
  align-items: center;
  height: 100%;
  padding: 0 0 0 20%;
  text-decoration: none;
  color: white;
  will-change: transform;
  transition: color 0.5s;
}
.nav__link:hover {
  color: black;
}
.nav__item-line {
  position: absolute;
  top: 0;
  right: 0;
  display: block;
  width: 1px;
  height: 100%;
  background: rgba(255, 255, 255, 0.2);
}
.nav__link-content {
  position: relative;
  z-index: 3;
}

.nav__link-base {
  position: absolute;
  z-index: 1;
  top: 0;
  left: 0;
  width: 100%;
  height: calc(100% - 150px);
  background-color: white;
  box-shadow: 2px 4px 16px 0 rgba(0, 0, 0, 0.2);
  will-change: transition;
  opacity: 0;
}
.nav__link:hover .nav__link-base {
  z-index: 2;
}
.nav__link-num {
  position: absolute;
  top: 12px;
  left: -24px;
  font-size: 16px;
  font-family: "bebas-neue", sans-serif;
}

.nav__link-title {
  font-size: 36px;
  text-transform: uppercase;
  font-family: "bebas-neue", sans-serif;
  margin-bottom: 8px;
  line-height: 0.8;
  overflow: hidden;
}

.nav__link-desc {
  display: block;
  font-size: 12px;
}
/*btn*/
.nav-btn {
  position: fixed;
  z-index: 101;
  bottom: 24px;
  left: 24px;
  width: 36px;
  height: 36px;
  background: transparent;
  padding: 0;
  margin: 0;
  border: none;
  appearance: none;
  outline: 0;
  cursor: pointer;
}
.burger {
  width: 36px;
  height: 36px;
}

.burger__stroke {
  stroke: white;
}

.burger__plus {
  fill: #1cb5e0;
}
/**/
.nav__bg {
  position: fixed;
  z-index: 99;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  will-change: auto;
  pointer-events: none;
  visibility: hidden;
}

.nav__bg-mask-rect {
  will-change: transform;
}
</style>
<div class="nav_box" style="z-index: 10000">
<nav class="nav">
	<ul class="nav__list">
		<li class="nav__item">
			<a class="nav__link" href="/">
				<div class="nav__link-content">
					<span class="nav__link-num">01</span>
					<div class="nav__link-title">Works</div>
					<div class="nav__link-desc">What I'm made</div>
				</div>
				<div class="nav__link-base"></div>
			</a>
			<div class="nav__item-line"></div>
		</li>
		<li class="nav__item">
			<a class="nav__link" href="/new">
				<div class="nav__link-content">
					<span class="nav__link-num">02</span>
					<div class="nav__link-title">News</div>
					<div class="nav__link-desc">Latest ramblings</div>
				</div>
				<div class="nav__link-base"></div>
			</a>
			<div class="nav__item-line"></div>
		</li>
		<li class="nav__item">
			<a class="nav__link" href="/book">
				<div class="nav__link-content">
					<span class="nav__link-num">03</span>
					<div class="nav__link-title">Books</div>
					<div class="nav__link-desc">Many good books</div>
				</div>
				<div class="nav__link-base"></div>
			</a>
			<div class="nav__item-line"></div>
		</li>
		<li class="nav__item">
			<a class="nav__link" href="/contact">
				<div class="nav__link-content">
					<span class="nav__link-num">04</span>
					<div class="nav__link-title">Contact</div>
					<div class="nav__link-desc">Don't be shy</div>
				</div>
				<div class="nav__link-base"></div>
			</a>
			<div class="nav__item-line"></div>
		</li>
	</ul>
</nav>
<svg class="nav__bg" width="100%" height="100%" viewBox="0 0 100 100" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg">
    <defs>
        <linearGradient class="nav__grad" x1="92.6356902%" y1="7.36430977%" x2="0%" y2="100%" id="nav-grad">
            <stop stop-color="#000000" offset="20%"></stop>
            <stop stop-color="#1cb5e0" offset="100%"></stop>
        </linearGradient>
		<mask id="nav__bg-mask" class="nav__bg-mask" maskUnits="userSpaceOnUse"x="0" y="0" width="100" height="100">
		  	<rect class="nav__bg-mask-rect" x="0" y="0" width="25" height="100" fill="white"/>
			<rect class="nav__bg-mask-rect" x="24.9" y="0" width="25.1" height="100" fill="white"/>
			<rect class="nav__bg-mask-rect" x="49.9" y="0" width="25.1" height="100" fill="white"/>
			<rect class="nav__bg-mask-rect" x="74.9" y="0" width="25.1" height="100" fill="white"/>
		</mask>
    </defs>
    <rect x="0" y="0" width="100" height="100" fill="url(#nav-grad)" mask="url(#nav__bg-mask)"></rect>
</svg>
<button class="nav-btn">
	<svg class="burger <?php echo $darkBurgerClass; ?>" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 36 36">
	<rect class="burger__stroke"  x="2" y="2" width="32" height="32" fill="none" stroke="" stroke-miterlimit="10" stroke-width="4"/>
	<polyline class="burger__stroke-over"points="18 2 34 2 34 34 2 34 2 2 18 2" fill="none" stroke="" stroke-miterlimit="10" stroke-width="4"/>
	<g class="burger__plus">
		<rect class="burger__plus-left" x="8" y="16" width="10" height="4"/>
		<rect class="burger__plus-btm" x="16" y="18" width="4" height="10"/>
		<rect class="burger__plus-right" x="18" y="16" width="10" height="4"/>
		<rect class="burger__plus-top" x="16" y="8" width="4" height="10"/>
	</g>
	</svg>
</button>

</div>

   <div class="content_container">
      <div class="common_box">
        <div class="slide_img" id="slide_img_1"><div class="slide_img_shade"></div></div>
        <div class="title_box">
          <h2 class="main_title"><span>WORKS</span></h2>
        </div> 
      </div>
      <div class="content_box">
          <div class="content_content" >
            <div class="post_content">
                <div class="content_title">
                  <h1>ES6基础-数组的扩展</h1><span id="busuanzi_container_page_pv">
                  <span><time datetime=""></time></span>
                </div>
                  <h3 id="一扩展运算符">一、扩展运算符</h3>
<h4 id="含义">含义</h4>
<p>扩展运算符是三个点(…)。它就像是rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>console.log(...[1,2,3]);     //1 2 3               
console.log(1,...[2,3,4],5); //1 2 3 4 5

var lis = document.querySelectorAll('li');
console.log(...lis);         // &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;
</code></pre>
</div>
<p>该运算符主要用于函数调用</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function(array,...values){
	array.push(...values);
}

function add(x,y){
   console.log(x+y);
}
let  data = [1,2];
add(...data); //3
</code></pre>
</div>
<p>上面代码都在函数的调用中用到了扩展运算符。该运算符将一个数组，变为参数序列。</p>

<p>扩展运算符与正常的函数参数可以结合使用，非常灵活。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(a,b,c,d,e){
  console.log(a+b+c+d+e);
}
func(1,...[2,3],...[4],5);//15
</code></pre>
</div>
<p>扩展运算符后面还可以放置表达式。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var x = 1;
let arr = [...(x&gt;0 ? ['a'] : []) , 'b' ];
console.log(arr); //[a,b];
</code></pre>
</div>
<p>如果扩展运算符后面是一个空数组，则不产生任何效果。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = [...[],2];
console.log(arr); //[2]
</code></pre>
</div>
<p>注意：扩展运算符如果放在括号中，js引擎就会认为这是函数调用。如果这时不是函数调用，就会报错。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = (...[1,2]);    //报错

console.log((...[1,2])); //报错

console.log(...[1,2])    //1,2
</code></pre>
</div>
<p>上面前两种写法会报错，是因为扩展运算符所在的括号不是函数调用。</p>

<h4 id="替代函数的apply方法">替代函数的apply方法</h4>
<p>由于扩展运算符可以展开数组，所以不再需要使用apply方法将数组转为函数的参数了。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function add(x,y,z){
	console.log(x+y+z);
}
let dataArr = [1,2,3];
add.apply(null,dataArr);  //6
add(...dataArr);          //6
</code></pre>
</div>
<p>下面是扩展运算符取代apply的方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>//es5
Math.max.apply(null,[1,3,4]);
//es6
Math.max(...[1,3,4]);
//等同于
Math.max(1,3,4);
</code></pre>
</div>
<p>上面代码中，由于js不提供数组最大项的函数，只能套用Math.max函数，将数组转化为一个参数序列，然后求最大值。有了扩展运算符之后，就可以直接用Math.max了。</p>

<p>另一个例子是：通过push函数，将一个数组添加到另一个数组的尾部。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>//es5
var arr1 = [1,2];
var arr2 = [3,4];
arr1.push(...arr2);
//es6
var arr1 = [1,2];
var arr2 = [3,4];
arr1.push(...arr2);
</code></pre>
</div>
<p>es5写法中，push的参数不能是数组，所以只好通过apply方法变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法。</p>

<p>下面是另外一个例子</p>
<div class="highlighter-rouge"><pre class="highlight"><code>//es5
var date = new (Date.bind.apply(Date, [null, 2015, 1, 1]));
//es6
var date2 = new Date(...[2015, 1, 1]);
</code></pre>
</div>
<h4 id="扩展运算符的应用">扩展运算符的应用</h4>

<h5 id="1复制数组">（1）复制数组</h5>
<p>数组是引用型数据类型，直接复制的话，只是复制数组的指针，而不是复制出一个全新的数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr1 = [1,2];
let arr2 = arr1;
arr2[0] = 2;
console.log(arr1);//[2, 2]
</code></pre>
</div>
<p>上面代码中，arr2不是一个全新的数组，而只是跟arr1拥有相同地址的指针。修改arr2，会直接导致arr1的变化。</p>

<p>ES5只能用变通方法来复制数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr1 = [1,2];
let arr2 = arr1.concat();
arr2[0] = 2;
console.log(arr1);//[1,2]
console.log(arr2);//[2,2]
</code></pre>
</div>
<p>上面代码中，arr1使用concat方法后，会返回元素数组的克隆，再修改arr2，就不会对arr1产生影响。</p>

<p>扩展运算符提供了复制数组的简便写法。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr1 = [1,2];
//写法一
let arr2 = [...arr1];
//写法二
let [...arr3] = [...arr1];
</code></pre>
</div>
<p>上面两种写法，arr2和arr3都是arr1的克隆。</p>
<h5 id="2数组合并">（2）数组合并</h5>
<p>扩展运算符提供了数组合并的新写法。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr1 = [1,2];
let arr2 = [3];
let arr3 = [4,5];
//es5
let arr4 = arr1.concat(arr2,arr3);
//es6
let arr5 = [...arr1,...arr2,...arr3];
</code></pre>
</div>
<p>不过，这两种方法都是浅拷贝，使用的时候需要注意。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr1 = [1,2];
let arr2 = [3,4];

let arr3 = arr1.concat(arr2);
let arr4 = [...arr1,...arr2];
arr3[0] === arr1[0]; //true
arr4[0] === arr1[0]; //true
</code></pre>
</div>
<p>【】这里阮一峰原文好像有点问题。
测试结论如下：上面两种方法在原数组是一维（数组内没有嵌套数组）的情况下用concat和扩展运算符拷贝后是深拷贝，修改拷贝后数组的值，不会影响到原数组。但是如果原数组中有嵌套的数组情况就不一样了，看下面代码。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr1 = [1,2,['abc']];
let arr2 = [3,4];

let arr3 = arr1.concat(arr2);
let arr4 = [...arr1,...arr2];

arr3[length - 3][0] = 'z'; //这里修改拷贝后数组中嵌套数组的值。
arr1[2]                    //z  原数组也修改了 
</code></pre>
</div>
<p>从上面的代码可以看出，如果原数组中有数组的嵌套，那么通过concat或者扩展运算符拷贝拷贝新数组后的第一层数组是深拷贝，嵌套的数组是浅拷贝，如果修改新数组内部嵌套数组的值，原数组的值也会发生改变。</p>
<h5 id="3与解构赋值结合">（3）与解构赋值结合</h5>
<p>扩展运算符可以与解构赋值结合起来，用于生成数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = [1,2,3,4];
//es5赋值
let a = arr[0];
let b = arr.slice(1);
//es6
[a,...b] = arr;
</code></pre>
</div>
<p>下面是另外一些例子。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = [1,2,3,4];
[first,...rest] = arr;
console.log(first); //1
console.log(rest);  //[2,3,4]

[first,...rest] = [];
console.log(first); //undefined
console.log(rest);  //[]

[first,...rest] = ['abc'];
console.log(first); //abc
console.log(rest);  //[]
</code></pre>
</div>
<p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>[...rest,first] = arr; //报错：Rest element must be last element
</code></pre>
</div>
<h5 id="4字符串">（4）字符串</h5>
<p>扩展运算符还可以将字符串转为真正的数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>[...'hello']; //["h", "e", "l", "l", "o"]
</code></pre>
</div>
<p>上面的写法有一个好处，那就是能够正确识别四个字节的Unicode字符。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>'x\uD83D\uDE80y'.length      //4
[...'x\uD83D\uDE80y'].length //4 
</code></pre>
</div>
<p>【】上面第二条用了扩展运算符之后结果还是4，原文打印的是3。？</p>
<h5 id="5实现了iterator接口的对象">（5）实现了Iterator接口的对象</h5>
<p>任何定义了遍历器(Iterator)接口的对象，（参阅Iterator一章），都可以用扩展运算符转为真正的数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let lis = document.querySelectorAll('li');
let arr = [...lis]; //[&lt;li&gt;&lt;/li&gt;]
</code></pre>
</div>
<p>上面代码中，querySelectorAll方法返回的是一个NodeList对象。不是数组，而是一个类似数组的对象。这时候如果用扩展运算符既可以将其转为真正的数组，原因就在于NodeList对象实现了Iterator。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Number.prototype[Symbol.iterator] = function*() {
  let i = 0;
  let num = this.valueOf();
  while (i &lt; num) {
    yield i++;
  }
}
console.log(...5);//0 1 2 3 4
</code></pre>
</div>
<p>【】Symbol.iterator不懂</p>

<p>实现的结果就是返回0到扩展运算符后面数字（不包括本身）的所有整数。</p>

<p>对于那些没有部署Iterator接口的类似数组的对象，扩展运算符就不能把他们转为真正的数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let obj = {
	name : 'tx',
	length:1
};
[...obj]; //报错 obj is not iterable
</code></pre>
</div>
<p>上面代码中，obj是一个对象，但是没有Iterator接口，扩展运算符就会报错。这时可以改为使用Array.from（下面快到了）方法将obj转为真正的数组。</p>
<h5 id="6map-和-set-结构generator-函数">（6）Map 和 Set 结构，Generator 函数</h5>
<p>扩展运算符内部调用的是数据结构的Iterator 接口，因此只要是具有Iterator 接口的对象，都可以使用扩展运算符，例如map结构。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let map = new Map([
	[1,'a'],
	[2,'b'],
	[3,'c']
]);
let arr = [...map.keys()]; //[1, 2, 3]
</code></pre>
</div>
<p>Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let go = function*(){
  yield 1;
  yield 2;
  yield 3;
};
[...go()] // [1, 2, 3])
</code></pre>
</div>
<p>【】上面函数看不懂</p>

<p>如果对没有Iterator 接口的对象使用扩展运算符，将会报错。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>const obj ={
	name:"tx",
	age:12
};
[...obj]; //报错
</code></pre>
</div>

<h3 id="二arrayfrom">二、Array.from()</h3>
<p>Array.from方法可以将两类对象转为真正的数组：类似数组的对象和可遍历的(iterable)对象(包括ES6 新增的数据结构 Set 和 Map)。</p>

<p>下面是一个类似数组的对象，Array.from可以把他转为真正的数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let obj = {
	"0" : 'tx',
	"1"  :'25',
	 length:2
};
//es5
let arr1 = [].slice.call(obj); //["tx", "25"]
//es6
let arr2 = Array.from(obj);    //["tx", "25"]
</code></pre>
</div>
<p>实际应用中，常见的类似数组的的对象是DOM返回的的NodeList集合，以及函数内部的arguments对象。Array.from()都可以将他们转为真正的数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>//NodeList集合
let lis = document.querySelectorAll('li');

Array.from(lis).filter( li =&gt;{
	if(li.textContent.length &gt; 1){
		console.log(li);
	}
})
//arguments对象
function func(){
	var args = Array.from(arguments);
}
</code></pre>
</div>
<p>上面代码中，querySelectorAll方法返回的是一个类似数组的对象，可以将这个对象转为数组，再使用filter方法【】。</p>

<p>只要是部署了Iterator 接口的数据结构，Array.from会返回一个一模一样的新数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var arr = Array.from([1,2,3]); //[1, 2, 3]
</code></pre>
</div>
<p>值得注意的是，扩展运算符也可以将某些数据结构转为数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(){
	let args = [...arguments];
}

[...document.querySelectorAll('li')]
</code></pre>
</div>
<p>扩展运算符背后调用的的是遍历器接口(Symbal.iterator)，如果一个对象没有部署这个接口，就无法转换。Array.from方法还支持类似数组的的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此任何有length属性的对象，都可以通过Array.from方法转为数组，但是这种情况扩展运算符是不能转换的</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var obj = {
	"name":"tx",
	"age" :28,
	length:2
};
var arr = Array.from(obj); //[undefined, undefined]

var obj = {
	"0":"tx",
	"1" :28,
	length:2
};
var arr = Array.from(obj); //["tx", 28]
</code></pre>
</div>
<p>上面这种情况，扩展运算符就会报错。</p>

<p>对于还没有部署该方法的环境，可以用Array.prototype.slice方法替代。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let toarray = (()=&gt; 
	Array.from  ? Array.from : obj=&gt; [].slice.call(obj)
)();
</code></pre>
</div>
<p>Array.from还可以接受第二个参数，作用跟数组的map方法类似。用来对每个元素进行处理，将处理后的值放入返回的数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = Array.from([1,2,3], x =&gt; x*x);      //[1, 4, 9]
let arr2 = Array.from([1,2,3]).map( x=&gt; x*x); //[1, 4, 9]
</code></pre>
</div>
<p>下面的例子是取出一组dom节点的文本内容。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let lis = document.querySelectorAll('li');
//map()
let LiTextcontent = Array.prototype.map.call(lis,x =&gt; x.textContent);
//Array.from()
let LiTextcontent2 = Array.from(lis,x=&gt;x.textContent);
</code></pre>
</div>
<p>下面的例子将数组中布尔值为false的成员转为0。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = Array.from([1,,2,false,4], x =&gt; x||0); //[1, 0, 2, 0, 4]
</code></pre>
</div>
<p>下面的例子是返回各种数据的类型。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(){
	return Array.from(arguments,x =&gt; typeof x);
}
datatype(1,NaN,'abc');//["number", "number", "string"]
</code></pre>
</div>
<p>如果map函数里面用到了this，还可以传入Array.from的第三个参数，用来绑定this。【】</p>

<p>Array.from可以将各种值转为真正的数组，并且还提供map功能。这实际上意味着，只要有一个原始的数据结构，就可以点对他的值进行处理，然后转成规范的数组结构，进而就可以使用数组上面的方法。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = Array.from({length:2}, () =&gt; 'tx') // ["tx", "tx"]
</code></pre>
</div>
<p>上面代码中，Array.from的第一个参数指定了第二个参数运行的次数。这种特性可以让Array.from的用法非常灵活。</p>

<p>Array.from的另一个应用是，将字符串转为数组，然后返回字符出的长度。因为他能正确处理各种Unicode 字符，可以避免js将大于\uFFFF的 Unicode 字符，算作两个字符的 bug。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function countSymbols(string) {
  return Array.from(string).length;
}
countSymbols('x\uD83D\uDE80y'); //3 这里可以正确打印x\uD83D\uDE80y的长度。
</code></pre>
</div>
<p>上面的代码证明了用Array.from转换后可以正确打印Unicode字符的长度，上文中用扩展运算符就不可以。</p>
<h3 id="三arrayof">三、Array.of()</h3>
<p>Array.of()方法用于将一组值转换为数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = Array.of(1,2,3); //[1, 2, 3]
Array.of(1,2).length;      //2
</code></pre>
</div>
<p>这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致
Array()的行为有差异。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = Array(1,2,3); //[1, 2, 3]
let arr = Array(2);     //[empty × 2]
let arr = Array();      //[]
</code></pre>
</div>
<p>上面代码中，Array方法三个参数、一个参数、没有参数时，返回结果都不一样。只有当参数个数不少于2个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上指定的是数组的长度。</p>

<p>Array.of()基本上可以替代Array()和new Array()，并且不存在由于参数不同而导致的的重载。他的行为非常统一。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Array.of();           //[]
Array.of(undefined);  //[undefined]
Array.of(2);          //[2]
</code></pre>
</div>
<p>Array.of()总是返回参数值组成的数组。如果没有参数，就返回一个空数组。</p>

<p>Array.of()方法可以用下面的函数模拟实现。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function arrayOf(){
	return [].slice.call(arguments);
}
</code></pre>
</div>
<h3 id="四数组实例的copywithin方法">四、数组实例的copyWithin()方法</h3>
<p>数组实例的copyWithin()方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），返回当前数组。使用这个方法，会修改当前数组。</p>

<p>他有三个参数。</p>

<p>（参数1）target（必须）→从该位置开始替换数据。如果为负值，表示倒数。</p>

<p>（参数2）start  （可选） →从该位置选取要复制的源数据，默认为0。如果为负值，表示倒数。</p>

<p>（参数3）end  （可选）  →到该位置停止选取复制的值。如果为负值，表示倒数。</p>

<p>这三个都应该是数值，如果不是，会自动转为数值。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = [1,2,3,4,5].copyWithin(0,3); //[4, 5, 3, 4, 5]
</code></pre>
</div>
<p>上面代码表示将从3号位直到最后的成员（4，5）。复制到从0号位开始的位置，结果复制了原来的1和2。</p>

<p>下面是更多的例子。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>//将3号位复制到0号位
let arr = [1,2,3,4,5].copyWithin(0,3,4); //[4, 2, 3, 4, 5]

//-2从后面数是正着数的3号位，-1从后面数是正着数的4号位
let arr = [1,2,3,4,5].copyWithin(0,-2,-1); //[4, 2, 3, 4, 5]

//如果没有部署TypedArray 的 copyWithin 的环境，用下面的方法
[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4); //Int32Array [4, 2, 3, 4, 5]
</code></pre>
</div>
<p>【】上面最后一个例子看不懂</p>

<h3 id="五数组实例的find和findindex">五、数组实例的find()和findIndex()</h3>
<p>数组实例的find方法，用于找出第一个符合条件的数组成员。他的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var x = [1,2,3,4,-1].find( (n) =&gt; n &gt; 3); //4
</code></pre>
</div>
<p>上面代码找出第一个大于3的成员，所以返回4。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var x = [1,2,3,4,-1].find(function(value,index,arr){
	return value &gt; 3
})  //4
</code></pre>
</div>
<p>上面代码中，find方法的回调函数可以接收三个参数，依次为当前的值，当前的位置，和原数组。</p>

<p>数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合，返回-1。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var x = [1,2,3,4,-1].findIndex(function(value,index,arr){
	return value &gt; 3
}) //3
</code></pre>
</div>
<p>这两个方法都可以接收第二个参数，用来绑定回调函数的this对象。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(x){
	return x &gt; this.age;
}
let obj = {
	name:'tx',
	age:'25'
};
var num = [20,25,26,30].find(func,obj); //26
</code></pre>
</div>
<p>上面代码中，find方法接收了第二个参数obj对象，回调函数func中的this指向obj对象。</p>

<p>另外，这两个方法都可以发现NaN，弥补了数组的indexOf方法的不足。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var idx = [NaN].indexOf(NaN);  						//-1
var idx = [NaN].findIndex(y =&gt; Object.is(NaN, y))   //0
</code></pre>
</div>
<p>上面代码中，indexOf方法无法识别数组的NaN成员，但是findIndex可以借助Object.is输出正确的结果。</p>
<h3 id="六数组实例的fill">六、数组实例的fill()</h3>
<p>fill方法使用给定值，填充一个数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = [1,2,'abc'].fill(0);       //[0, 0, 0]
let arrr = new Array(3).fill('abc'); //["abc", "abc", "abc"]
</code></pre>
</div>
<p>上面的代码表明，fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。</p>

<p>fill方法还可以接收第二个和第三个参数，用于指定填充的起始位置和结束位置。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = [1,2,3].fill('abc',1,2); //[1, "abc", 3]
</code></pre>
</div>
<p>上面代码表示：从1号位置开始，向原数组中填充abc，到2号位置结束。</p>

<p>注意，如果填充的类型为对象，那么被赋值的是对象的指针，而不是深拷贝对象。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let obj = { name:'tx'};
let arr = [1,2,3].fill(obj,1,2); 
console.log(arr);//[1, {name:'tx'}, 3]
obj.name = 'jl'; //修改原对象后,数组也会变化
console.log(arr);//[1, {name:'jl'}, 3]

let arr = new Array(3).fill([]);
console.log(arr);
arr[0].push(5);
console.log(arr); //[[5], [5], [5]]
</code></pre>
</div>
<h3 id="七数组实例的entrieskeysvalues">七.数组实例的entries()，keys()，values()</h3>
<p>ES6提供了三个新的方法entries()，keys()，values() ，这三个方法都用于遍历数组。他们都返回一个遍历器对象(详见Iterator一章)，可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var arr = [1,2];
for(let index of arr.keys()){
	console.log(index); //0,1
}
for(let elm of arr.values()){
	console.log(elm);   //1,2
}
for(let [index,elm] of arr.entries()){
	console.log(index,elm); //0 1 , 1 2
}
</code></pre>
</div>
<p>如果不使用for…of循环，可以手动调用遍历器对象的next方法，进行遍历。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = [1,2];
let entries  = arr.entries();
console.log(entries.next().value);  //[0,1]
console.log(entries.next().value);  //[1,2]
console.log(entries.next().value);  //undefined
</code></pre>
</div>
<h3 id="八数组实例的includes">八、数组实例的includes()</h3>
<p>Array.prototype.includes方法返回一个布尔值，表示数组是否包含给定的值，与字符出的includes方法类似。ES6引入了该方法。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>[1,2,3].includes(1);   //true
[1,2,3].includes(4);   //false
[1,NaN].includes(NaN); //true
</code></pre>
</div>
<p>该方法的第二个参数表示开始搜索的位置，默认为0。如果为负数，则表示倒数，如果绝对值大于数组长度，则会重置为从0开始。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>[1, 2, 3].includes(3, 3);  // false
[1, 2, 3].includes(3, -1); // true
</code></pre>
</div>
<p>没有该方法之前，我们通常使用数组的indexOf方法，检查是否包含某个值。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>if(arr.indexOf('成员') != -1){
	//有要查找的成员
}
</code></pre>
</div>
<p>indexOf方法有两个缺点，一是不够语义化，他的含义是找到参数值首次出现的位置，所以要与不等于-1比较，表达起来不够直观。二是，它内部使用全等(===)进行判断，这会导致对NaN的误判。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>[NaN].indexOf(NaN) //-1
</code></pre>
</div>
<p>使用includes方法就不会有这个问题。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>[NaN].includes(NaN) //true
</code></pre>
</div>
<p>对于不支持该方法的环境，使用一个函数替代。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>const contains = (() =&gt;
  Array.prototype.includes
    ? (arr, value) =&gt; arr.includes(value)
    : (arr, value) =&gt; arr.some(el =&gt; el === value)
)();
contains([1,NaN],NaN); //true
</code></pre>
</div>
<p>【】arr.some是什么意思？</p>

<p>另外，Map 和 Set 数据结构有一个has方法，需要注意与includes区分。</p>

<p>Map 结构的has方法，是用来查找键名的，比如Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。</p>

<p>Set 结构的has方法，是用来查找值的，比如Set.prototype.has(value)、WeakSet.prototype.has(value)。</p>

<h3 id="九数组实例的flatflatmap方法">九、数组实例的flat()，flatMap()方法</h3>
<p>数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组”拉平”，变成一维的数组。返回新数组，对原数组没有影响。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = [1,2,3,[4,5]].flat() //[1, 2, 3, 4, 5]
</code></pre>
</div>
<p>flat()默认只会”拉平”一层，如果想要”拉平”多层的嵌套数组，可以给flat()方法传入一个整数参数，该参数表示的就是你要拉平的层数，默认为1。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = [1,2,[3,['abc']]].flat();   //[1,2,3,['abc']]
let arr = [1,2,[3,['abc']]].flat(2);  //[1, 2, 3, "abc"]
</code></pre>
</div>
<p>如果不确定有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = [1,2,[3,['abc']]].flat(Infinity);  //[1, 2, 3, "abc"]
let arr = [[[[1,2]]]].flat(Infinity);        //[1, 2]
</code></pre>
</div>
<p>如果原数组有空位，flat()会跳过空位。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = [1,,[3]].flat(Infinity);  //[1, 3]
</code></pre>
</div>
<p>flatMap()方法对原数组的每个成员执行一个函数(相当于执行Array.prototype.map())，然会对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = [1,2,3].flatMap((x) =&gt;[x,x*x]); //[1, 1, 2, 4, 3, 9]
//相当于
let arr = [[1,1],[2,4],[3,9]].flat();
</code></pre>
</div>
<p>flatMap()只能拉平一层数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = [1,2,3].flatMap((x) =&gt;[[x*x]]); //[[1],[4],[9]]]
//相当于
let arr = [[[1]],[[4]],[[9]]].flat();
</code></pre>
</div>
<p>上面代码中，遍历函数返回的是一个双层的数组，但是默认只能展开一层，因此flatMap()返回的还是一个潜逃数组。</p>

<p>flatMap()方法的参数是一个遍历函数，该函数可以接收三个参数，分别是当前数组的成员、当前数组成员的位置(从0开始)、原数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>arr.flatMap(function callback(currentValue[, index[, array]]) {
  // ...
}[, thisArg])
</code></pre>
</div>
<p>flatMap()方法的第二个参数是：用来绑定前面循环函数的this。</p>
<h3 id="十数组的空位">十、数组的空位</h3>
<p>数组的空位是指：数组的某一个位置没有值。比如Array()构造函数返回的数组都是空位组成的。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Array(2)    //[ , ]
new Array(2)//[ , ]
</code></pre>
</div>
<p>注意：空位不是undefined，一个位置的值等于undefined，依然是有值的，空位是没有任何值，in运算符可以说明这一点。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>0 in [undefined, undefined] // true
0 in [, ,]                  // false
</code></pre>
</div>
<p>上面代码说明，第一个数组0号位置是有值的，第二个0号数组是没有值的。</p>

<p>ES5对空位的处理，已经很不一致了，大多数情况下会忽略空位。</p>

<p>forEach(), filter(), reduce(), every() 和some()都会跳过空位。</p>

<p>map()会跳过空位，但会保留这个值</p>

<p>join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串</p>
<div class="highlighter-rouge"><pre class="highlight"><code>//toString()方法
[,'a',undefined,null].toString()         //",a,,"
//join()方法
[,'a',undefined,null].join('#')          //"#a##"
// forEach方法
[,'a'].forEach((x,i) =&gt; console.log(i)); // 1
// filter方法
['a',,'b'].filter(x =&gt; true)             // ['a','b']
// every方法
[,'a'].every(x =&gt; x==='a')               // true
// reduce方法
[1,,2].reduce((x,y) =&gt; x+y)              // 3
// some方法
[,'a'].some(x =&gt; x !== 'a')              // false
// map方法
[,'a'].map(x =&gt; 1)                       // [,1]
</code></pre>
</div>
<p>ES6明确将空位转为undefined。</p>

<p>Array.from()方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Array.from([1,,3])//[1, undefined, 3]
</code></pre>
</div>
<p>扩展运算符(…)也会将空位填充undefined。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>[...[1,,3]] //[1, undefined, 3]
</code></pre>
</div>
<p>copyWithin()方法会连空位一起复制。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>[1,,3].copyWithin(); //[1, empty, 3]
</code></pre>
</div>
<p>fill会将空位视为正常的数组位置。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Array(3).fill('a') //["a", "a", "a"]
</code></pre>
</div>
<p>for…of循环也会遍历空位。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr =  [, , ,];
for(let i of arr){
	console.log(1); //打印三次
}
</code></pre>
</div>
<p>上面代码中，arr数组有三个空位，for…of没有忽略他们。如果改成map方法遍历，空位是会跳过的。</p>

<p>entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>// entries()
[...[,'a'].entries()]        // [[0,undefined], [1,"a"]]

// keys()
[...[,'a'].keys()]           // [0,1]

// values()
[...[,'a'].values()]         // [undefined,"a"]

// find()
[,'a'].find(x =&gt; true)       // undefined

// findIndex()
[,'a'].findIndex(x =&gt; true)  // 0
</code></pre>
</div>
<p>由于空位的处理规则非常不统一，所以尽量避免出现空位。</p>


   
            </div>
            
          </div>
          
                <div class="next_page_box">
                  <div class="read_next">阅读下一篇文章</div>
                  <div class="next_page">
                    <a class="" href="http://localhost:4000/tec/2018/12/23/%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95.html" data-post-href="http://localhost:4000/tec/2018/12/23/%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95.html">
                      <h4>ES6基础-函数的扩展</h4>
                      <div></div>
                    </a>
                  </div>
                </div>
          
       </div>
    </div>
  </body>
<script src="/source/js/highlight.min.js"></script>
<script type="text/javascript" src="/source/js/jquery.js"></script>
<script type="text/javascript" src="/source/js/TweenMax.min.js"></script>
<script type="text/javascript" src="/source/js/DrawSVGPlugin.min.js"></script>
<script type="text/javascript" src="/source/js/tween.js"></script>
<script type="text/javascript" src="/source/js/animation.js"></script>
  <script type="text/javascript" src="/source/js/index.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
    $(document).ready(function(){
      //评论
        $('.comments').on('click',function(e){
          e.preventDefault();
          $('#lv-container').show();
        });
    })
  </script>
</html>