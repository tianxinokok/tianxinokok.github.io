<!DOCTYPE HTML>
<html>
<head>
  <meta charset="UTF-8">
    <link rel="stylesheet" href="/source/css/index.css" type="text/css">
    <link rel="stylesheet" href="/source/css/post_last.css" type="text/css">
    <link rel="stylesheet" href="/source/css/obsidian.min.css">
<!--     <link rel="stylesheet" type="text/css" href="/source/css/nav.css"> -->
    <link rel="stylesheet" type="text/css" href="/source/css/font-awesome-4.7.0/css/font-awesome.min.css">
    <link rel="icon" href="favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>摆渡先生</title>
   <!-- <link rel="stylesheet" href="/css/highlight.css" type="text/css">-->
</head>

 <body>
 <div class="nav_box" style="z-index: 10000">
<nav class="nav">
	<ul class="nav__list">
		<li class="nav__item">
			<a class="nav__link" href="/">
				<div class="nav__link-content">
					<span class="nav__link-num">01</span>
					<div class="nav__link-title">Works</div>
					<div class="nav__link-desc">What I'm made</div>
				</div>
				<div class="nav__link-base"></div>
			</a>
			<div class="nav__item-line"></div>
		</li>
		<li class="nav__item">
			<a class="nav__link" href="/new">
				<div class="nav__link-content">
					<span class="nav__link-num">02</span>
					<div class="nav__link-title">News</div>
					<div class="nav__link-desc">Latest ramblings</div>
				</div>
				<div class="nav__link-base"></div>
			</a>
			<div class="nav__item-line"></div>
		</li>
		<li class="nav__item">
			<a class="nav__link" href="/book">
				<div class="nav__link-content">
					<span class="nav__link-num">03</span>
					<div class="nav__link-title">Books</div>
					<div class="nav__link-desc">Many good books</div>
				</div>
				<div class="nav__link-base"></div>
			</a>
			<div class="nav__item-line"></div>
		</li>
		<li class="nav__item">
			<a class="nav__link" href="/contact">
				<div class="nav__link-content">
					<span class="nav__link-num">04</span>
					<div class="nav__link-title">Contact</div>
					<div class="nav__link-desc">Don't be shy</div>
				</div>
				<div class="nav__link-base"></div>
			</a>
			<div class="nav__item-line"></div>
		</li>
        <li class="phone_btn_close nav__item">
            x
        </li>
	</ul>
  <div class="header_logo">
    <svg version="1.1"  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
   viewBox="0 0 825 299" style="enable-background:new 0 0 825 299;" xml:space="preserve">
<g class="logo_baidu">
  <path class="st0 logo_baidu_letter" fill="#fff" d="M132.94,183.58c-5.84,0.73-10.94,1.46-15.31,2.19c-2.19,0.73-4.02,0-5.47-2.19c0-5.1,1.82-8.02,5.47-8.75
    c3.64,0.73,8.75,1.09,15.31,1.09c0-5.1-0.37-10.2-1.09-15.31c0-2.91,1.09-4.38,3.28-4.38c7.29,0.73,10.57,3.65,9.84,8.75
    c-0.73,2.92-1.09,6.56-1.09,10.94h8.75c2.91,0.73,4.38,2.19,4.38,4.38c-2.19,1.46-6.56,2.19-13.13,2.19v9.84
    c7.29-1.45,11.3-1.45,12.03,0c0.73,2.19-3.28,4.74-12.03,7.66c0,11.67,0.36,21.52,1.09,29.53c0.73,5.84-1.46,10.21-6.56,13.13
    c-4.38,2.19-10.94,1.83-19.69-1.09c-7.3-3.64-11.3-7.29-12.03-10.94c17.5,4.38,26.25,3.65,26.25-2.19c0.73-9.48,0.73-17.86,0-25.16
    c-8.75,2.92-14.95,4.74-18.59,5.47c-2.92,0-4.74-1.45-5.47-4.38c-0.73-3.64,0.73-5.83,4.38-6.56c5.1-0.73,11.66-1.82,19.69-3.28
    V183.58z M217.16,162.8c3.64,0.73,5.47,3.28,5.47,7.66c-1.46,5.84-2.19,11.67-2.19,17.5c-0.73,3.65-2.92,5.11-6.56,4.38
    c-6.56-1.45-12.77-2.19-18.59-2.19c-0.73,2.19-0.73,4.38,0,6.56h14.22c3.64,0,5.83,0.73,6.56,2.19c0.73,2.92-1.09,4.38-5.47,4.38
    h-15.31c-0.73,2.19-0.73,4.38,0,6.56c15.31,0.73,28.8,0.73,40.47,0c-5.11,10.94-12.4,14.22-21.88,9.84
    c-6.56-2.19-13.13-3.28-19.69-3.28l-5.47,6.56c-2.92,2.92-5.11,5.47-6.56,7.66c3.64,2.92,7.66,4.02,12.03,3.28
    c5.1-1.45,8.38-3.28,9.84-5.47c-1.46-0.73-3.28-1.82-5.47-3.28c0.73-3.64,2.55-5.47,5.47-5.47c2.91-0.73,6.2,0.73,9.84,4.38
    c5.1,4.38,8.75,8.39,10.94,12.03c2.19,4.38,0.73,5.84-4.38,4.38c-3.65-2.91-7.66-5.83-12.03-8.75c-5.11,7.3-11.3,10.58-18.59,9.84
    c-8.02-3.64-13.13-5.1-15.31-4.38c-2.92,0.73-5.84,1.83-8.75,3.28c-2.92,0.73-5.11-0.36-6.56-3.28c-0.73-2.19,0-4.01,2.19-5.47
    c2.91-2.19,5.83-4.01,8.75-5.47c6.56-3.64,10.57-6.92,12.03-9.84c-14.59,0.73-24.06,1.83-28.44,3.28
    c-3.65,0.73-5.11-0.73-4.38-4.38c1.45-3.64,3.28-5.83,5.47-6.56c6.56,1.46,15.67,1.83,27.34,1.09c0.73-2.19,0.73-4.38,0-6.56
    c-7.3,0-13.49,0.37-18.59,1.09c-3.65,0.73-4.74-1.09-3.28-5.47c1.45-1.45,3.64-2.55,6.56-3.28c5.1,0.73,10.2,1.09,15.31,1.09
    c0.73-2.19,0.73-4.38,0-6.56c-6.56,0-11.67,0.73-15.31,2.19c-3.65,1.46-5.84,0.37-6.56-3.28c-0.73-8.75-1.46-15.67-2.19-20.78
    c0-4.38,2.55-6.2,7.66-5.47C181.8,164.99,198.93,164.99,217.16,162.8z M167.94,170.46c-0.73,2.92-0.73,7.3,0,13.13
    c3.64,1.46,6.56,1.46,8.75,0c0.73-4.38,0.73-8.75,0-13.13C174.51,169.73,171.58,169.73,167.94,170.46z M184.35,183.58
    c3.64,0.73,6.56,0.73,8.75,0c0.73-5.1,0.73-9.48,0-13.13c-2.92-0.73-5.84-0.73-8.75,0C183.62,175.57,183.62,179.94,184.35,183.58z
     M200.76,170.46c-0.73,3.65-0.73,8.02,0,13.13c4.38,1.46,7.66,1.46,9.84,0c2.19-3.64,2.55-8.02,1.09-13.13
    C208.05,169.73,204.4,169.73,200.76,170.46z"/>
  <path class="st0 logo_baidu_letter" fill="#fff" d="M255.44,189.05c8.75,2.92,17.5,5.11,26.25,6.56c1.45,0.73,1.45,1.83,0,3.28c-5.84,2.19-11.3,3.28-16.41,3.28
    c-7.3,0.73-13.13,0-17.5-2.19c-2.92-2.19-2.92-5.1,0-8.75C249.98,189.05,252.52,188.33,255.44,189.05z M255.44,216.4
    c8.75-1.45,17.5-4.01,26.25-7.66c1.45-0.73,2.55-0.73,3.28,0c-2.19,4.38-5.11,8.02-8.75,10.94c-4.38,3.65-10.94,6.93-19.69,9.84
    c-2.92,0-5.11-1.82-6.56-5.47C249.24,219.68,251.07,217.13,255.44,216.4z M262.01,166.08c7.29,5.11,14.95,9.48,22.97,13.13
    c-0.73,1.46-4.38,2.19-10.94,2.19s-12.77-1.45-18.59-4.38c-2.19-1.45-2.92-3.28-2.19-5.47
    C254.71,167.18,257.63,165.36,262.01,166.08z M313.41,186.87c-4.38-0.73-8.39-0.36-12.03,1.09c0,5.84-0.73,13.13-2.19,21.88
    c-0.73,4.38-2.19,8.39-4.38,12.03c-2.19,3.65-4.38,6.56-6.56,8.75c-5.11,4.38-9.48,6.93-13.13,7.66c-2.92,0-5.47-0.36-7.66-1.09
    c-1.46-1.45-2.55-2.55-3.28-3.28c2.91-2.19,6.2-4.01,9.84-5.47c3.64-2.19,6.92-5.1,9.84-8.75c2.19-3.64,4.01-7.29,5.47-10.94
    c1.45-5.83,2.19-11.3,2.19-16.41c0.73-8.75-0.37-16.04-3.28-21.88c0-4.38,2.19-6.56,6.56-6.56c4.38,1.46,12.39,2.19,24.06,2.19
    v-6.56c1.45-2.91,4.38-4.01,8.75-3.28c2.19,0.73,4.01,1.83,5.47,3.28v6.56h20.78c6.56,0,9.84,1.46,9.84,4.38
    c-1.46,1.46-7.66,2.19-18.59,2.19c-1.46,2.92-1.46,5.47,0,7.66h8.75c5.83,0,8.75,1.09,8.75,3.28s-1.09,3.28-3.28,3.28h-14.22
    c-0.73,3.65-0.73,6.93,0,9.84c0.73,3.65-1.09,5.11-5.47,4.38c-2.92-1.45-5.84-2.55-8.75-3.28c-2.19,0-4.38,0-6.56,0
    c-2.19,0.73-4.02,1.46-5.47,2.19c-3.65,0.73-5.47-0.36-5.47-3.28C314.14,192.33,314.14,189.05,313.41,186.87z M314.51,202.18
    c2.19,0.73,4.38,1.09,6.56,1.09c7.29-0.73,14.95-0.36,22.97,1.09c5.1,1.46,6.92,4.02,5.47,7.66c-2.19,2.92-5.11,6.93-8.75,12.03
    c16.04,5.11,28.07,7.66,36.09,7.66c-7.3,10.94-14.59,14.58-21.88,10.94c-6.56-4.38-13.49-8.75-20.78-13.13
    c-9.48,5.11-17.87,8.75-25.16,10.94c-6.56,1.46-10.58-0.73-12.03-6.56c0.73-0.73,4.73-1.82,12.03-3.28
    c8.02-1.45,14.22-3.64,18.59-6.56c-4.38-2.91-8.39-5.47-12.03-7.66c0-3.64,1.82-5.1,5.47-4.38c3.64,2.19,7.66,4.74,12.03,7.66
    c2.91-2.19,4.73-4.73,5.47-7.66c0.73-2.19-0.73-3.28-4.38-3.28c-6.56,0-12.77,0.37-18.59,1.09c-3.65,2.19-5.84,2.19-6.56,0
    C309.76,205.46,311.58,202.91,314.51,202.18z M313.41,172.65c-3.65-0.73-8.02-0.73-13.13,0c-0.73,2.92-0.73,5.47,0,7.66
    c4.38,0.73,8.75,0.73,13.13,0C314.14,177.39,314.14,174.83,313.41,172.65z M322.16,172.65c-0.73,2.92-0.73,5.47,0,7.66
    c5.1,0.73,9.48,0.73,13.13,0c0.73-2.91,0.73-5.47,0-7.66C330.91,171.92,326.54,171.92,322.16,172.65z M336.38,186.87
    c-4.38-0.73-9.12-0.73-14.22,0c0,1.46,0,3.28,0,5.47c4.38,0.73,8.38,0.73,12.03,0C336.38,192.33,337.11,190.51,336.38,186.87z"/>
</g>
<polyline class="st1 logo_baidu_border" points="409.5,179.35 409.5,261 81.5,261 81.5,140 367.18,140 " fill="none" stroke="#fff" stroke-miterlimit="10" stroke-width="16"/>
<g class="logo__plus" fill="none" stroke="#fff" stroke-miterlimit="10" stroke-width="16">
  <line class="st1 logo__plus-horz" x1="382.5" y1="140.5" x2="436.5" y2="140.5"/>
  <!-- <path class="st1" d="M411.5,117.5"/> -->
  <line class="st1 logo__plus-vert" x1="409.5" y1="167.5" x2="409.5" y2="113.5"/>
</g>
<g class="logo__xiansheng">
  <path class="st2 logo_xiansheng_letter" fill="#fff" d="M484.78,60.65c-5.11,3.65-9.12,5.47-12.03,5.47c-4.38,0-5.47-1.09-3.28-3.28c5.1-2.91,8.75-8.02,10.94-15.31
    c1.45-6.56,3.64-9.48,6.56-8.75c2.91,0,4.73,1.46,5.47,4.38c0,3.65-1.09,6.56-3.28,8.75h16.41V39.87c0-4.38,1.82-6.92,5.47-7.66
    c6.56,0,9.84,2.92,9.84,8.75V51.9h25.16c4.38,0,6.2,1.83,5.47,5.47c-0.73,2.19-2.19,3.28-4.38,3.28h-26.25v8.75
    c10.94,0,22.6,0.37,35,1.09c2.91,0,4.73,1.09,5.47,3.28c0.73,4.38-1.83,6.56-7.66,6.56c-10.21-0.73-19.69-1.09-28.44-1.09v10.94
    c0,8.02,6.56,12.03,19.69,12.03c14.58,0.73,26.25-1.45,35-6.56c-2.92,10.94-6.2,17.5-9.84,19.69c-7.3,5.11-17.87,5.84-31.72,2.19
    c-5.11-1.45-9.48-3.28-13.13-5.47c-7.3-4.38-11.3-10.57-12.03-18.59V79.24h-6.56c-0.73,4.38-2.55,9.48-5.47,15.31
    c-6.56,9.48-14.22,16.05-22.97,19.69c-7.3,2.92-14.59,3.65-21.88,2.19c-6.56-2.91-8.75-5.83-6.56-8.75
    c24.79-0.73,40.1-10.2,45.94-28.44c-5.84-0.73-13.49,0-22.97,2.19c-7.3,2.19-10.58,0.73-9.84-4.38c3.64-5.83,6.92-8.38,9.84-7.66
    c8.02,1.46,18.95,1.46,32.81,0v-8.75H484.78z"/>

  <path class="st3 logo_xiansheng_letter" fill="#fff" d="M645.29,63.43c-6.56-0.73-14.22-0.73-22.97,0c-2.92,3.65-7.3,6.93-13.13,9.84c-2.92,0.73-4.02,0-3.28-2.19
    c5.83-6.56,9.84-13.48,12.03-20.78c2.19-8.75,6.2-12.03,12.03-9.84c4.38,2.92,3.64,8.02-2.19,15.31h17.5
    c0.73-6.56,0.73-12.39,0-17.5c0-4.38,2.19-6.92,6.56-7.66c5.83,0,8.75,2.55,8.75,7.66c0,8.75,0.36,14.59,1.09,17.5h22.97
    c8.02-0.73,12.03,0.73,12.03,4.38c2.19,3.65-9.48,4.74-35,3.28c-1.46,3.65-1.46,7.3,0,10.94l21.88,1.09c2.91,0,6.2,0.73,9.84,2.19
    c1.45,2.92,1.09,4.74-1.09,5.47c-8.75-0.73-18.23-0.73-28.44,0c-2.19,0-3.28,3.65-3.28,10.94c0.73,6.56,16.04,8.02,45.94,4.38
    c3.64,0,8.02-0.73,13.13-2.19c-3.65,16.77-12.03,22.97-25.16,18.59c-22.61-8.02-48.13-10.2-76.56-6.56
    c-10.94,2.19-17.87,3.65-20.78,4.38c-5.84,1.46-8.02-0.36-6.56-5.47c2.91-5.83,6.92-9.48,12.03-10.94
    c2.91-0.73,7.29-0.36,13.13,1.09c18.95,2.19,28.8,1.46,29.53-2.19c1.45-8.02,0-12.03-4.38-12.03c-7.3-0.73-14.22,0-20.78,2.19
    c-4.38,1.46-5.84-0.36-4.38-5.47c0.73-2.19,2.91-4.38,6.56-6.56c2.91-1.45,5.83-1.09,8.75,1.09c5.83,0.73,10.2,0.73,13.13,0
    C646.38,72.91,646.74,69.27,645.29,63.43z"/>
</g>
<polyline class="st1 logo_xiansheng_border" points="409.5,101.65 409.5,20 737.5,20 737.5,141 451.82,141 " fill="none" stroke="#fff" stroke-miterlimit="10" stroke-width="16"/>
</svg>
  </div>
</nav>
<svg class="nav__bg" width="100%" height="100%" viewBox="0 0 100 100" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg">
    <defs>
        <linearGradient class="nav__grad" x1="92.6356902%" y1="7.36430977%" x2="0%" y2="100%" id="nav-grad">
            <!-- <stop stop-color="#000000" offset="20%"></stop>
            <stop stop-color="#223e36" offset="100%"></stop> -->
            <!-- <stop stop-color="#43C6AC" offset="20%"></stop>
            <stop stop-color="#191654" offset="100%"></stop> -->
            <stop stop-color="#00dbde" offset="20%"></stop>
            <stop stop-color="#fc00ff" offset="100%"></stop>
        </linearGradient>
		<mask id="nav__bg-mask" class="nav__bg-mask" maskUnits="userSpaceOnUse"x="0" y="0" width="100" height="100">
		  	<rect class="nav__bg-mask-rect" x="0" y="0" width="25" height="100" fill="white"/>
			<rect class="nav__bg-mask-rect" x="24.9" y="0" width="25.1" height="100" fill="white"/>
			<rect class="nav__bg-mask-rect" x="49.9" y="0" width="25.1" height="100" fill="white"/>
			<rect class="nav__bg-mask-rect" x="74.9" y="0" width="25.1" height="100" fill="white"/>
		</mask>
    </defs>
    <rect x="0" y="0" width="100" height="100" fill="url(#nav-grad)" mask="url(#nav__bg-mask)"></rect>
</svg>
<button class="nav-btn">
	<svg class="burger <?php echo $darkBurgerClass; ?>" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 36 36">
	<rect class="burger__stroke"  x="2" y="2" width="32" height="32" fill="none" stroke="" stroke-miterlimit="10" stroke-width="4"/>
	<polyline class="burger__stroke-over"points="18 2 34 2 34 34 2 34 2 2 18 2" fill="none" stroke="" stroke-miterlimit="10" stroke-width="4"/>
	<g class="burger__plus">
		<rect class="burger__plus-left" x="8" y="16" width="10" height="4"/>
		<rect class="burger__plus-btm" x="16" y="18" width="4" height="10"/>
		<rect class="burger__plus-right" x="18" y="16" width="10" height="4"/>
		<rect class="burger__plus-top" x="16" y="8" width="4" height="10"/>
	</g>
	</svg>
</button>
   <!--phone_menu-->  
<button class="nav_btn_phone">
  <svg version="1.1" id="" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
     viewBox="0 0 213 200" style="enable-background:new 0 0 213 200;" xml:space="preserve">
  <g>
    <line class="svg_menu_phone" x1="33" y1="58" x2="177" y2="58"/>
    <line class="svg_menu_phone" x1="33" y1="100" x2="177" y2="100"/>
    <line class="svg_menu_phone" x1="33" y1="142" x2="177" y2="142"/>
  </g>
  </svg>
</button>
</div>

   <div class="content_container">
      <div class="common_box">
        <div class="slide_img" id="slide_img_1"><div class="slide_img_shade"></div></div>
        <div class="title_box">
          <h2 class="main_title"><span>WORKS</span></h2>
        </div> 
      </div>
      <div class="content_box">
          <div class="content_content" >
            <div class="post_content">
                <div class="content_title">
                  <h1>ES6基础-数组的扩展</h1><span id="busuanzi_container_page_pv">
                  <span><time datetime=""></time></span>
                </div>
                  <h3 id="一扩展运算符">一、扩展运算符</h3>
<h4 id="含义">含义</h4>
<p>扩展运算符是三个点(…)。它就像是rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>console.log(...[1,2,3]);     //1 2 3               
console.log(1,...[2,3,4],5); //1 2 3 4 5

var lis = document.querySelectorAll('li');
console.log(...lis);         // &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;
</code></pre>
</div>
<p>该运算符主要用于函数调用</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function(array,...values){
	array.push(...values);
}

function add(x,y){
   console.log(x+y);
}
let  data = [1,2];
add(...data); //3
</code></pre>
</div>
<p>上面代码都在函数的调用中用到了扩展运算符。该运算符将一个数组，变为参数序列。</p>

<p>扩展运算符与正常的函数参数可以结合使用，非常灵活。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(a,b,c,d,e){
  console.log(a+b+c+d+e);
}
func(1,...[2,3],...[4],5);//15
</code></pre>
</div>
<p>扩展运算符后面还可以放置表达式。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var x = 1;
let arr = [...(x&gt;0 ? ['a'] : []) , 'b' ];
console.log(arr); //[a,b];
</code></pre>
</div>
<p>如果扩展运算符后面是一个空数组，则不产生任何效果。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = [...[],2];
console.log(arr); //[2]
</code></pre>
</div>
<p>注意：扩展运算符如果放在括号中，js引擎就会认为这是函数调用。如果这时不是函数调用，就会报错。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = (...[1,2]);    //报错

console.log((...[1,2])); //报错

console.log(...[1,2])    //1,2
</code></pre>
</div>
<p>上面前两种写法会报错，是因为扩展运算符所在的括号不是函数调用。</p>

<h4 id="替代函数的apply方法">替代函数的apply方法</h4>
<p>由于扩展运算符可以展开数组，所以不再需要使用apply方法将数组转为函数的参数了。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function add(x,y,z){
	console.log(x+y+z);
}
let dataArr = [1,2,3];
add.apply(null,dataArr);  //6
add(...dataArr);          //6
</code></pre>
</div>
<p>下面是扩展运算符取代apply的方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>//es5
Math.max.apply(null,[1,3,4]);
//es6
Math.max(...[1,3,4]);
//等同于
Math.max(1,3,4);
</code></pre>
</div>
<p>上面代码中，由于js不提供数组最大项的函数，只能套用Math.max函数，将数组转化为一个参数序列，然后求最大值。有了扩展运算符之后，就可以直接用Math.max了。</p>

<p>另一个例子是：通过push函数，将一个数组添加到另一个数组的尾部。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>//es5
var arr1 = [1,2];
var arr2 = [3,4];
arr1.push(...arr2);
//es6
var arr1 = [1,2];
var arr2 = [3,4];
arr1.push(...arr2);
</code></pre>
</div>
<p>es5写法中，push的参数不能是数组，所以只好通过apply方法变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法。</p>

<p>下面是另外一个例子</p>
<div class="highlighter-rouge"><pre class="highlight"><code>//es5
var date = new (Date.bind.apply(Date, [null, 2015, 1, 1]));
//es6
var date2 = new Date(...[2015, 1, 1]);
</code></pre>
</div>
<h4 id="扩展运算符的应用">扩展运算符的应用</h4>

<h5 id="1复制数组">（1）复制数组</h5>
<p>数组是引用型数据类型，直接复制的话，只是复制数组的指针，而不是复制出一个全新的数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr1 = [1,2];
let arr2 = arr1;
arr2[0] = 2;
console.log(arr1);//[2, 2]
</code></pre>
</div>
<p>上面代码中，arr2不是一个全新的数组，而只是跟arr1拥有相同地址的指针。修改arr2，会直接导致arr1的变化。</p>

<p>ES5只能用变通方法来复制数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr1 = [1,2];
let arr2 = arr1.concat();
arr2[0] = 2;
console.log(arr1);//[1,2]
console.log(arr2);//[2,2]
</code></pre>
</div>
<p>上面代码中，arr1使用concat方法后，会返回元素数组的克隆，再修改arr2，就不会对arr1产生影响。</p>

<p>扩展运算符提供了复制数组的简便写法。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr1 = [1,2];
//写法一
let arr2 = [...arr1];
//写法二
let [...arr3] = [...arr1];
</code></pre>
</div>
<p>上面两种写法，arr2和arr3都是arr1的克隆。</p>
<h5 id="2数组合并">（2）数组合并</h5>
<p>扩展运算符提供了数组合并的新写法。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr1 = [1,2];
let arr2 = [3];
let arr3 = [4,5];
//es5
let arr4 = arr1.concat(arr2,arr3);
//es6
let arr5 = [...arr1,...arr2,...arr3];
</code></pre>
</div>
<p>不过，这两种方法都是浅拷贝，使用的时候需要注意。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr1 = [1,2];
let arr2 = [3,4];

let arr3 = arr1.concat(arr2);
let arr4 = [...arr1,...arr2];
arr3[0] === arr1[0]; //true
arr4[0] === arr1[0]; //true
</code></pre>
</div>
<p>【】这里阮一峰原文好像有点问题。
测试结论如下：上面两种方法在原数组是一维（数组内没有嵌套数组）的情况下用concat和扩展运算符拷贝后是深拷贝，修改拷贝后数组的值，不会影响到原数组。但是如果原数组中有嵌套的数组情况就不一样了，看下面代码。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr1 = [1,2,['abc']];
let arr2 = [3,4];

let arr3 = arr1.concat(arr2);
let arr4 = [...arr1,...arr2];

arr3[length - 3][0] = 'z'; //这里修改拷贝后数组中嵌套数组的值。
arr1[2]                    //z  原数组也修改了 
</code></pre>
</div>
<p>从上面的代码可以看出，如果原数组中有数组的嵌套，那么通过concat或者扩展运算符拷贝拷贝新数组后的第一层数组是深拷贝，嵌套的数组是浅拷贝，如果修改新数组内部嵌套数组的值，原数组的值也会发生改变。</p>
<h5 id="3与解构赋值结合">（3）与解构赋值结合</h5>
<p>扩展运算符可以与解构赋值结合起来，用于生成数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = [1,2,3,4];
//es5赋值
let a = arr[0];
let b = arr.slice(1);
//es6
[a,...b] = arr;
</code></pre>
</div>
<p>下面是另外一些例子。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = [1,2,3,4];
[first,...rest] = arr;
console.log(first); //1
console.log(rest);  //[2,3,4]

[first,...rest] = [];
console.log(first); //undefined
console.log(rest);  //[]

[first,...rest] = ['abc'];
console.log(first); //abc
console.log(rest);  //[]
</code></pre>
</div>
<p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>[...rest,first] = arr; //报错：Rest element must be last element
</code></pre>
</div>
<h5 id="4字符串">（4）字符串</h5>
<p>扩展运算符还可以将字符串转为真正的数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>[...'hello']; //["h", "e", "l", "l", "o"]
</code></pre>
</div>
<p>上面的写法有一个好处，那就是能够正确识别四个字节的Unicode字符。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>'x\uD83D\uDE80y'.length      //4
[...'x\uD83D\uDE80y'].length //4 
</code></pre>
</div>
<p>【】上面第二条用了扩展运算符之后结果还是4，原文打印的是3。？</p>
<h5 id="5实现了iterator接口的对象">（5）实现了Iterator接口的对象</h5>
<p>任何定义了遍历器(Iterator)接口的对象，（参阅Iterator一章），都可以用扩展运算符转为真正的数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let lis = document.querySelectorAll('li');
let arr = [...lis]; //[&lt;li&gt;&lt;/li&gt;]
</code></pre>
</div>
<p>上面代码中，querySelectorAll方法返回的是一个NodeList对象。不是数组，而是一个类似数组的对象。这时候如果用扩展运算符既可以将其转为真正的数组，原因就在于NodeList对象实现了Iterator。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Number.prototype[Symbol.iterator] = function*() {
  let i = 0;
  let num = this.valueOf();
  while (i &lt; num) {
    yield i++;
  }
}
console.log(...5);//0 1 2 3 4
</code></pre>
</div>
<p>【】Symbol.iterator不懂</p>

<p>实现的结果就是返回0到扩展运算符后面数字（不包括本身）的所有整数。</p>

<p>对于那些没有部署Iterator接口的类似数组的对象，扩展运算符就不能把他们转为真正的数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let obj = {
	name : 'tx',
	length:1
};
[...obj]; //报错 obj is not iterable
</code></pre>
</div>
<p>上面代码中，obj是一个对象，但是没有Iterator接口，扩展运算符就会报错。这时可以改为使用Array.from（下面快到了）方法将obj转为真正的数组。</p>
<h5 id="6map-和-set-结构generator-函数">（6）Map 和 Set 结构，Generator 函数</h5>
<p>扩展运算符内部调用的是数据结构的Iterator 接口，因此只要是具有Iterator 接口的对象，都可以使用扩展运算符，例如map结构。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let map = new Map([
	[1,'a'],
	[2,'b'],
	[3,'c']
]);
let arr = [...map.keys()]; //[1, 2, 3]
</code></pre>
</div>
<p>Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let go = function*(){
  yield 1;
  yield 2;
  yield 3;
};
[...go()] // [1, 2, 3])
</code></pre>
</div>
<p>【】上面函数看不懂</p>

<p>如果对没有Iterator 接口的对象使用扩展运算符，将会报错。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>const obj ={
	name:"tx",
	age:12
};
[...obj]; //报错
</code></pre>
</div>

<h3 id="二arrayfrom">二、Array.from()</h3>
<p>Array.from方法可以将两类对象转为真正的数组：类似数组的对象和可遍历的(iterable)对象(包括ES6 新增的数据结构 Set 和 Map)。</p>

<p>下面是一个类似数组的对象，Array.from可以把他转为真正的数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let obj = {
	"0" : 'tx',
	"1"  :'25',
	 length:2
};
//es5
let arr1 = [].slice.call(obj); //["tx", "25"]
//es6
let arr2 = Array.from(obj);    //["tx", "25"]
</code></pre>
</div>
<p>实际应用中，常见的类似数组的的对象是DOM返回的的NodeList集合，以及函数内部的arguments对象。Array.from()都可以将他们转为真正的数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>//NodeList集合
let lis = document.querySelectorAll('li');

Array.from(lis).filter( li =&gt;{
	if(li.textContent.length &gt; 1){
		console.log(li);
	}
})
//arguments对象
function func(){
	var args = Array.from(arguments);
}
</code></pre>
</div>
<p>上面代码中，querySelectorAll方法返回的是一个类似数组的对象，可以将这个对象转为数组，再使用filter方法【】。</p>

<p>只要是部署了Iterator 接口的数据结构，Array.from会返回一个一模一样的新数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var arr = Array.from([1,2,3]); //[1, 2, 3]
</code></pre>
</div>
<p>值得注意的是，扩展运算符也可以将某些数据结构转为数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(){
	let args = [...arguments];
}

[...document.querySelectorAll('li')]
</code></pre>
</div>
<p>扩展运算符背后调用的的是遍历器接口(Symbal.iterator)，如果一个对象没有部署这个接口，就无法转换。Array.from方法还支持类似数组的的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此任何有length属性的对象，都可以通过Array.from方法转为数组，但是这种情况扩展运算符是不能转换的</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var obj = {
	"name":"tx",
	"age" :28,
	length:2
};
var arr = Array.from(obj); //[undefined, undefined]

var obj = {
	"0":"tx",
	"1" :28,
	length:2
};
var arr = Array.from(obj); //["tx", 28]
</code></pre>
</div>
<p>上面这种情况，扩展运算符就会报错。</p>

<p>对于还没有部署该方法的环境，可以用Array.prototype.slice方法替代。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let toarray = (()=&gt; 
	Array.from  ? Array.from : obj=&gt; [].slice.call(obj)
)();
</code></pre>
</div>
<p>Array.from还可以接受第二个参数，作用跟数组的map方法类似。用来对每个元素进行处理，将处理后的值放入返回的数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = Array.from([1,2,3], x =&gt; x*x);      //[1, 4, 9]
let arr2 = Array.from([1,2,3]).map( x=&gt; x*x); //[1, 4, 9]
</code></pre>
</div>
<p>下面的例子是取出一组dom节点的文本内容。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let lis = document.querySelectorAll('li');
//map()
let LiTextcontent = Array.prototype.map.call(lis,x =&gt; x.textContent);
//Array.from()
let LiTextcontent2 = Array.from(lis,x=&gt;x.textContent);
</code></pre>
</div>
<p>下面的例子将数组中布尔值为false的成员转为0。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = Array.from([1,,2,false,4], x =&gt; x||0); //[1, 0, 2, 0, 4]
</code></pre>
</div>
<p>下面的例子是返回各种数据的类型。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(){
	return Array.from(arguments,x =&gt; typeof x);
}
datatype(1,NaN,'abc');//["number", "number", "string"]
</code></pre>
</div>
<p>如果map函数里面用到了this，还可以传入Array.from的第三个参数，用来绑定this。【】</p>

<p>Array.from可以将各种值转为真正的数组，并且还提供map功能。这实际上意味着，只要有一个原始的数据结构，就可以点对他的值进行处理，然后转成规范的数组结构，进而就可以使用数组上面的方法。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = Array.from({length:2}, () =&gt; 'tx') // ["tx", "tx"]
</code></pre>
</div>
<p>上面代码中，Array.from的第一个参数指定了第二个参数运行的次数。这种特性可以让Array.from的用法非常灵活。</p>

<p>Array.from的另一个应用是，将字符串转为数组，然后返回字符出的长度。因为他能正确处理各种Unicode 字符，可以避免js将大于\uFFFF的 Unicode 字符，算作两个字符的 bug。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function countSymbols(string) {
  return Array.from(string).length;
}
countSymbols('x\uD83D\uDE80y'); //3 这里可以正确打印x\uD83D\uDE80y的长度。
</code></pre>
</div>
<p>上面的代码证明了用Array.from转换后可以正确打印Unicode字符的长度，上文中用扩展运算符就不可以。</p>
<h3 id="三arrayof">三、Array.of()</h3>
<p>Array.of()方法用于将一组值转换为数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = Array.of(1,2,3); //[1, 2, 3]
Array.of(1,2).length;      //2
</code></pre>
</div>
<p>这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致
Array()的行为有差异。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = Array(1,2,3); //[1, 2, 3]
let arr = Array(2);     //[empty × 2]
let arr = Array();      //[]
</code></pre>
</div>
<p>上面代码中，Array方法三个参数、一个参数、没有参数时，返回结果都不一样。只有当参数个数不少于2个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上指定的是数组的长度。</p>

<p>Array.of()基本上可以替代Array()和new Array()，并且不存在由于参数不同而导致的的重载。他的行为非常统一。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Array.of();           //[]
Array.of(undefined);  //[undefined]
Array.of(2);          //[2]
</code></pre>
</div>
<p>Array.of()总是返回参数值组成的数组。如果没有参数，就返回一个空数组。</p>

<p>Array.of()方法可以用下面的函数模拟实现。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function arrayOf(){
	return [].slice.call(arguments);
}
</code></pre>
</div>
<h3 id="四数组实例的copywithin方法">四、数组实例的copyWithin()方法</h3>
<p>数组实例的copyWithin()方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），返回当前数组。使用这个方法，会修改当前数组。</p>

<p>他有三个参数。</p>

<p>（参数1）target（必须）→从该位置开始替换数据。如果为负值，表示倒数。</p>

<p>（参数2）start  （可选） →从该位置选取要复制的源数据，默认为0。如果为负值，表示倒数。</p>

<p>（参数3）end  （可选）  →到该位置停止选取复制的值。如果为负值，表示倒数。</p>

<p>这三个都应该是数值，如果不是，会自动转为数值。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = [1,2,3,4,5].copyWithin(0,3); //[4, 5, 3, 4, 5]
</code></pre>
</div>
<p>上面代码表示将从3号位直到最后的成员（4，5）。复制到从0号位开始的位置，结果复制了原来的1和2。</p>

<p>下面是更多的例子。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>//将3号位复制到0号位
let arr = [1,2,3,4,5].copyWithin(0,3,4); //[4, 2, 3, 4, 5]

//-2从后面数是正着数的3号位，-1从后面数是正着数的4号位
let arr = [1,2,3,4,5].copyWithin(0,-2,-1); //[4, 2, 3, 4, 5]

//如果没有部署TypedArray 的 copyWithin 的环境，用下面的方法
[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4); //Int32Array [4, 2, 3, 4, 5]
</code></pre>
</div>
<p>【】上面最后一个例子看不懂</p>

<h3 id="五数组实例的find和findindex">五、数组实例的find()和findIndex()</h3>
<p>数组实例的find方法，用于找出第一个符合条件的数组成员。他的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var x = [1,2,3,4,-1].find( (n) =&gt; n &gt; 3); //4
</code></pre>
</div>
<p>上面代码找出第一个大于3的成员，所以返回4。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var x = [1,2,3,4,-1].find(function(value,index,arr){
	return value &gt; 3
})  //4
</code></pre>
</div>
<p>上面代码中，find方法的回调函数可以接收三个参数，依次为当前的值，当前的位置，和原数组。</p>

<p>数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合，返回-1。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var x = [1,2,3,4,-1].findIndex(function(value,index,arr){
	return value &gt; 3
}) //3
</code></pre>
</div>
<p>这两个方法都可以接收第二个参数，用来绑定回调函数的this对象。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>function func(x){
	return x &gt; this.age;
}
let obj = {
	name:'tx',
	age:'25'
};
var num = [20,25,26,30].find(func,obj); //26
</code></pre>
</div>
<p>上面代码中，find方法接收了第二个参数obj对象，回调函数func中的this指向obj对象。</p>

<p>另外，这两个方法都可以发现NaN，弥补了数组的indexOf方法的不足。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var idx = [NaN].indexOf(NaN);  						//-1
var idx = [NaN].findIndex(y =&gt; Object.is(NaN, y))   //0
</code></pre>
</div>
<p>上面代码中，indexOf方法无法识别数组的NaN成员，但是findIndex可以借助Object.is输出正确的结果。</p>
<h3 id="六数组实例的fill">六、数组实例的fill()</h3>
<p>fill方法使用给定值，填充一个数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = [1,2,'abc'].fill(0);       //[0, 0, 0]
let arrr = new Array(3).fill('abc'); //["abc", "abc", "abc"]
</code></pre>
</div>
<p>上面的代码表明，fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。</p>

<p>fill方法还可以接收第二个和第三个参数，用于指定填充的起始位置和结束位置。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = [1,2,3].fill('abc',1,2); //[1, "abc", 3]
</code></pre>
</div>
<p>上面代码表示：从1号位置开始，向原数组中填充abc，到2号位置结束。</p>

<p>注意，如果填充的类型为对象，那么被赋值的是对象的指针，而不是深拷贝对象。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let obj = { name:'tx'};
let arr = [1,2,3].fill(obj,1,2); 
console.log(arr);//[1, {name:'tx'}, 3]
obj.name = 'jl'; //修改原对象后,数组也会变化
console.log(arr);//[1, {name:'jl'}, 3]

let arr = new Array(3).fill([]);
console.log(arr);
arr[0].push(5);
console.log(arr); //[[5], [5], [5]]
</code></pre>
</div>
<h3 id="七数组实例的entrieskeysvalues">七.数组实例的entries()，keys()，values()</h3>
<p>ES6提供了三个新的方法entries()，keys()，values() ，这三个方法都用于遍历数组。他们都返回一个遍历器对象(详见Iterator一章)，可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>var arr = [1,2];
for(let index of arr.keys()){
	console.log(index); //0,1
}
for(let elm of arr.values()){
	console.log(elm);   //1,2
}
for(let [index,elm] of arr.entries()){
	console.log(index,elm); //0 1 , 1 2
}
</code></pre>
</div>
<p>如果不使用for…of循环，可以手动调用遍历器对象的next方法，进行遍历。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = [1,2];
let entries  = arr.entries();
console.log(entries.next().value);  //[0,1]
console.log(entries.next().value);  //[1,2]
console.log(entries.next().value);  //undefined
</code></pre>
</div>
<h3 id="八数组实例的includes">八、数组实例的includes()</h3>
<p>Array.prototype.includes方法返回一个布尔值，表示数组是否包含给定的值，与字符出的includes方法类似。ES6引入了该方法。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>[1,2,3].includes(1);   //true
[1,2,3].includes(4);   //false
[1,NaN].includes(NaN); //true
</code></pre>
</div>
<p>该方法的第二个参数表示开始搜索的位置，默认为0。如果为负数，则表示倒数，如果绝对值大于数组长度，则会重置为从0开始。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>[1, 2, 3].includes(3, 3);  // false
[1, 2, 3].includes(3, -1); // true
</code></pre>
</div>
<p>没有该方法之前，我们通常使用数组的indexOf方法，检查是否包含某个值。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>if(arr.indexOf('成员') != -1){
	//有要查找的成员
}
</code></pre>
</div>
<p>indexOf方法有两个缺点，一是不够语义化，他的含义是找到参数值首次出现的位置，所以要与不等于-1比较，表达起来不够直观。二是，它内部使用全等(===)进行判断，这会导致对NaN的误判。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>[NaN].indexOf(NaN) //-1
</code></pre>
</div>
<p>使用includes方法就不会有这个问题。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>[NaN].includes(NaN) //true
</code></pre>
</div>
<p>对于不支持该方法的环境，使用一个函数替代。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>const contains = (() =&gt;
  Array.prototype.includes
    ? (arr, value) =&gt; arr.includes(value)
    : (arr, value) =&gt; arr.some(el =&gt; el === value)
)();
contains([1,NaN],NaN); //true
</code></pre>
</div>
<p>【】arr.some是什么意思？</p>

<p>另外，Map 和 Set 数据结构有一个has方法，需要注意与includes区分。</p>

<p>Map 结构的has方法，是用来查找键名的，比如Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。</p>

<p>Set 结构的has方法，是用来查找值的，比如Set.prototype.has(value)、WeakSet.prototype.has(value)。</p>

<h3 id="九数组实例的flatflatmap方法">九、数组实例的flat()，flatMap()方法</h3>
<p>数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组”拉平”，变成一维的数组。返回新数组，对原数组没有影响。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = [1,2,3,[4,5]].flat() //[1, 2, 3, 4, 5]
</code></pre>
</div>
<p>flat()默认只会”拉平”一层，如果想要”拉平”多层的嵌套数组，可以给flat()方法传入一个整数参数，该参数表示的就是你要拉平的层数，默认为1。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = [1,2,[3,['abc']]].flat();   //[1,2,3,['abc']]
let arr = [1,2,[3,['abc']]].flat(2);  //[1, 2, 3, "abc"]
</code></pre>
</div>
<p>如果不确定有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = [1,2,[3,['abc']]].flat(Infinity);  //[1, 2, 3, "abc"]
let arr = [[[[1,2]]]].flat(Infinity);        //[1, 2]
</code></pre>
</div>
<p>如果原数组有空位，flat()会跳过空位。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = [1,,[3]].flat(Infinity);  //[1, 3]
</code></pre>
</div>
<p>flatMap()方法对原数组的每个成员执行一个函数(相当于执行Array.prototype.map())，然会对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = [1,2,3].flatMap((x) =&gt;[x,x*x]); //[1, 1, 2, 4, 3, 9]
//相当于
let arr = [[1,1],[2,4],[3,9]].flat();
</code></pre>
</div>
<p>flatMap()只能拉平一层数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr = [1,2,3].flatMap((x) =&gt;[[x*x]]); //[[1],[4],[9]]]
//相当于
let arr = [[[1]],[[4]],[[9]]].flat();
</code></pre>
</div>
<p>上面代码中，遍历函数返回的是一个双层的数组，但是默认只能展开一层，因此flatMap()返回的还是一个潜逃数组。</p>

<p>flatMap()方法的参数是一个遍历函数，该函数可以接收三个参数，分别是当前数组的成员、当前数组成员的位置(从0开始)、原数组。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>arr.flatMap(function callback(currentValue[, index[, array]]) {
  // ...
}[, thisArg])
</code></pre>
</div>
<p>flatMap()方法的第二个参数是：用来绑定前面循环函数的this。</p>
<h3 id="十数组的空位">十、数组的空位</h3>
<p>数组的空位是指：数组的某一个位置没有值。比如Array()构造函数返回的数组都是空位组成的。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Array(2)    //[ , ]
new Array(2)//[ , ]
</code></pre>
</div>
<p>注意：空位不是undefined，一个位置的值等于undefined，依然是有值的，空位是没有任何值，in运算符可以说明这一点。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>0 in [undefined, undefined] // true
0 in [, ,]                  // false
</code></pre>
</div>
<p>上面代码说明，第一个数组0号位置是有值的，第二个0号数组是没有值的。</p>

<p>ES5对空位的处理，已经很不一致了，大多数情况下会忽略空位。</p>

<p>forEach(), filter(), reduce(), every() 和some()都会跳过空位。</p>

<p>map()会跳过空位，但会保留这个值</p>

<p>join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串</p>
<div class="highlighter-rouge"><pre class="highlight"><code>//toString()方法
[,'a',undefined,null].toString()         //",a,,"
//join()方法
[,'a',undefined,null].join('#')          //"#a##"
// forEach方法
[,'a'].forEach((x,i) =&gt; console.log(i)); // 1
// filter方法
['a',,'b'].filter(x =&gt; true)             // ['a','b']
// every方法
[,'a'].every(x =&gt; x==='a')               // true
// reduce方法
[1,,2].reduce((x,y) =&gt; x+y)              // 3
// some方法
[,'a'].some(x =&gt; x !== 'a')              // false
// map方法
[,'a'].map(x =&gt; 1)                       // [,1]
</code></pre>
</div>
<p>ES6明确将空位转为undefined。</p>

<p>Array.from()方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Array.from([1,,3])//[1, undefined, 3]
</code></pre>
</div>
<p>扩展运算符(…)也会将空位填充undefined。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>[...[1,,3]] //[1, undefined, 3]
</code></pre>
</div>
<p>copyWithin()方法会连空位一起复制。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>[1,,3].copyWithin(); //[1, empty, 3]
</code></pre>
</div>
<p>fill会将空位视为正常的数组位置。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Array(3).fill('a') //["a", "a", "a"]
</code></pre>
</div>
<p>for…of循环也会遍历空位。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>let arr =  [, , ,];
for(let i of arr){
	console.log(1); //打印三次
}
</code></pre>
</div>
<p>上面代码中，arr数组有三个空位，for…of没有忽略他们。如果改成map方法遍历，空位是会跳过的。</p>

<p>entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>// entries()
[...[,'a'].entries()]        // [[0,undefined], [1,"a"]]

// keys()
[...[,'a'].keys()]           // [0,1]

// values()
[...[,'a'].values()]         // [undefined,"a"]

// find()
[,'a'].find(x =&gt; true)       // undefined

// findIndex()
[,'a'].findIndex(x =&gt; true)  // 0
</code></pre>
</div>
<p>由于空位的处理规则非常不统一，所以尽量避免出现空位。</p>


   
            </div>
            
          </div>
          
                <div class="next_page_box">
                  <div class="read_next">阅读下一篇文章</div>
                  <div class="next_page">
                    <a class="" href="http://localhost:4000/tec/2018/12/23/%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95.html" data-post-href="http://localhost:4000/tec/2018/12/23/%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95.html">
                      <h4>ES6基础-函数的扩展</h4>
                      <div></div>
                    </a>
                  </div>
                </div>
          
       </div>
    </div>
  </body>
<script src="/source/js/highlight.min.js"></script>
<script type="text/javascript" src="/source/js/jquery.js"></script>
<script type="text/javascript" src="/source/js/TweenMax.min.js"></script>
<script type="text/javascript" src="/source/js/DrawSVGPlugin.min.js"></script>
<script type="text/javascript" src="/source/js/tween.js"></script>
<script type="text/javascript" src="/source/js/animation.js"></script>
  <script type="text/javascript" src="/source/js/index.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
    $(document).ready(function(){
      //评论
        $('.comments').on('click',function(e){
          e.preventDefault();
          $('#lv-container').show();
        });
    })
  </script>
</html>