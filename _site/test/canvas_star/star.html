<<<<<<< HEAD
<<<<<<< HEAD
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>canvas实现的旋转星空效果</title>
	<style type="text/css">
		body{
			background-color: #000;
		}
		h1{
			color: #fff;
		}
		.header{
			position: relative;
			height: 1000px;
			overflow: hidden;
		}
		.starCanvas{
			position: absolute;
			width: 1920px;
			height: 100%;
			left: 50%;
			margin-left: -960px;
		}
	</style>
</head>
<body>
	<div class="container">
		<h1>canvas实现的旋转星空效果</h1>
		<div class="header">
			<canvas class="starCanvas" id="starCanvas"></canvas>
		</div>
	</div>
</body>
<script type="text/javascript">
(function(){
	var canvas = document.getElementById('starCanvas');
	var context = canvas.getContext("2d"); 

	var stars = {},
		particleIndex = 0,
		settings={
			r : 1400,
			height:260,
			density:300,
			maxLeft :100,
			groundLevel:canvas.height,
			leftWall : 0 ,
			rightWall:canvas.width,
			alpha:0.0,
			maxAlpha:1
		};
	var getMinRandom = function(){
		var rand = Math.random();
		//step的大小决定了星星的聚拢程度
		var step = Math.ceil(1 / (1 - rand));
		var arr = [];
		for(var i = 0 ; i< step ; i++){
			arr.push(Math.random());
		}
		return Math.min.apply(null,arr);
	};
	function resizeCanvas() {
        canvas.width = 1920;
        canvas.height = 800;
        settings.rightWall = canvas.width;
        settings.groundLevel = canvas.height;
        settings.height = 260 + (canvas.height - 800) / 2;
        redraw();
    }

    resizeCanvas();

    window.addEventListener('resize', resizeCanvas);

	function redraw(){
		context.clearPath(0,0,canvas.width,canvas.height);
		context.fillStyle = "rgba(0,0,0,0)";
		context.fillRect(0,0,canvas.width,canvas.height);
	}
	function Star(){
		//圆的轨迹方程为:(x-a)²+(y-b)²=r²
		//已知x , 则y = Math.sqrt(r²-(x-a)²) + b;
		//圆心(a,b);
		//在本例中 
		//圆心坐标(canvas.width/2, canvas.height - 260 + r);
		var  a = canvas.width / 2 ,
			 b = canvas.height - settings.height + settings.r ;
	    //已知x横坐标随机
		this.x = Math.floor(Math.random() * canvas.width);
		//纵坐标需要在圆弧以上
		//越往上 ， 越稀疏
		this.offsety = getMinRandom() * (canvas.height - settings.height);

		this.y  = b - Math.sqrt(settings.r * settings.r - (this.x - a)*(this.x -a )) - this.offsety;

		this.vx = Math.random() * 0.05 + 0.025;             //水平偏移，也是移动速度

		//星星的尺寸
		this.particleSize = 0.5  + (Math.random() + 0.1 / 4);
		particleIndex ++ ; 
		stars[particleIndex] = this;
		this.alpha = 0;
		this.maxAlpha = 0.3 + (this.y/canvas.height) * Math.random() * 0.8;
		this.alphaAction = 1;


	}
	Star.prototype.draw = function(){
		//横坐标移动
		this.x += this.vx ; 
		//根据切线方向进行偏移
		//y坐标
		this.y = canvas.height - settings.height + settings.r - Math.sqrt(settings.r * settings.r - (this.x - canvas.width/2)*(this.x - canvas.width/2)) - this.offsety ; 

		//透明度慢慢起来
		if(this.alphaAction == 1){
			if(this.alpha < this.maxAlpha){
				this.alpha += 0.005;
			}else{
				this.alphaAction = -1;
			}
		}else{
			if(this.alpha > 0.2){
				this.alpha -= 0.002;
			}else{
				this.alphaAction = 1;
			}

		}

		if( this.x + (this.particleSize*2) >= settings.rightWall){
			//x到左侧
			this.x = this.x  - settings.rightWall;
		}

		//绘制星星
		context.beginPath();
		context.fillStyle = "rgba(255,255,255," + this.alpha.toString() + ")";
		context.arc(this.x,this.y, this.particleSize , 0 , Math.PI*2 , true);
		context.closePath();
		context.fill();

	}

	function render(){
		redraw();

		//星星的数目
		//ie下cpu性能有限，数目小
		var length = 400;
        if (!history.pushState) {
			// IE9
            length = 200;
        } else if (document.msHidden != undefined) {
			// IE10+
            length = 300;
        }
     
        if ( Object.keys(stars).length > length ) {
            settings.density = 0;
        }



		for(var i = 0 ; i < settings.density ;i++){
			if(Math.random() > 0.97){
				new Star();
			}
		}
		//星星时时移动
		for(var i in stars){
			stars[i].draw();
		}
		requestAnimationFrame(render);
	}

	if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = function(fn) {
            setTimeout(fn, 17);
        };
    }

	render();
})()
</script>
=======
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>canvas实现的旋转星空效果</title>
	<style type="text/css">
		body{
			background-color: #000;
		}
		h1{
			color: #fff;
		}
		.header{
			position: relative;
			height: 1000px;
			overflow: hidden;
		}
		.starCanvas{
			position: absolute;
			width: 1920px;
			height: 100%;
			left: 50%;
			margin-left: -960px;
		}
	</style>
</head>
<body>
	<div class="container">
		<h1>canvas实现的旋转星空效果</h1>
		<div class="header">
			<canvas class="starCanvas" id="starCanvas"></canvas>
		</div>
	</div>
</body>
<script type="text/javascript">
(function(){
	var canvas = document.getElementById('starCanvas');
	var context = canvas.getContext("2d"); 

	var stars = {},
		particleIndex = 0,
		settings={
			r : 1400,
			height:260,
			density:300,
			maxLeft :100,
			groundLevel:canvas.height,
			leftWall : 0 ,
			rightWall:canvas.width,
			alpha:0.0,
			maxAlpha:1
		};
	var getMinRandom = function(){
		var rand = Math.random();
		//step的大小决定了星星的聚拢程度
		var step = Math.ceil(1 / (1 - rand));
		var arr = [];
		for(var i = 0 ; i< step ; i++){
			arr.push(Math.random());
		}
		return Math.min.apply(null,arr);
	};
	function resizeCanvas() {
        canvas.width = 1920;
        canvas.height = 800;
        settings.rightWall = canvas.width;
        settings.groundLevel = canvas.height;
        settings.height = 260 + (canvas.height - 800) / 2;
        redraw();
    }

    resizeCanvas();

    window.addEventListener('resize', resizeCanvas);

	function redraw(){
		context.clearPath(0,0,canvas.width,canvas.height);
		context.fillStyle = "rgba(0,0,0,0)";
		context.fillRect(0,0,canvas.width,canvas.height);
	}
	function Star(){
		//圆的轨迹方程为:(x-a)²+(y-b)²=r²
		//已知x , 则y = Math.sqrt(r²-(x-a)²) + b;
		//圆心(a,b);
		//在本例中 
		//圆心坐标(canvas.width/2, canvas.height - 260 + r);
		var  a = canvas.width / 2 ,
			 b = canvas.height - settings.height + settings.r ;
	    //已知x横坐标随机
		this.x = Math.floor(Math.random() * canvas.width);
		//纵坐标需要在圆弧以上
		//越往上 ， 越稀疏
		this.offsety = getMinRandom() * (canvas.height - settings.height);

		this.y  = b - Math.sqrt(settings.r * settings.r - (this.x - a)*(this.x -a )) - this.offsety;

		this.vx = Math.random() * 0.05 + 0.025;             //水平偏移，也是移动速度

		//星星的尺寸
		this.particleSize = 0.5  + (Math.random() + 0.1 / 4);
		particleIndex ++ ; 
		stars[particleIndex] = this;
		this.alpha = 0;
		this.maxAlpha = 0.3 + (this.y/canvas.height) * Math.random() * 0.8;
		this.alphaAction = 1;


	}
	Star.prototype.draw = function(){
		//横坐标移动
		this.x += this.vx ; 
		//根据切线方向进行偏移
		//y坐标
		this.y = canvas.height - settings.height + settings.r - Math.sqrt(settings.r * settings.r - (this.x - canvas.width/2)*(this.x - canvas.width/2)) - this.offsety ; 

		//透明度慢慢起来
		if(this.alphaAction == 1){
			if(this.alpha < this.maxAlpha){
				this.alpha += 0.005;
			}else{
				this.alphaAction = -1;
			}
		}else{
			if(this.alpha > 0.2){
				this.alpha -= 0.002;
			}else{
				this.alphaAction = 1;
			}

		}

		if( this.x + (this.particleSize*2) >= settings.rightWall){
			//x到左侧
			this.x = this.x  - settings.rightWall;
		}

		//绘制星星
		context.beginPath();
		context.fillStyle = "rgba(255,255,255," + this.alpha.toString() + ")";
		context.arc(this.x,this.y, this.particleSize , 0 , Math.PI*2 , true);
		context.closePath();
		context.fill();

	}

	function render(){
		redraw();

		//星星的数目
		//ie下cpu性能有限，数目小
		var length = 400;
        if (!history.pushState) {
			// IE9
            length = 200;
        } else if (document.msHidden != undefined) {
			// IE10+
            length = 300;
        }
     
        if ( Object.keys(stars).length > length ) {
            settings.density = 0;
        }



		for(var i = 0 ; i < settings.density ;i++){
			if(Math.random() > 0.97){
				new Star();
			}
		}
		//星星时时移动
		for(var i in stars){
			stars[i].draw();
		}
		requestAnimationFrame(render);
	}

	if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = function(fn) {
            setTimeout(fn, 17);
        };
    }

	render();
})()
</script>
>>>>>>> 5d4e353f4fdf785248196093a1ae0ec0a84c8221
=======
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>canvas实现的旋转星空效果</title>
	<style type="text/css">
		body{
			background-color: #000;
		}
		h1{
			color: #fff;
		}
		.header{
			position: relative;
			height: 1000px;
			overflow: hidden;
		}
		.starCanvas{
			position: absolute;
			width: 1920px;
			height: 100%;
			left: 50%;
			margin-left: -960px;
		}
	</style>
</head>
<body>
	<div class="container">
		<h1>canvas实现的旋转星空效果</h1>
		<div class="header">
			<canvas class="starCanvas" id="starCanvas"></canvas>
		</div>
	</div>
</body>
<script type="text/javascript">
(function(){
	var canvas = document.getElementById('starCanvas');
	var context = canvas.getContext("2d"); 

	var stars = {},
		particleIndex = 0,
		settings={
			r : 1400,
			height:260,
			density:300,
			maxLeft :100,
			groundLevel:canvas.height,
			leftWall : 0 ,
			rightWall:canvas.width,
			alpha:0.0,
			maxAlpha:1
		};
	var getMinRandom = function(){
		var rand = Math.random();
		//step的大小决定了星星的聚拢程度
		var step = Math.ceil(1 / (1 - rand));
		var arr = [];
		for(var i = 0 ; i< step ; i++){
			arr.push(Math.random());
		}
		return Math.min.apply(null,arr);
	};
	function resizeCanvas() {
        canvas.width = 1920;
        canvas.height = 800;
        settings.rightWall = canvas.width;
        settings.groundLevel = canvas.height;
        settings.height = 260 + (canvas.height - 800) / 2;
        redraw();
    }

    resizeCanvas();

    window.addEventListener('resize', resizeCanvas);

	function redraw(){
		context.clearPath(0,0,canvas.width,canvas.height);
		context.fillStyle = "rgba(0,0,0,0)";
		context.fillRect(0,0,canvas.width,canvas.height);
	}
	function Star(){
		//圆的轨迹方程为:(x-a)²+(y-b)²=r²
		//已知x , 则y = Math.sqrt(r²-(x-a)²) + b;
		//圆心(a,b);
		//在本例中 
		//圆心坐标(canvas.width/2, canvas.height - 260 + r);
		var  a = canvas.width / 2 ,
			 b = canvas.height - settings.height + settings.r ;
	    //已知x横坐标随机
		this.x = Math.floor(Math.random() * canvas.width);
		//纵坐标需要在圆弧以上
		//越往上 ， 越稀疏
		this.offsety = getMinRandom() * (canvas.height - settings.height);

		this.y  = b - Math.sqrt(settings.r * settings.r - (this.x - a)*(this.x -a )) - this.offsety;

		this.vx = Math.random() * 0.05 + 0.025;             //水平偏移，也是移动速度

		//星星的尺寸
		this.particleSize = 0.5  + (Math.random() + 0.1 / 4);
		particleIndex ++ ; 
		stars[particleIndex] = this;
		this.alpha = 0;
		this.maxAlpha = 0.3 + (this.y/canvas.height) * Math.random() * 0.8;
		this.alphaAction = 1;


	}
	Star.prototype.draw = function(){
		//横坐标移动
		this.x += this.vx ; 
		//根据切线方向进行偏移
		//y坐标
		this.y = canvas.height - settings.height + settings.r - Math.sqrt(settings.r * settings.r - (this.x - canvas.width/2)*(this.x - canvas.width/2)) - this.offsety ; 

		//透明度慢慢起来
		if(this.alphaAction == 1){
			if(this.alpha < this.maxAlpha){
				this.alpha += 0.005;
			}else{
				this.alphaAction = -1;
			}
		}else{
			if(this.alpha > 0.2){
				this.alpha -= 0.002;
			}else{
				this.alphaAction = 1;
			}

		}

		if( this.x + (this.particleSize*2) >= settings.rightWall){
			//x到左侧
			this.x = this.x  - settings.rightWall;
		}

		//绘制星星
		context.beginPath();
		context.fillStyle = "rgba(255,255,255," + this.alpha.toString() + ")";
		context.arc(this.x,this.y, this.particleSize , 0 , Math.PI*2 , true);
		context.closePath();
		context.fill();

	}

	function render(){
		redraw();

		//星星的数目
		//ie下cpu性能有限，数目小
		var length = 400;
        if (!history.pushState) {
			// IE9
            length = 200;
        } else if (document.msHidden != undefined) {
			// IE10+
            length = 300;
        }
     
        if ( Object.keys(stars).length > length ) {
            settings.density = 0;
        }



		for(var i = 0 ; i < settings.density ;i++){
			if(Math.random() > 0.97){
				new Star();
			}
		}
		//星星时时移动
		for(var i in stars){
			stars[i].draw();
		}
		requestAnimationFrame(render);
	}

	if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = function(fn) {
            setTimeout(fn, 17);
        };
    }

	render();
})()
</script>
>>>>>>> 4006a03c6a87402aebff97455c2d5f53432de636
</html>